{"componentChunkName":"component---src-templates-blog-post-js","path":"/cs/운영체제/프로세스&쓰레드/","result":{"data":{"site":{"siteMetadata":{"title":"jinwook567"}},"markdownRemark":{"id":"96f083a2-5aa5-5b8a-9364-c6733018eeb4","excerpt":"프로세스 프로세스는 실행중인 프로그램으로, 실행 파일이 memory에 적재되어 CPU를 할당받아 실행되는 것을 process라고 한다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받고 이것들을 총칭하여 프로세스라고 한다. 프로세스 메모리 구조 code…","html":"<h1>프로세스</h1>\n<p><strong>프로세스는 실행중인 프로그램으로,</strong> 실행 파일이 memory에 적재되어 CPU를 할당받아 실행되는 것을 process라고 한다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받고 이것들을 총칭하여 프로세스라고 한다.</p>\n<h2>프로세스 메모리 구조</h2>\n<ol>\n<li>code 영역 - 실행한 프로그램의 코드가 저장되는 메모리 영역</li>\n<li>data 영역 - 프로그램의 전역 변수가 저장되는 영역</li>\n<li>heap 영역 - 동적으로 할당되는 메모리 영역</li>\n<li>stack 영역 - 함수 호출 시 생성되는 지역변수, 매개변수가 저장되는 영역</li>\n</ol>\n<h2>프로세스 제어 블록(Process Control Block, PCB)</h2>\n<p>PCB는 특정 프로세스의 중요한 정보를 저장하고 있는 운영체제의 자료구조이다. 운영체제는 프로세스 관리를 위해 프로세스 생성과 동시에 고유한 PCB를 생성한다. 프로세스 전환이 발생하면 진행하던 작업을 종료하고 CPU를 반환해야 하는데 이 때 작업의 진행상황을 전부 PCB에 저장해놓는다. 이를 Context Switch라고 한다. 다시 CPU를 할당받으면 PCB 내역을 바탕으로 다시 작업을 수행한다.</p>\n<h3>PCB 구성</h3>\n<ul>\n<li>프로세스 식별자: process id</li>\n<li>프로세스 상태: new, ready, running 등</li>\n<li>프로그램 카운터: 프로세스가 다음에 실행할 주소</li>\n<li>CPU 스케쥴링 정보: 프로세스의 우선순위</li>\n<li>메모리 관리 정보: 페이지 테이블 또는 세그먼트 테이블과 같은 정보를 포함</li>\n</ul>\n<h2>멀티 프로세스</h2>\n<p>멀티 프로세스란 2개 이상의 프로세스가 동시에 실행되는 것을 의미한다. 동시에 실행하는 방법은 2가지이다. 1개의 CPU Core를 사용하여 여러개의 프로세스를 빠르게 전환하며 처리하는 방식, 여러개의 CPU Core를 사용하여 각각의 process를 처리하는 방식이다.</p>\n<h2>멀티 프로세스간 데이터 통신 방법</h2>\n<p>멀티 프로세스에서 프로세스끼리 원칙적으로는 데이터를 공유할 수 없다. 프로세스는 독립적인 주소 공간을 갖기 때문이다. 하지만 경우에 따라 운영체제는 프로세스 간 통신(IPC)를 제공한다. IPC 방식에는 공유 메모리 방식과 메시지 전달 방식이 있다.</p>\n<h3>공유 메모리 방식</h3>\n<p>process들이 주소 공간 일부를 공유한다. 공유한 메모리에 읽기/쓰기를 통해서 통신을 수행한다. 커널의 관여 없이 데이터를 통신할 수 있기 때문에 속도가 빠르다는 장점이 있지만, 동시에 같은 메모리 위치에 접근하게 되면 일관성 문제가 발생할 수 있다.</p>\n<h3>메시지 전달 방식</h3>\n<p>커널을 통해서 데이터를 전달해준다. 커널이 개입하기에 속도가 느리다는 단점이 있지만, 일관성 문제가 발생하지 않기 때문에 적은 데이터를 공유할 때 유리하다.</p>\n<p><em>커널이란 운영체제 중에서 항상 메모리에 올라가 있는 운영체제의 핵심 부분으로 컴퓨터 자원들을 관리하는 역할을 수행한다. 컴퓨터 자원으로는 CPU,메모리,파일,네트워크 등이 있다.</em></p>\n<h2>CPU의 처리 방식</h2>\n<p>CPU는 PC Register라는 다음에 실행될 명령어가 저장된 주솟값을 참조하여 연산을 수행한다. 프로세스가 전환될 때, 다른 프로세스의 PC Register가 등록된다.</p>\n<h2>Context Switch</h2>\n<p>한 프로세스에서 다른 프로세스로 CPU 제어권을 넘겨주는 것을 말한다. 이전의 프로세스 상태를 PCB에 저장하여 보관하고 새로운 프로세스의 PCB를 읽어서 보관된 상태를 복구한다.</p>\n<h1>쓰레드</h1>\n<p>쓰레드는 프로세스의 실행의 단위라고 할 수 있다. 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다. (스택을 제외한 나머지 메모리 영역을 공유)</p>\n<h2>stack을 스레드마다 독립적으로 할당하는 이유</h2>\n<p><strong>thread는 프로세스 내에서 독립적으로 기능을 실행한다. 즉 독립적으로 함수를 호출함을 의미한다.</strong> 독립적으로 동작하기 위해서는 thread의 stack memory 영역이 독립적이여야 한다.</p>\n<h2>PC Register를 스레드마다 독립적으로 할당하는 이유</h2>\n<p>한 프로세스 내에서도 thread끼리 context switch가 일어나기 때문에.</p>\n<h2>멀티 쓰레드</h2>\n<p>하나의 process 내에서도 여러 작업이 있다. 이런 작업들을 병렬적으로 처리하기 위해서 multi thread를 사용한다.</p>\n<h2>멀티 쓰레드의 장점</h2>\n<p>프로세스를 이용하여 동시에 처리하던 일을 쓰레드로 구현할 경우 메모리 공간과 시스템 자원 소모가 줄어든다. 쓰레드간의 통신이 필요한 경우 별도의 자원을 사용하지 않고 메모리 영역을 공유하기 때문이다. 즉 프로세스 간의 통신 방법에 비해 쓰레드 간의 통신 방법이 훨씬 간단하다. 쓰레드의 context switch는 프로세스의 context switch와 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.</p>\n<h2>멀티 쓰레드의 문제점</h2>\n<p>멀티 프로세스는 프로세스간 공유하는 자원이 없기 때문에 동일한 자원에 동시에 접근하는 일이 없었지만 멀티 쓰레드는 이 부분을 신경써줘야한다. 어떤 쓰레드가 다른 쓰레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다. 따라서 멀티 쓰레드 환경에서는 동기화 작업이 필요하다.</p>\n<p>또한 멀티 쓰레드는 적은 메모리 공간과 Context Switch가 빠르다는 장점이 있지만 오류로 인해 하나의 쓰레드가 죽으면 전체 쓰레드가 죽을 수 있다.</p>\n<h3>동기화 문제 해결 방안</h3>\n<p>mutex, semaphore 기법을 사용하여 해결할 수 있다.</p>\n<p>mutex란 1개의 스레드만이 공유 자원에 접근할 수 있도록 하여 경쟁 상황을 방지하는 기법이다. 하나의 쓰레드가 공유 자원에 접근하여 lock을 걸면, 다른 쓰레드는 lock이 풀릴 때 까지 해당 자원에 접근할 수 없다.</p>\n<p>semaphore란 S개의 thread만이 공유 자원에 접근할 수 있도록 하여 경쟁 상황을 방지하는 기법이다. 하나의 쓰레드가 자원에 접근할 떄마다 세마포 값을 감소시키고, 자원을 방출할 때는 세마포 값을 증가시킨다. 이 때 세마포의 값이 0이 되면 모든 자원이 사용 중임을 의미하고 0보다 커질 때까지 자원 사용을 block한다.</p>\n<h1>교착상태(데드락)</h1>\n<p>두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태로, 2개 이상의 thead가 각기 자원을 점유하고 있고, 서로의 자원을 기다릴 때 무한 대기가 발생한다.</p>\n<h2>데드락이 발생할 조건 4가지</h2>\n<ol>\n<li>\n<p>상호 배제</p>\n</li>\n<li>\n<p>점유 대기</p>\n</li>\n<li>\n<p>비선점</p>\n</li>\n<li>\n<p>순환 대기</p>\n</li>\n</ol>","frontmatter":{"title":"프로세스와 쓰레드","date":"October 18, 2022","description":"프로세스와 쓰레드의 개념과 차이점"}},"previous":{"fields":{"slug":"/tech/React/GlobalState/"},"frontmatter":{"title":"React의 전역 상태 관리"}},"next":{"fields":{"slug":"/programming/이펙티브타입스크립트/2장/"},"frontmatter":{"title":"이펙티브 타입스크립트 2장"}}},"pageContext":{"id":"96f083a2-5aa5-5b8a-9364-c6733018eeb4","previousPostId":"d1ab9ee2-c0be-5477-b15c-54461acf94e5","nextPostId":"4f71d23a-e4d0-5efb-a1b0-e52d6c4f76bd"}},"staticQueryHashes":["2841359383","3257411868"]}