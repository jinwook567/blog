{"componentChunkName":"component---src-templates-post-template-tsx","path":"/cs/web/브라우저/","result":{"pageContext":{"node":{"fields":{"slug":"/cs/web/브라우저/"},"excerpt":"브라우저 목적 브라우저의 주요 기능은 사용자가 명시한 자원을 서버에 요청하고 이를 브라우저에 표시하는 것이다.\n대부분 HTML 문서이며, 브라우저는 HTML 파일을 해석하여 화면에 보여주는 역할을 한다.\n헤석 과정에서 요즘 브라우저는 W3C에서 정하는 표준 명세를 대부분 따라서 호환성이 과거에 비해 크게 향상되었다. 브라우저의 구성 브라우저는 7개의 부분으로 구성되어 있다. 사용자 인터페이스 - 주소 표시줄, 이전/다음/새로고침 버튼 등 웹페…","frontmatter":{"date":"2022-10-15T00:00:00.000Z","description":"작성중.","title":"브라우저에 대해서"},"html":"<h1>브라우저 목적</h1>\n<p>브라우저의 주요 기능은 사용자가 명시한 자원을 서버에 요청하고 이를 브라우저에 표시하는 것이다.\n대부분 HTML 문서이며, 브라우저는 HTML 파일을 해석하여 화면에 보여주는 역할을 한다.\n헤석 과정에서 요즘 브라우저는 W3C에서 정하는 표준 명세를 대부분 따라서 호환성이 과거에 비해 크게 향상되었다.</p>\n<h1>브라우저의 구성</h1>\n<p>브라우저는 7개의 부분으로 구성되어 있다.</p>\n<ol>\n<li><strong>사용자 인터페이스</strong> - 주소 표시줄, 이전/다음/새로고침 버튼 등 웹페이지를 제외하고 사용자와 상호 작용하는 인터페이스이다.</li>\n<li><strong>브라우저 엔진</strong> - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어한다.</li>\n<li><strong>렌더링 엔진</strong> - 요청한 콘텐츠를 표시한다. HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 보여준다.</li>\n<li><strong>통신(Networking)</strong> - HTTP 요청과 같은 네트워크 호출에 사용된다. 플랫폼의 독립적인 인터페이스로 구성되어 있다.</li>\n<li><strong>자바스크립트 해석기</strong> - JS 코드를 해석하고 실행한다.</li>\n<li><strong>UI 백엔드</strong> - 콤보 박스와 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않았기에 OS 사용자 인터페이스 체계를 따른다.</li>\n<li><strong>자료 저장소</strong> - 쿠키, 로컬 스토리지 등 브라우저에 데이터를 저장할 수 있는 공간.</li>\n</ol>\n<h1>브라우저의 렌더링 과정</h1>\n<h1>브라우저의 이벤트 루프</h1>\n<p><a href=\"https://www.youtube.com/watch?v=YpQTeIqjC4o\">우테코 브라우저의 이벤트 루프</a></p>\n<h1>참고 자료</h1>\n<p><a href=\"https://d2.naver.com/helloworld/59361\">네이버 D2 자료</a></p>\n<p><a href=\"https://d2.naver.com/helloworld/5237120\">네이버 D2 자료2</a></p>","id":"cce72fd4-a726-5f4c-9012-179561fd66a4"},"previous":{"fields":{"slug":"/알고리즘/스타수열/"},"excerpt":"문제 링크 해결 전략 처음에 이 문제를 완전탐색 형태로 해결하고자 하였다. a의 부분 수열을 모두 만들고, 스타 수열인지 확인하는 방식으로 알고리즘을 짰다. 하지만 이 방식은, a의 길이가 최대 500,000이므로 절대 만족할 수 없다. 조합의 경우 O(2^n)의 시간 복잡도를 가지기 때문이다. 그렇다면 반대로 생각해봐야 한다. 모든 부분 수열을 만들어보고 스타 수열인지 검증하는 대신, 주어진 배열을 활용해서 직접 스타 수열을 만들어보면 된다…","frontmatter":{"date":"2022-10-13T00:00:00.000Z","description":"백트래킹","title":"스타수열"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/70130\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>처음에 이 문제를 완전탐색 형태로 해결하고자 하였다. a의 부분 수열을 모두 만들고, 스타 수열인지 확인하는 방식으로 알고리즘을 짰다. 하지만 이 방식은, a의 길이가 최대 500,000이므로 절대 만족할 수 없다. 조합의 경우 O(2^n)의 시간 복잡도를 가지기 때문이다.</p>\n<p>그렇다면 <strong>반대로 생각해봐야 한다.</strong> 모든 부분 수열을 만들어보고 스타 수열인지 검증하는 대신, 주어진 배열을 활용해서 직접 스타 수열을 만들어보면 된다!</p>\n<p>스타수열을 만들 때, 우리는 중복된 숫자가 꼭 필요하다. 따라서 중복된 숫자가 많을수록 더 길이가 긴 스타수열을 만들 수 있다. 하지만 중복된 숫자가 많다고 해서 꼭 스타수열의 길이가 긴 것은 아니기에, 중복된 숫자의 개수가 큰 순서대로 검증해나가는 백트래킹 방식을 사용하면 된다.</p>\n<p><code>[1,1,1,1,1,1,1,1,1,1,2,3,2,3,2]</code>과 같은 배열의 경우 1이 가장 많은 중복된 숫자지만, 1을 교집합으로 두었을 때 스타 수열을 만들 수 없다. 1이 연속적으로 배치되어 있어 i번쨰와 i+1번째가 같기 때문이다. 따라서 그 다음으로 중복된 개수가 많은 2를 검증해야 한다.</p>\n<p>스타 수열 조건을 만족하는 부분 수열들을 찾아나가면서 합하는 방식으로 스타 수열의 최대 길이를 구할 것이다. 최대한 길이가 긴 스타 수열을 구하기 위해서는 좌측부터 만족시키면서 나가면 된다. 그래야 우측에 남은 배열의 길이가 길어져 더 길이가 긴 부분 수열을 만들 수 있다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-js\">function solution(a) {\n  //배열 내에서, 중복된 숫자의 순서가 많은 순서대로 정렬한다.\n  const obj = {}\n  a.forEach(v => {\n    if (!obj[v]) obj[v] = 1\n    else obj[v] += 1\n  })\n\n  const sameNumberCounts = Object.entries(obj).sort((a, b) => b[1] - a[1])\n\n  //스타 수열을 만족하는 최대 부분 수열을 찾는다.\n  let answer = 0\n\n  for (let [number, cnt] of sameNumberCounts) {\n    number = Number(number)\n    if (answer > cnt) break\n\n    let len = 0\n    for (let i = 0; i &#x3C; a.length; i++) {\n      if (a[i + 1] === undefined) continue\n\n      if (a[i] === number &#x26;&#x26; a[i + 1] !== number) {\n        len += 2\n        i++\n        continue\n      }\n      //좌측부터 만족하는지 확인, 좌측부터 만족하는지 확인해야 남는 우측 길이가 김.\n\n      if (a[i] !== number &#x26;&#x26; a[i + 1] === number) {\n        len += 2\n        i++\n        continue\n      }\n      //좌측이 만족하지 않는다면 우측으로 확인\n    }\n    answer = Math.max(answer, len)\n  }\n  return answer\n}\n</code></pre>","id":"46cdd6bd-2022-521c-8533-167ea9cf86fb"},"next":{"fields":{"slug":"/programming/이펙티브타입스크립트/1장/"},"excerpt":"타입스크립트와 자바스크립트의 관계 타입스크립트는 자바스크립트의 상위 집합이다. 즉 모든 자바스크립트 프로그램은 타입스크립트 프로그램이다. 하지만 타입스크립트의 경우 타입 선언 등 별도의 문법을 가지고 있기 때문에 유효한 자바스크립트 프로그램이라고는 할 수 없다. 자바스크립트가 타입스크립트 프로그램이기에 마이그레이션 하는데 큰 이점을 가진다. 타입 시스템 타입스크립트는 자바스크립트에 타입 시스템을 더한 것이다. 타입 시스템의 목표 중 하나는 런…","frontmatter":{"date":"2022-10-17T00:00:00.000Z","description":"타입스크립트 알아보기","title":"이펙티브 타입스크립트 1장"},"html":"<h1>타입스크립트와 자바스크립트의 관계</h1>\n<p>타입스크립트는 자바스크립트의 상위 집합이다. 즉 모든 자바스크립트 프로그램은 타입스크립트 프로그램이다. 하지만 타입스크립트의 경우 타입 선언 등 별도의 문법을 가지고 있기 때문에 유효한 자바스크립트 프로그램이라고는 할 수 없다. 자바스크립트가 타입스크립트 프로그램이기에 마이그레이션 하는데 큰 이점을 가진다.</p>\n<h2>타입 시스템</h2>\n<p>타입스크립트는 자바스크립트에 타입 시스템을 더한 것이다. 타입 시스템의 목표 중 하나는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것이다. '정적'타입 시스템이라는 것은 바로 이런 특징을 말하는 것이다. 하지만 타입 체커가 모든 오류를 찾아내지는 않으니 유의해야한다.</p>\n<p>타입을 선언하지 않아도 타입스크립트는 오류는 발생시키지 않지만 의도와 다르게 동작하는 코드를 찾아내기도 한다. 하지만 정확하지 않기에 명시적으로 타입을 선언해야한다.</p>\n<pre><code class=\"language-typescript\">interface State {\n  name: string\n  capital: string\n}\n\nconst states: State[] = [\n  { name: \"Alaska\", capital: \"Juneau\" },\n  { name: \"Korea\", capitol: \"Seoul\" },\n]\n//만일 State 타입을 명시하지 않았다면, 에러를 발생시키지 않지만 State 타입을 명시함으로써 capitol 속성 부분에 에러를 표시해준다. 이는 잠재적으로 생길 수 있는 문제를 해결해준다.\n</code></pre>\n<p>타입스크립트 타입 시스템은 자바스크립트의 런타임 동작을 모델링한다.</p>\n<pre><code class=\"language-ts\">const x = 2 + \"3\"\nconst a = null + 7\nconst b = [] + 12\nalert(\"hi\", \"ts\")\n</code></pre>\n<p>변수 x의 경우 문자열 \"23\"이 되는 자바스크립트 런타임 동작으로 모델링된다. 하지만 변수 a,b, alert 함수의 경우에 자바스크립에서는 정상적으로 동작하지만 타입스크립에서는 타입 체커가 문제점을 표시한다.</p>\n<p>이러한 불명확함이 타입스크립트를 사용하는데 의문이 들 수 있지만, 타입스크립트를 사용하면 오류가 적은 프로그램을 만들 수 있다. <code>null+7</code>과 같은 코드가 당연하다고 생각된다면 타입스크립트를 안쓰는게 낫다.</p>\n<h1>타입스크립트 설정 이해하기</h1>\n<pre><code class=\"language-ts\">function sum(a, b) {\n  return a + b\n}\n</code></pre>\n<p>다음 함수가 타입스크립트에서 오류를 발생시키는지, 아닌지 알 수 있을까? 해당 프로그램의 타입스크립트 설정을 보지 않는 이상 알 수 없다. 설정은 커맨드라인에서도 사용할 수 있지만, 설정 파일을 만들어서 동료 개발자나 다른 도구들이 알 수 있도록 해야한다.</p>\n<h2>주요 설정</h2>\n<h3>noImplicitAny</h3>\n<p>noImplicitAny는 변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어한다.\n위의 <code>sum</code> 함수는 noImplicitAny가 설정되었다면 유효하지 않다. a,b가 any 타입으로 간주되기 때문이다. 되도록이면 noImplicitAny로 설정하도록 하고 새 프로젝트를 한다면 꼭 noImplicitAny로 설정하도록 한다.</p>\n<h3>strictNullChecks</h3>\n<p>null과 undefined가 모든 타입에서 허용되는지 확인하는 설정이다.</p>\n<pre><code class=\"language-ts\">const x: number = null\n</code></pre>\n<p>위의 예시는 정상이다. 하지만 strictNullChecks 설정하면 오류가 발생한다.</p>\n<pre><code class=\"language-ts\">const x: number | null = null\n</code></pre>\n<p>만일 null을 허용하려면 위와같이 명시적으로 null을 타입에 넣어주어야 한다.</p>\n<p>만일 null을 허용하지 않으려면 null을 체크하는 코드나 단언문을 추가해야한다.</p>\n<pre><code class=\"language-ts\">const el = document.getElementById(\"status\")\n//el.textContent = \"ready'; -> 개체가 null인 것 같습니다.\n\nif (el) {\n  el.textContent = \"ready\"\n}\nel!.textContent = \"ready\"\n</code></pre>\n<p>strictNullChecks 설정은 null, undefined 관련된 오류를 잡는데 큰 도움을 주지만 코드 작성을 어렵게 한다. 새 프로젝트를 시작한다면 가급적 사용을 권장하고 처음이거나 마이그레이션 중이라면 설정하지 않아도 좋다.</p>\n<h3>strict</h3>\n<p>모든 체크를 설정하고 싶다면 strict 설정을 하면 된다. 타입스크립트에 strict 설정을 하면 대부분 오류를 잡아낸다.</p>\n<h1>코드 생성과 타입이 관계없음을 이해하기</h1>\n<p>타입스크립트의 컴파일러는 두 가지 역할을 수행한다.</p>\n<ol>\n<li>최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일 한다.</li>\n<li>코드의 타입 오류를 체크한다.</li>\n</ol>\n<p>여기서 주의해야 할 점은 두 가지가 완벽히 독립적이라는 점이다. <strong>타입스크립트가 자바스크립트로 변환될 때 타입은 영향을 미치지 않는다. 타입과 관련된 코드는 전부 사라진다!</strong></p>\n<h2>독립적이기에 생기는 특징</h2>\n<h3>1. 타입 오류가 있는 코드도 컴파일 가능</h3>\n<p>타입 오류가 있어도 컴파일 된다는 것은 엉성해보이지만, 실제로는 도움이 되는 경우가 있다. 애플리케이션에서 어떤 부분이 오류가 발생했다고 했을 때, 컴파일이 가능하기에 다른 부분에 대한 테스트가 가능하다.</p>\n<p>만일 오류가 있을 때 컴파일 하지 않으려면 noEmitOnError를 설정하면 된다.</p>\n<h3>2. 런타임에는 타입 체크가 불가능하다.</h3>\n<p>만일 어떤 코드에서 <code>instanceof</code>와 타입을 사용하여 분기를 만든다면, 런타임 환경에서 타입은 사라지기에 전혀 유효하지 않다. 런타임에 타입 정보를 유지하는 방법으로는 3가지가 있다.</p>\n<ol>\n<li>\n<p>속성이 존재하는지 체크 - 속성 체크는 런타임에 접근 가능한 값에만 관련되지만, 타입 체커 역시 보정해주기 때문에 오류가 사라진다.</p>\n</li>\n<li>\n<p>타입 정보를 명시적으로 저장하는 태그 기법</p>\n<pre><code class=\"language-ts\">interface Square {\n  kind: \"square\"\n  width: number\n}\n\ninterface Rectangle {\n  kind: \"rectangle\"\n  width: number\n  height: number\n}\n</code></pre>\n<p>kind 속성을 추가해서, 명시해준다. 타입스크립트에서 흔하게 볼 수 있는 패턴이다.</p>\n</li>\n<li>\n<p>타입을 클래스로 만든다.</p>\n<pre><code class=\"language-ts\">class Square {\n  constructor(public width: number) {}\n}\nclass Rectangle extends Square {\n  constructor(public width: number, public height: number) {\n    super(width)\n  }\n}\ntype Shape = Square | Rectangle\n\nfunction calculateArea(shape: Shape) {\n  if (shape instanceof Rectangle) {\n    //...\n  }\n}\n</code></pre>\n<p><code>type Shape = Square | Rectangle</code> 부분에서 Rectangle은 타입으로 참조되지만, <code>shape instanceof Rectangle</code> 부분에서는 값으로 참조되어 분기가 가능한 것이다.</p>\n</li>\n</ol>\n<h3>3. 타입 연산은 런타임에 영향을 주지 않는다.</h3>\n<p>타입이 사라지기 때문에 당연히 타입 연산도 런타임에 어떠한 영향을 주지 않는다.</p>\n<pre><code class=\"language-ts\">function asNumber(val: number | string): number {\n  return val as number\n}\n</code></pre>\n<pre><code class=\"language-js\">function asNumber(val) {\n  return val\n}\n</code></pre>\n<p>위의 코드는 아래와 같이 컴파일 되기 때문에 해당 인수가 해당 함수를 통과하더라도 그대로이다. 즉 어떠한 영향도 받지 않는다.</p>\n<h3>4. 런타임 타입은 선언된 타입과 다를 수 있다.</h3>\n<p>만약 API값을 수신할 때, API값을 잘못 파악하고 타입을 입력해놨다면 런타임 타입과 선언된 타입이 다르다.</p>\n<h3>5. 함수 오버로드 할 수 없다.</h3>\n<p>타입스크립트가 함수 오버로딩 기능을 지원하기는 하지만, 실제 컴파일 되어있을 때 선언문을 여러개 작성하더라도 구현체는 오직 하나뿐이다. 자바스크립트에서 함수 선언문으로 작성할 경우, 함수명이 동일하면 맨 마지막 함수로 덮어써진다. 이는 자바스크립트의 특징이다.</p>\n<h1>구조적 타이핑 익숙해지기</h1>\n<p>자바스크립트는 덕 타이핑 기반이다.</p>\n<p><em>덕 타이핑이란, 객체가 어떤 타입에 부합하는 변수와 메소드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주한다. 독수리가 오리처럼 걷고, 헤엄치고, 꽥꽥거린다면 독수리는 오리라고 할 수 있다.</em></p>\n<pre><code class=\"language-ts\">function calculateLength(v: { a: number; b: number }) {\n  return v.a + v.b\n}\n\nconst v1 = { a: 1, b: 2, c: 3 }\ncalculateLength(v1) //3\n</code></pre>\n<p>calculateLength의 매개변수 v는 a,b의 속성만 가지지만 c의 속성도 가지고 있는 v1을 해당 함수에 넣어도 문제로 인식하지 않는다. 구조적 관점에서 a,b가 있기 때문에 호환되기 때문이다.</p>\n<p>함수를 작성할 때 호출에 사용되는 매개변수의 속성들이 매개변수의 타입에 선언된 속성만을 가질거라 생각하기 쉽다. 이러한 타입은 봉인된 또는 정확한 타입이라고 불리며 타입스크립트 타입 시스템에서는 표현할 수 없다. 좋든 싫든 타입은 열려있다. 이러한 특성때문에 발생하는 오류는 아래와 같다.</p>\n<pre><code class=\"language-ts\">let sum: number = 0\nfor (let p of Object.keys(v1)) {\n  const num = v1[p]\n  //string은 v1의 인덱스로 사용할 수 없다.\n  sum += num\n}\nreturn sum\n</code></pre>\n<p>Object.keys(v1)을 호출하면 도출되는 배열은 무조건 객체의 속성 중 하나이지만, 타입은 확장될 수 있기 때문에 Object.keys(v1)의 타입은 string[]가 될 수도 있다. 즉 v1이 <code>{a:1,b:2,c:3, d: \"this is string\"}</code>이라면 NaN을 반환한다.\n이럴 경우에 루프보다는, 모든 속성을 각각 더하는 구현이 더 간결하다.</p>\n<p>정확한 타입으로 객체를 순회하는 방법은 추후에 다루도록 하겠다.</p>\n<p>클래스 역시 구조적 타이핑을 따른다. 클래스의 인스턴스가 예상과 다를 수 있음을 유의해야한다.</p>\n<h2>구조적 타이핑의 장점</h2>\n<p>구조적 타이핑은 테스트하는데 유리하다. 함수를 테스트하기 위해서는 모킹한 객체를 생성해야 하는데, 테스트에 필요한 객체의 속성만 작성해주면 되기 때문이다.</p>\n<h1>any 타입 지양하기</h1>\n<p>any의 위험성..</p>\n<h2>any 타입에는 타입 안정성이 없다.</h2>\n<pre><code class=\"language-ts\">let age: number = 10\nconst one = \"1\" as any\nage += one\n//age \"101:\n</code></pre>\n<p>age는 number 타입이지만, any를 설정함으로써 string 타입을 할당할 수 있게 된다. 런타임에서 age는 string이다..</p>\n<h2>함수 시그니처를 무시해버린다.</h2>\n<p>함수를 작성할 때는 시그니처를 명시해야 한다. 호출하는 쪽은 약속된 타입의 입력을 제공하고, 함수는 약속된 타입의 출력을 반환한다. any는 이런 약속을 무시해버릴 수 있다.</p>\n<pre><code class=\"language-ts\">function sum(a: number, b: number): number {\n  return a + b\n}\n\nconst a = \"3\" as number\nconst b = 5\nsum(a, b) //정상적으로 작동함.\n</code></pre>\n<h2>언어 서비스가 적용되지 않는다.</h2>\n<p>자동완성 기능 제공하지 않는다. 또한 Rename Symbol 기능을 사용하면 프로그램 내 모든 속성의 이름을 변경해주지만 any 타입이라면 적용되지 않는다.</p>\n<h2>타입 설계를 감춘다.</h2>\n<p>상태 객체의 설계를 감추기 때문에, 설계가 어떻게 되어있는지 전혀 알 수 없다. 내가 아닌 다른 사람이 코드를 본다면 파악하기 위해 코드를 재구성 해봐야 한다.</p>\n<h2>신뢰도를 떨어트린다.</h2>\n<p>런타임 오류가 더 자주 발생한다. 또한 타입 오류를 고쳐야하고 머릿속에 실제 타입을 기억해야 하기 때문에 번거롭다.</p>","id":"c6927e48-b60a-5406-8e46-4523fec67491"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}