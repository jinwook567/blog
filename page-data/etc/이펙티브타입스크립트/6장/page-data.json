{"componentChunkName":"component---src-templates-post-template-tsx","path":"/etc/이펙티브타입스크립트/6장/","result":{"pageContext":{"node":{"fields":{"slug":"/etc/이펙티브타입스크립트/6장/"},"excerpt":"devDependencies에 typescript와 @types 추가하기 devDependencies에는 프로젝트를 개발하고 테스트하는 데 사용되지만, 런타임에는 필요 없는 라이브러리가 포함된다. typescript와 @types는 런타임에서 사용되지 않기 때문에 devDependencies에 설치되어야한다. 타입스크립트 프로젝트 의존성 타입스크립트 자체 의존성 팀원들 모두가 항상 동일한 버전을 설치한다는 보장이 없다. 프로젝트를 셋업할 때 …","frontmatter":{"date":"2022-12-09T00:00:00.000Z","description":"타입 선언과 @types","title":"이펙티브 타입스크립트 6장"},"html":"<h1>devDependencies에 typescript와 @types 추가하기</h1>\n<p>devDependencies에는 프로젝트를 개발하고 테스트하는 데 사용되지만, 런타임에는 필요 없는 라이브러리가 포함된다. typescript와 @types는 런타임에서 사용되지 않기 때문에 devDependencies에 설치되어야한다.</p>\n<h2>타입스크립트 프로젝트 의존성</h2>\n<ol>\n<li>\n<p>타입스크립트 자체 의존성</p>\n<ul>\n<li>팀원들 모두가 항상 동일한 버전을 설치한다는 보장이 없다.</li>\n<li>프로젝트를 셋업할 때 별도의 단계가 필요하다.</li>\n</ul>\n<p>devDependencies에 포함되어 있다면 npm install 할 때 항상 정확한 버전의 타입스크립트를 설치할 수 있다.</p>\n</li>\n<li>\n<p>타입 의존성</p>\n<ul>\n<li>사용하려는 라이브러리에 타입 선언이 되어있지 않더라도, DefinitelyType에서 타입 정보를 얻을 수도 있다.</li>\n<li>DefinitelyType에서 얻은 타입 정보 또한 devDependencies에서 관리해야한다.</li>\n</ul>\n</li>\n</ol>\n<h1>타입 선언과 관련된 세 가지 버전 이해하기</h1>\n<p>타입스크립트는 의존성 관리를 더욱 힘들게 한다. 다음 세 가지 사항을 추가로 고려해야 한다.</p>\n<ol>\n<li>타입스크립트 버전</li>\n<li>타입 선언(@types)의 버전</li>\n<li>라이브러리의 버전</li>\n</ol>\n<h2>실제 라이브러리와 타입이 따로 관리됨으로써 발생하는 문제점</h2>\n<ol>\n<li>\n<p>라이브러리는 업데이트 했지만 실수로 타입 선언은 업데이트 하지 않는 경우</p>\n<p>라이브러리와 관련하여 새로운 기능을 사용하려고 할 때마다 오류 발생함. 특히 하위 호환성이 깨진다면 런타임에서 오류가 발생할 수도 있다.</p>\n<p>타입 선언도 버전을 맞춰서 업데이트 해주거나, 보강 기법을 활용하여 타입 정보를 프로젝트에 추가해준다.</p>\n</li>\n<li>\n<p>라이브러리보다 타입 선언의 버전이 최신인 경우</p>\n<p>타입 체커는 최신 API를 기준으로 코드를 검사하지만, 런타임에 실제로 쓰이는 것은 과거 버전이다. 이런 경우에도 라이브러리 버전과 타입 선언의 버전을 일치시켜줌으로써 문제를 해결한다.</p>\n</li>\n<li>\n<p>프로젝트에서 사용하는 타입스크립트 버전보다 라이브러리에서 필요로 하는 타입스크립트 버전이 최신인 경우</p>\n<p>유명 라이브러리는 타입 정보를 더 정확하게 표현하기 위해 타입 시스템이 개선되고 버전이 올라가게 된다.</p>\n<p>해결을 위해서는 프로젝트의 타입스크립트 버전을 올리거나, 라이브러리의 타입 선언 버전을 내리거나, declare module 선언으로 라이브러리의 타입 정보를 없애버리거나 하면 된다.</p>\n</li>\n<li>\n<p>@types 의존성이 중복될 수도 있다.</p>\n</li>\n</ol>\n<h1>공개 API에 등장하는 모든 타입을 익스포트하기</h1>\n<p>공개 API에 등장하는 모든 타입은 익스포트 하는 것이 좋다. 필요한 타입을 사용자들이 접근할 수 있도록 해야한다. 모종의 사유로 어떤 타입을 숨기기 싶어서 익스포트 하지 않았다고 해도, 해당 타입을 사용하는 함수가 익스포트 될 경우 Parameters, ReturnType 제너릭을 사용해서 추출할 수 있기 때문이다.</p>\n<h1>API 주석에 TSDoc 사용하기</h1>\n<p>JSDoc 스타일로 주석을 작성하게 되면 대부분의 편집기는 함수가 호출되는 곳에서 함수에 붙어있는 JSDoc 스타일으 주석을 툴팁으로 표시해준다. 툴팁을 보면서 함수에 대해서 더 쉽게 이해할 수 있다.</p>\n<p>인라인 주석으로 작성하게 될 경우에는 지원하지 않는다.</p>\n<h1>콜백에서 this에 대한 타입 제공하기</h1>\n<p>콜백 함수가 this를 사용한다면 this에 대한 타입을 명시해주어야 하고 바인딩 시켜주어야 한다.</p>\n<p>아래는 this에 대한 타입 명시와 바인딩을 시켜준 예시이다.</p>\n<pre><code class=\"language-ts\">function addKeyListener(\n  el: HTMLElement,\n  fn: (this: HTMLElement, e: KeyboardEvent) => void\n) {\n  el.addEventListener(\"keydown\", e => {\n    fn.call(el, e)\n  })\n}\n</code></pre>\n<p>콜백 함수의 첫 번째 매개 변수에 있는 this는 특별하게 처리된다. this에 대한 타입으로 설정된다.\n그리고 만약 this에 대한 명시적 바인딩이 일어나지 않으면 에러를 도출한다.\n아래의 예시를 살펴보면 알 수 있다.</p>\n<pre><code class=\"language-ts\">function addKeyListener(\n  el: HTMLElement,\n  fn: (this: HTMLElement, e: KeyboardEvent) => void\n) {\n  el.addEventListener(\"keydown\", e => {\n    fn(el, e)\n    //1개의 인수가 필요한데 2개의 인수가 사용되었습니다.\n\n    fn(e)\n    //void 형식의 this 컨텍스트를 HTMLElement 형식 this에 할당할 수 없다.\n  })\n}\n</code></pre>\n<p>this에 대한 타입이 주어지고 명시적으로 바인딩 함으로써 완전한 타입 안전성을 얻을 수 있다.</p>\n<pre><code class=\"language-ts\">addKeyListener(el, function (e) {\n  this.innerHTML //정상\n})\n</code></pre>\n<h1>오버로딩 타입보다는 조건부 타입 사용하기</h1>\n<p>오버로딩은 아이템3에서 학습하였지만 간단하게 기술한다.</p>\n<pre><code class=\"language-ts\">function add(x: number, y: number): number\nfunction add(x: string, y: string): string\n\nadd(3, 3) //1번 호출부\nadd(\"x\", \"y\") //2번 호출부\n</code></pre>\n<p><strong>함수는 오버로딩 될 수 없지만 타입은 오버로딩 될 수 있다.</strong> 오버로딩된 타입중에서 일치하는 타입을 찾게된다. add 함수의 1번 호출부에서 2개의 오버로딩된 타입 중 위에것을 찾아서 매칭시킨다. add 함수의 2번 호출부에서는 2개의 오버로딩된 타입 중 아래것을 찾아서 매칭시킨다.</p>\n<p>타입 오버로딩 없이 처리하기 위해서 유니온 함수를 사용했다고 가정해보자</p>\n<pre><code class=\"language-ts\">function double(x: string | number): string | number\nfunction double(x: any) {\n  return x + x\n}\n</code></pre>\n<p>double 함수를 호출하면 실제로는 number가 들어가면 number가 결과 타입으로 예측되고 string이 들어가면 string이 결과 타입으로 예측된다. 하지만 타입 선언의 경우 x가 string일 때 결과 타입이 number인 경우가 존재한다.</p>\n<p>타입을 정교화하기 위해서 제너릭을 사용해본다.</p>\n<pre><code class=\"language-ts\">function double&#x3C;T extends string | number>(x: T): T\n</code></pre>\n<pre><code class=\"language-ts\">const str = \"str\"\nconst doubledStr = double(str) //타입이 'str', 'strstr'이 되어야함.\n</code></pre>\n<p>타입이 너무 과하게 좁혀져서 정확한 타입을 유추하지 못하는 문제가 발생한다.</p>\n<p>위와 같은 예시의 문제를 해결하기 위해서 우리는 오버로딩을 사용하지만, 오버로딩 보다는 조건부 타입을 사용하면 더 간결하게 코드 작성이 가능하다.</p>\n<pre><code class=\"language-ts\">function double&#x3C;T extends string | number>(\n  x: T\n): T extends string ? string : number\n</code></pre>\n<h1>의존성 분리를 위해 미러 타입 사용하기</h1>\n<p>만일 어떤 모듈의 구현과 무관하게 타입에만 의존한다면 필요한 선언부만 추출하여 작성 중인 라이브러리에 넣는 것을 고려해볼 수 있다. 이를 미러링이라고 한다.</p>\n<p>그 이유는 구현에 필요한 라이브러리는 없고 타입만 있으면 혼란을 줄 수 있기 때문이다.</p>\n<p>하지만 다른 라이브러리의 타입 선언의 대부분을 추출해야 한다면 @types 의존성을 추가하는게 낫다.</p>","id":"00255866-68e9-5e52-af0f-3a83d9e6c126"},"previous":{"fields":{"slug":"/etc/yarnberry/"},"excerpt":"패키지 매니저 공부 배경 위투디 프로젝트에서 사용했던 기술을 바탕으로 2개의 프로젝트를 진행해보려고 한다.\n2개의 프로젝트 모두 웹에서 디자인 할 수 있는 canvas api를 사용하기 때문에 두 프로젝트가 컴포넌트를 공유하여 사용할 수 있도록 제작하려 한다.\n물론 버튼이나, 레이아웃 등의 기타 컴포넌트도 공통적으로 관리하여 개발 생산성을 높일 것이다. 이런 공통적인 기능을 어떻게 유지할까 고민해봤다. 패키지로 만들어서 관리하는 방식. 모노레…","frontmatter":{"date":"2022-12-07T00:00:00.000Z","description":"Yarn Berry는 왜 사용하는걸까?","title":"package manager"},"html":"<h1>패키지 매니저 공부 배경</h1>\n<p>위투디 프로젝트에서 사용했던 기술을 바탕으로 2개의 프로젝트를 진행해보려고 한다.\n2개의 프로젝트 모두 웹에서 디자인 할 수 있는 canvas api를 사용하기 때문에 두 프로젝트가 컴포넌트를 공유하여 사용할 수 있도록 제작하려 한다.\n물론 버튼이나, 레이아웃 등의 기타 컴포넌트도 공통적으로 관리하여 개발 생산성을 높일 것이다.</p>\n<p>이런 공통적인 기능을 어떻게 유지할까 고민해봤다.</p>\n<ol>\n<li>패키지로 만들어서 관리하는 방식.</li>\n<li>모노레포 방식.</li>\n</ol>\n<p>1번인 패키지로 만들어서 관리하는 방식은 공통적인 기능(컴포넌트)이 변경이 되면 패키지를 다시 빌드해줘야 한다. 이렇게 되면 패키지 버전이 달라지게 되고 2개의 프로젝트 모두 패키지를 업데이트 해줘야한다.\n개발을 하면서 공통적인 기능의 수정이 빈번하게 일어날 것 같은데 이 과정이 매우 번거롭다고 생각했다.</p>\n<p>2번인 모노레포 방식을 사용하기로 결심했다</p>\n<p>빅테크 기업들의 모노레포 도입기를 보니까 yarn berry의 workspaces 기능을 많이 사용하였다.\n나는 npm을 사용했기에 이번 기회에 패키지 매니저에 대해서 공부해야겠다고 생각했다.</p>\n<h1>yarn classic</h1>\n<p>yarn은 기존에 npm이 있었음에도 불구하고 왜 개발되었을까?</p>\n<ul>\n<li>병렬화를 통해서 다운로드 속도를 개선한다.</li>\n<li>lock 파일을 자동으로 생성(npm의 경우 과거에는 자동으로 생성을 지원하지 않았으나 현재는 지원함.)\n<ul>\n<li>package.json에는 버전의 정확한 버전이 아니라, 버전의 범위가 명시되어 있다. 패키지의 버그가 수정되어 버전이 올라갔을 때, 범위로 명시 되었기에 매번 패키지의 릴리즈에 대해서 추적하지 않아도 된다.</li>\n<li>package-lock.json에는 의존성 트리에 대한 정보가 담겨있으며 node_modules의 트리나 package.json이 수정되었을 때 자동으로 생성된다. 의존성 트리에 대한 정보가 있음으로써 npm install 했을 때 동일한 환경을 구성하도록 도와준다.</li>\n</ul>\n</li>\n<li>의존성 트리 알고리즘 변경\n<ul>\n<li>의존성 트리가 덜 변경되도록 함. npm의 경우 다운로드 순서에 따라서 의존성 트리가 변경되는 경우가 있음.</li>\n</ul>\n</li>\n<li>캐시 사용.</li>\n</ul>\n<p>yarn은 현재 2020년 부터 유지보수 단계이다. 1.x 버전은 모두 레거시로 간주한다.\n장기적으로 프로젝트를 진행한다면 yarn berry를 사용하는 편이 좋아보인다.</p>\n<h1>pnpm</h1>\n<p>2017년에 제작되었으며 npm이 보유한 문제점을 해결한 대체품으로 npm만 있으면 사용 가능하다.</p>\n<p>pnpm은 2가지 문제를 해결한다.</p>\n<ol>\n<li>패키지 중복 다운로드 문제</li>\n<li>유령 의존성 문제 해결</li>\n</ol>\n<h2>1. 패키지 중복 다운로드 문제</h2>\n<p>만일 100개의 프로젝트가 동일한 dependency를 사용하고 있다고 가정하면, 모든 프로젝트에 해당 dependency를 다운로드 해주어야 한다.\npnpm 개발자들은 이러한 행위가 불필요하다고 생각했다.</p>\n<p>pnpm을 사용하면 의존성이 content-addressable에 저장이 된다. 모든 파일은 디스크 상에서 단일 위치에 저장되고, 패키지가 설치될 때 그 파일들은 단일 위치에서 하드 링크되고 추가적인 디스크 공간을 소비하지 않는다.\n중복된 패키지 설치를 줄이기 때문에 많은 디스크 공간을 세이브 할 수 있고 새롭게 패키지를 구성할 때 필요한 다운로드 수를 줄여 빠른 다운로드가 가능하다.</p>\n<p>pnpm은 프로젝트 수가 많아질수록 그 위력이 강력해지는 것 같다.</p>\n<h2>2. 유령 의존성 문제 해결</h2>\n<p>npm과 yarn classic의 경우 의존성을 위해 다운로드 되는 패키지의 중복 저장을 막기위해 평탄화 작업을 한다.\n평탄화 작업이란 중복되는 패키지를 위로 끌어올리는 작업을 의미한다.</p>\n<p>만일 A가 B라는 패키지에 의존을 하고있고 C라는 패키지가 A라는 패키지에 의존하고 있을 때, 평탄화 작업이 일어나지 않는다면 B 패키지의 경우 중복 저장된다.\n평탄화 작업을 통해서 중복 저장은 피했지만, 유령 의존성이라는 문제가 생기게 된다. package.json에 명시되어 있지 않은 B라는 패키지에 바로 접근할 수 있게 되는 것이다.</p>\n<p>pnpm은 symlink를 사용하여 프로젝트의 직접적인 의존성 만을 모듈 디렉토리의 루트로 추가하여 이러한 문제를 해결한다.</p>\n<p>프로젝트의 의존성 정보를 symlink로 정확하게 dependencies의 중첩된 구조를 생성한다.\nsymlink를 이용한 방식이 가능한 이유는 단일 출처에 저장되어, 끌어올리는 평탄화 작업이 필요없기 때문이다.</p>\n<p>A 패키지의 의존성을 가지는 B 패키지를 설치한다고 가정해보자.</p>\n<p>node_modules 폴더 아래 .pnpm이라는 폴더가 있다. 해당 폴더에는 A 패키지와 B 패키지가 담기게 되고, B 패키지에는 필요한 A 패키지에 대한 심볼릭 링크가 된다.\n그 다음으로는 직접 의존성이 처리된다. B 패키지는 node_modules에 심볼릭 링크된다. node_modules는 B라는 패키지 정보만 보유하고 있기 때문에 유령 의존성 문제가 발생하지 않는다.</p>\n<h1>yarn berry</h1>\n<p>yarn berry는 yarn classic의 업그레이드 버전이다.</p>\n<p>yarn berry는 node_modules를 아에 없애버리고자 하고 있다.\nnode_modules를 왜 없애버릴려고 했을까?</p>\n<h2>비효율적인 의존성 검색</h2>\n<p>node_modules는 복잡한 폴더 구조이다. 그리고 npm은 파일을 찾기위해 node의 파일 시스템을 사용한다.\n필요한 파일을 찾기위해 상위 폴더 순회를 반복한다. 하지만 yarn berry의 경우 의존성을 관리하기위해 <code>.pnp.cjs</code>라는 파일을 사용하는데 이는 중첩된 폴더 구조가 아닌 단일 파일로 디스크 I/O없이 빠르게 의존성 검색이 가능하다.</p>\n<h2>무거운 node_modules</h2>\n<p>기존에는 간단한 프로젝트를 하려고 해도 수백 메가바이트에 달하는 node_modules를 설치해야했다.\n하지만 yarn은 의존성을 <code>.yarn/cache</code> 폴더 아래 zip 파일로 관리하여 디스크 공간을 많이 세이브 할 수 있고, 의존성 패키지 다운로드 속도를 대폭 줄일 수 있다.\n또한 zip 파일로 관리가 되기에 의존성을 구성하는 파일의 수가 많지 않으므로 변경 사항을 감지하거나 의존성을 삭제하는 작업이 매우 빠르다.</p>\n<p>의존성 패키지의 용량이 작아지면서 Zero-Install이라는 개념이 생겼다.\nZero-Install이란 프로젝트를 클론했을 때, npm install과 같은 명령어를 사용하여 필요한 패키지를 다운로드 할 필요가 없다는 의미이다.</p>\n<p>어떻게 가능한 것일까?</p>\n<p>프로젝트를 처음 구성했을 때 가장 먼저 하는 일은 git 저장소를 생성하고 <code>.gitignore</code>에 <code>/node_modules</code>를 추가하는 것이였다.\n그 이유는 node_modules가 무겁고 환경에 따라서 동작이 달라질 수 있기 때문이다.</p>\n<p>하지만 yarn berry의 경우 zip 파일로 용량이 상대적으로 적고, .pnp.cjs 파일을 이용하여 의존성이 관리되기 때문에 외부 환경에 영향을 받지 않는다.\n따라서 의존성 파일을 git을 사용하여 버전관리를 해도 좋다. 의존성 파일을 코드 저장소에 포함시킴으로써 우리는 프로젝트를 클론하기만 하면 패키지 install없이 시작할 수 있다.</p>\n<h1>어떤 패키지 매니저를 사용할 것인가?</h1>\n<p>나는 yarn berry를 사용하여 프로젝트를 진행하기로 결정하였다.</p>\n<p>그 이유는 3가지이다.</p>\n<ol>\n<li>엄격한 의존성 관리가 가능하다.</li>\n<li>내가 진행하는 프로젝트의 수는 그렇게 많지 않다. pnpm을 사용하여 패키지 중복 다운로드 문제를 해결함으로써 크게 디스크 공간이 세이브 되지 않는다. (현재 디스크 공간도 여유롭다.)</li>\n<li>Zero-Install이 가능하며 의존성 파일의 크기가 작아짐으로써 CI 시간을 절약할 수 있다.</li>\n</ol>","id":"dd7e37d9-eebb-5383-90ba-9873b1d742ec"},"next":{"fields":{"slug":"/etc/cdn/"},"excerpt":"cdn이란? cdn이란 content delivery network의 약어로 빠른 콘텐츠 전달을 목적으로 고안되었다.\n엔드 유저와 서버 사이의 물리적인 거리를 줄여서 콘텐츠 로딩에 소요되는 시간을 최소화한다. 전세계에 캐시 서버를 분산 배치하여 엔드 유저의 요청에 오리진 서버가 아닌 엔드 유저에 근접한 캐시 서버가 콘텐츠를 전송한다. 거리가 먼 오리진 서버가 아닌, 가까운 캐시 서버에서 콘텐츠를 받아오기 때문에 로딩에 소요되는 시간을 획기적으…","frontmatter":{"date":"2022-12-16T00:00:00.000Z","description":"cdn의 개념과 원리","title":"cdn"},"html":"<h1>cdn이란?</h1>\n<p>cdn이란 content delivery network의 약어로 빠른 콘텐츠 전달을 목적으로 고안되었다.\n엔드 유저와 서버 사이의 물리적인 거리를 줄여서 콘텐츠 로딩에 소요되는 시간을 최소화한다.</p>\n<p>전세계에 캐시 서버를 분산 배치하여 엔드 유저의 요청에 <strong>오리진 서버가 아닌 엔드 유저에 근접한 캐시 서버가 콘텐츠를 전송한다.</strong> 거리가 먼 오리진 서버가 아닌, 가까운 캐시 서버에서 콘텐츠를 받아오기 때문에 로딩에 소요되는 시간을 획기적으로 줄일 수 있는 것이다.</p>\n<p>예시로 캐나다에 있는 유저가 한국에 있는 서비스에 접근하다면, 캐나다에 위치한 캐시 서버에서 캐싱된 콘텐츠를 전송하여 빠르게 콘텐츠를 받아올 수 있다.</p>\n<h1>cdn 적용 유무에 따른 속도 차이</h1>\n<p>속도 차이가 얼마나 나는지 궁금해서 직접 실험을 해봤다.\nAWS EC2 인스턴스를 각각 서울, 미국 버지니아 북부 지역에 생성하였고 서울에 위치하는 S3 버킷의 동영상을 다운로드 받아봤다. CDN은 AWS Cloudfront 서비스를 이용했다.</p>\n<p>서울에 위치하는 EC2에서 실험을 해봤을 때 cdn 적용 유무에 따라 차이가 없었다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2351b1f16beacc9b83348cc7abefdafe/a71c9/seoul.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 9.714285714285714%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAUUlEQVR42o3LzQZAIRRF4ZNUND4a9UNE0fu/3ro0SMM7+Fg2W/bejDFYazHnpPdOa41SCjlnYoyIyH+1VlJKqOo5G2Pw3l8hhOPdXs6529ZaPsQnLUzWlYKqAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"서울 리전 s3,cdn\"\n        title=\"서울 리전 s3,cdn\"\n        src=\"/static/2351b1f16beacc9b83348cc7abefdafe/8c557/seoul.png\"\n        srcset=\"/static/2351b1f16beacc9b83348cc7abefdafe/4edbd/seoul.png 175w,\n/static/2351b1f16beacc9b83348cc7abefdafe/13ae7/seoul.png 350w,\n/static/2351b1f16beacc9b83348cc7abefdafe/8c557/seoul.png 700w,\n/static/2351b1f16beacc9b83348cc7abefdafe/e996b/seoul.png 1050w,\n/static/2351b1f16beacc9b83348cc7abefdafe/2cefc/seoul.png 1400w,\n/static/2351b1f16beacc9b83348cc7abefdafe/a71c9/seoul.png 3480w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\ncdn이 적용되었을 때와 적용되지 않았을 때 0.7s로 동일하였다. 위의 예시는 cdn을 적용하였을 때 다운로드 속도이다.</p>\n<p>미국 버지니아 북부 지역에서 실험을 해봤을 때는 cdn 적용 유무에 따라 유의미한 차이가 있었다.</p>\n<ol>\n<li>\n<p>버지니아 리전에서 cdn이 아닌 S3(오리진 서버)로 직접 접속하여 다운 받았을 떄\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1a4da759948b10a591da3d63c12399c5/c7b13/us_s3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 9.714285714285714%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAXklEQVR42m2NOwoAIRBDB/yitYKVyqAieP/rZdkBi4UtHi+BQOicgzEG9t5Ya2HOidYaeu8CM0svpSDGCK01lFIgon9qrcg5I6WEEIKMnXPw3n988+3GGFhrxTe/Rw9way7GCavXkwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"버지니아 리전 s3\"\n        title=\"버지니아 리전 s3\"\n        src=\"/static/1a4da759948b10a591da3d63c12399c5/8c557/us_s3.png\"\n        srcset=\"/static/1a4da759948b10a591da3d63c12399c5/4edbd/us_s3.png 175w,\n/static/1a4da759948b10a591da3d63c12399c5/13ae7/us_s3.png 350w,\n/static/1a4da759948b10a591da3d63c12399c5/8c557/us_s3.png 700w,\n/static/1a4da759948b10a591da3d63c12399c5/e996b/us_s3.png 1050w,\n/static/1a4da759948b10a591da3d63c12399c5/2cefc/us_s3.png 1400w,\n/static/1a4da759948b10a591da3d63c12399c5/c7b13/us_s3.png 3468w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n17초가 걸렸다.</p>\n</li>\n<li>\n<p>버지니아 리전에서 cdn을 적용하여 처음 다운로드 받았을 때\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4d8436a685f58963b4aee2e2b409e058/f9b4f/us_cdn.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 9.714285714285714%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAUElEQVR42o2LMQoAIRDEFlzF1kpBEBcU/f8Hc5xgeXBFmBQZmXOy1mLvzRgDM6P3TmuNnDOqioj8p9ZKKYWU0jl774kxEkI4e/2Lt7/unOMBoCEtCkYfB3UAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"버지니아 리전 cdn 초기\"\n        title=\"버지니아 리전 cdn 초기\"\n        src=\"/static/4d8436a685f58963b4aee2e2b409e058/8c557/us_cdn.png\"\n        srcset=\"/static/4d8436a685f58963b4aee2e2b409e058/4edbd/us_cdn.png 175w,\n/static/4d8436a685f58963b4aee2e2b409e058/13ae7/us_cdn.png 350w,\n/static/4d8436a685f58963b4aee2e2b409e058/8c557/us_cdn.png 700w,\n/static/4d8436a685f58963b4aee2e2b409e058/e996b/us_cdn.png 1050w,\n/static/4d8436a685f58963b4aee2e2b409e058/2cefc/us_cdn.png 1400w,\n/static/4d8436a685f58963b4aee2e2b409e058/f9b4f/us_cdn.png 3470w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n4.4초가 걸렸다.</p>\n</li>\n<li>\n<p>버지니아 리전에서 cdn을 적용하여 두번 째 다운로드 받았을 때(캐싱된 상태)\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9ed44162e21f1f2b6bf14f0f06b52e17/8b833/us_cdn_cached.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 13.142857142857142%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAYklEQVR42pXMuwrAIBQD0Cv4GhQHUVHBwcXB//++FC+0Y2mHAyGEUIwRKSWUUtBaY2MM9N7hvYcQAkT03VoLe2/MOVFr5eOcM3POQUr57zCEAGvtU2itoZRiJx/GmFf37rgAtp9CChu8zbcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"버지니아 리전 cdn cached\"\n        title=\"버지니아 리전 cdn cached\"\n        src=\"/static/9ed44162e21f1f2b6bf14f0f06b52e17/8c557/us_cdn_cached.png\"\n        srcset=\"/static/9ed44162e21f1f2b6bf14f0f06b52e17/4edbd/us_cdn_cached.png 175w,\n/static/9ed44162e21f1f2b6bf14f0f06b52e17/13ae7/us_cdn_cached.png 350w,\n/static/9ed44162e21f1f2b6bf14f0f06b52e17/8c557/us_cdn_cached.png 700w,\n/static/9ed44162e21f1f2b6bf14f0f06b52e17/e996b/us_cdn_cached.png 1050w,\n/static/9ed44162e21f1f2b6bf14f0f06b52e17/2cefc/us_cdn_cached.png 1400w,\n/static/9ed44162e21f1f2b6bf14f0f06b52e17/8b833/us_cdn_cached.png 3476w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n0.5초가 걸렸다.</p>\n</li>\n</ol>\n<p>우선 서울에서 서울에 위치하는 오리진 서버로부터 다운로드 받았을 때와 미국에서 서울에 위치하는 오리진 서버로부터 다운로드 받았을 때의 차이를 비교해본다.</p>\n<p>17초와 0.7초로 매우 많이 차이가 난다는 것을 알 수 있다. 서버와의 물리적인 거리가 멀어질수록 전송 속도가 느려진다는 것을 파악했다.</p>\n<p>이번에는 미국에서 오리진 서버로부터 다운로드 받았을 떄와 cdn을 적용했을 때 차이를 비교해본다.</p>\n<ol>\n<li>\n<p>1번 케이스 vs 3번 케이스</p>\n<p>왜 cdn을 적용해야 하는지 보여준다. 17초와 0.5초로 속도 차이가 매우 큰 것을 알 수 있다. 전세계를 대상으로 하는 서비스라면 cdn을 적용하는게 훨씬 좋은 사용자 경험을 제공할 것이다.</p>\n</li>\n<li>\n<p>2번 케이스 vs 3번 케이스</p>\n<p>캐시 서버에 콘텐츠가 캐싱이 되어 있지 않을 때와 캐싱이 되어 있을 때 비교이다. 2번 케이스의 경우 캐시 서버에 콘텐츠가 없어서 오리진 서버로부터 콘텐츠를 가져와서 캐싱 후 요청에 응답한다. 이를 cache miss라고 한다. 3번 케이스의 경우 캐싱이 된 상태이므로 오리진 서버로부터 콘텐츠를 요청하지 않고 바로 캐시 서버에서 응답한다. 이를 cache hit라고 한다. cache hit의 경우 오리진 서버를 거치지 않기 때문에 속도가 더 빠르다.</p>\n</li>\n<li>\n<p>1번 케이스 vs 2번 케이스</p>\n<p>1번 케이스와 2번 케이스 모두 오리진 서버로부터 데이터를 요청한다. 하지만 cdn을 이용하는 2번 케이스의 경우 1번 케이스 대비 약 13초나 빠르게 콘텐츠를 다운로드 하였다. 이번 비교를 통해서 캐싱된 콘텐츠를 반환하는 것이 아닌 매번 오리진을 거쳐야 하는 동적인 콘텐츠를 전달할 때도 cdn을 사용하면 좋다는 것을 알 수 있다. 어떻게 이런 일이 가능한 것일까?</p>\n<p>우리가 잘아는 KT와 같은 ISP(Internet Service Provider)들 간의 연결(ISP-ISP)은 경제적인 논리에 의해서 이루어져 있다. 따라서 항상 최적화된 라우팅 경로를 제공하는 것은 아니다.\n하지만 전세계에 깔린 cdn 서버들은 많은 네트워크 통신을 하다보니 많은 데이터가 쌓이게 되었고 최적화된 라우팅 경로를 파악하여 제공할 수 있게 되었다. cdn은 라우팅을 최적화하여 다운로드 시간을 단축시킨다.</p>\n<p>AWS의 Cloudfront의 경우에는 원본과의 지속적인 유지, gzip 압축을 사용함으로써 시간을 추가적으로 단축한다고 한다. 원본과의 지속적인 유지란, connectionless라는 HTTP의 특징과 반하는 개념으로 콘텐츠를 다운로드 받고도 지속적으로 연결을 유지하는 것을 의미한다. IP 기반의 네트워크를 통해서 TCP/IP 연결을 하기 위해서는 3 way handshake 과정을 거쳐야 하는데 이 과정에 필요한 패킷 사이즈는 크지 않아서 사실 큰 오버헤드는 아니다. 하지만 거리가 멀어질수록 round-trip time이 길어짐으로써 큰 오버헤드가 될 수 있다. 원본과의 유지를 지속함으로써 초기 연결에 필요한 시간을 세이브 할 수 있다. 초당 요청 건수가 많을수록 큰 효과를 누릴 수 있다.</p>\n<p>gzip은 전송되는 데이터 크기를 줄여서 트래픽을 줄일 수 있다. 데이터를 더 짧은 시간안에 전송할 뿐만 아니라 데이터 전송 비용도 절감할 수 있다.</p>\n</li>\n</ol>\n<h1>cdn의 속도 이외의 기능</h1>\n<p>cdn을 활용하면 콘텐츠를 빠르게 전달한다는 장점 이외에도 요청을 여러개의 서버로 분산시킬 수 있으므로 대역폭 소비를 줄이며 안정적인 서비스 제공이 가능하다.</p>\n<p>극단적인 예시로는 DDOS 공격에 대한 방어인데, DDOS 공격이란 좀비 pc를 사용하여 특정 서비스에 엄청난 트래픽을 발생시켜서 서비스를 무력화 시키는 것을 말한다.</p>\n<p>CDN이 요청을 분산하여 오리진 서버에 미치는 영향을 줄임으로써 트래픽 급증에 대처할 수 있다. 만일 한국 캐시 서버의 요청이 너무 많다면, 옆에 도쿄로 분산시키고, 도쿄도 많다면 홍콩으로 분산시키고.. 이러한 방식으로 전세계에 배치된 캐시 서버를 활용하여 요청을 분산시킨다. 또한 사용자 위치에 따라 접근을 제어하거나 너무 빠르거나 느린 요청을 차단함으로써 요청을 줄인다고 한다.</p>\n<h1>캐싱 관리</h1>\n<h2>캐싱 만료 주기</h2>\n<p>CDN 서비스를 이용할 때 기본적으로 캐싱의 만료 주기(TTL)를 설정할 수 있다.</p>\n<p>요청을 받았을 때, 캐시 서버에 저장된 콘텐츠가 만료되었다면 캐시 서버는 원본 서버에 데이터가 변경되었는지 유효성을 검증한다. 변경되지 않았다면 HTTP 304(not modified) 응답을 받게되고 캐싱으로 저장된 콘텐츠를 수정하지 않고 TTL만 갱신하여 요청에 응답한다. 이를 Cache Refresh Hit이라고 한다. 만일 변경되었다는 HTTP 200 응답을 받게되면 오리진 서버로부터 콘텐츠를 다운로드받고 해당 콘텐츠로 캐싱을 갱신하여 요청에 응답한다. 이를 Cache Refresh Miss라고 한다.</p>\n<h2>캐싱의 만료 주기가 끝나기 전에 콘텐츠 수정이 일어난다면?</h2>\n<p>캐싱의 만료 주기가 끝나기 전에, 콘텐츠의 수정이 일어나게 된다면 캐시 서버는 변경되기 전의 콘텐츠를 제공할 것이다.</p>\n<p>위와 같은 문제는 2가지 전략으로 해결할 수 있다.</p>\n<ol>\n<li>\n<p>캐시 서버에 캐싱된 콘텐츠를 강제로 삭제한다.</p>\n<p>캐싱된 콘텐츠를 강제로 삭제함으로써 캐시 서버는 오리진 서버에 새롭게 콘텐츠를 요청하여 받아온다. 만일 캐싱된 콘텐츠가 사용령이 많다면 순간적으로 오리진 서버에 부하가 올 수 있으므로 사용에 유의해야 한다. 또한 사용자 단의(브라우저 등) 로컬 캐시된 콘텐츠의 갱신을 보장하지 않는다.</p>\n</li>\n<li>\n<p>콘텐츠를 다른 이름으로 저장한다.</p>\n<p>이 방식은 사용자 단의 콘텐츠의 최신성을 보장해줄 수 있다. AWS에서는 파일을 버전관리 함으로써 이 전략을 수행하도록 권장한다.</p>\n<p>캐싱의 기준은 콘텐츠가 아닌 URL 기반이기 때문에 쿼리스트링이 추가될 수 있다. 동일 콘텐츠임에도 불구하고 쿼리스트링이 달라짐으로써 캐싱이 안될수도 있으니 잘 설정해주어야 한다.</p>\n</li>\n</ol>\n<h1>어떻게 가까운 곳을 찾아서 전달할 수 있을까?</h1>\n<p>CDN은 엔드 유저의 요청에서 가장 가까운 캐시 서버의 캐싱된 콘텐츠를 반환함으로써 빠른 다운로드 속도를 제공한다고 했다. 그렇다면 어떻게 엔드 유저와 가까운 캐시 서버를 알 수 있을까? 이는 라우팅의 원리를 알아야한다.</p>\n<h2>라우팅 테이블</h2>\n<p>라우팅은 네트워크에서 경로를 선택하는 프로세스이다. 쉽게 말하면 라우터에서 라우터로 이동하면서 목적지 주소를 찾는 과정을 말한다. 목적지 주소가 라우터와 동일한 네트워크에 있을 경우 패킷을 직접 전달하는 것으로 마무리된다.</p>\n<p>라우터에서 라우터로 이동할 때 라우팅 테이블이라는 표를 보고 움직이게 된다. 라우팅 테이블에는 최적의 경로로 도달할 수 있는 다음 라우터의 네트워크 주소만 명시되어있다.</p>\n<p>동일한 네트워크에 연결된 컴퓨터 하나하나 모두 명시하는게 아니라 네트워크 주소만 명시하는 이유는 테이블의 크기를 줄이기 위함이다. 테이블 크기를 줄임으로써 검색도 빨라지고 메모리 낭비도 줄일 수 있다.</p>\n<p>라우팅 테이블에는 모든 경로에 대한 네트워크 주소가 들어가있는게 아니고 다음 라우터에 대한 네트워크 주소만 들어가있다. 그 이유는 다음 라우터 네트워크 주소만 들어가 있어도 차례대로 이동하면서 목적지에 도착할 수 있기 때문이다. 굳이 모든 경로에 대한 네트워크 주소를 명시함으로써 메모리 낭비를 할 필요가 없다.</p>\n<h3>그렇다면 라우팅 테이블은 어떻게 구성되는 것일까?</h3>\n<p>라우팅 테이블을 구성하는 방법은 2가지이다.</p>\n<ol>\n<li>\n<p>정적 라우팅 테이블</p>\n<p>직접 사용자가 라우팅 테이블을 입력해준다.\n네트워크에 붙어 있는 마지막 컴퓨터들이 정적 라우팅을 하는 경우가 대부분이다. 혹은 보안적으로 어떤 목적이 있거나.</p>\n</li>\n<li>\n<p>동적 라우팅 테이블</p>\n<p>라우팅 프로토콜에 의해서 동적으로 구성된다.</p>\n<p>유니캐스트 라우팅 프로토콜: 일대일 통신을 말한다. 보내는 사람도 하나, 받는 사람도 하나</p>\n<p>멀티캐스트 라우팅 프로토콜: 보내는 사람은 하나인데 받는 사람 여려명</p>\n</li>\n</ol>\n<h2>라우팅 프로토콜</h2>\n<p>최적화된 라우팅 테이블을 만드는데 라우팅 프로토콜이 사용된다.</p>\n<p>라우팅 프로토콜은 내부 게이트웨이 프로토콜과 외부 게이트웨이 프로토콜로 나누어진다. 나누는 기준은 AS이며 AS(Autonomous System)는 독립적인 네트워크로 라우팅 정보를 주고 받을 수 있는 영역이며 2가지 특징을 가진다.</p>\n<ol>\n<li>AS 내의 라우터들은 서로 동일한 라우팅 프로토콜을 사용한다.</li>\n<li>AS 내의 라우터들은 한 조직에 의해 관리된다.</li>\n</ol>\n<h3>내부 프로토콜</h3>\n<p>내부 프로토콜에는 Distance Vector 알고리즘, Link State 알고리즘이 사용된다.</p>\n<ol>\n<li>\n<p>Distance Vector 알고리즘</p>\n<p>최소 경로를 계산하기 위해서 벨만 포드 알고리즘을 사용한다.\n벨만 포드 알고리즘을 사용하는 이유는 음의 간선이 존재해서가 아니라 본인이 가진 네트워크 정보를 이웃하고만 교환하는 방식이기 떄문이라고 생각한다.</p>\n</li>\n<li>\n<p>Link State 알고리즘</p>\n<p>본인으로부터 모든 목적지까지 가는 최단 경로를 구한다. 다익스트라 알고리즘을 사용한다.\n다익스트라 알고리즘을 사용하는 이유는 이웃 이외에도 모든 노드와 네트워크 정보를 교환하기 때문이다. 모든 정보를 알고있다면 다익스트라 알고리즘이 시간복잡도에서 효율적이다.</p>\n</li>\n</ol>\n<h3>외부 프로토콜</h3>\n<p>외부 프로토콜은 경로 벡터 라우팅이라는 방식에 의해서 수행된다.</p>\n<p>경로 벡터 라우팅에는 목적지 네트워크, 다음 라우터, 경로명이 명시된다. Distance Vector 알고리즘 기반으로 작동하고 looping 되는 경로를 방지하기 위해 모든 path를 명시한다.</p>","id":"be1a2b10-08a6-5537-8c99-435add533f9f"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}