{"componentChunkName":"component---src-templates-post-template-tsx","path":"/algorithm/부대복귀/","result":{"pageContext":{"node":{"fields":{"slug":"/algorithm/부대복귀/"},"excerpt":"문제 링크 해결 전략 위 문제는 한 노드에서 다른 노드의 최단거리 찾기 문제이다. 즉 다익스트라 알고리즘을 사용하면 문제를 해결할 수 있다. 다익스트라 알고리즘은 그리디 알고리즘의 일종인데 방문한 노드에서 최단거리를 가지는 노드를 찾는 알고리즘에서 시간 복잡도 차이가 발생한다.\n노드의 방문 여부를 통해 최단거리를 찾는 알고리즘의 경우 모든 노드를 순회해야하므로 O(n^2)의 시간 복잡도를 가진다.\n하지만 문제의 경우 n이 100,000으로 O…","frontmatter":{"date":"2022-11-22T00:00:00.000Z","description":"다익스트라 알고리즘","title":"부대복귀"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/132266\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>위 문제는 한 노드에서 다른 노드의 최단거리 찾기 문제이다. 즉 다익스트라 알고리즘을 사용하면 문제를 해결할 수 있다.</p>\n<p>다익스트라 알고리즘은 그리디 알고리즘의 일종인데 방문한 노드에서 최단거리를 가지는 노드를 찾는 알고리즘에서 시간 복잡도 차이가 발생한다.\n노드의 방문 여부를 통해 최단거리를 찾는 알고리즘의 경우 모든 노드를 순회해야하므로 O(n^2)의 시간 복잡도를 가진다.\n하지만 문제의 경우 n이 100,000으로 O(n^2)으로 해결할 수 없다.</p>\n<p>이 때 힙을 사용하면 O(NlogN)의 시간 복잡도로 최단거리를 가지는 노드를 찾을 수 있다. 따라서 우선순위 큐를 활용해서 다익스트라 알고리즘을 사용하면 문제의 정답을 구할 수 있다.</p>\n<p>이 문제의 경우 특이한 점이 하나 있다. 보통 노드간의 거리가 다른데 이 문제는 모든 노드 사이의 거리가 1이다. 따라서 사실 우선순위큐를 사용하지 않고 일반 큐를 사용해도 좋다. 그 이유는 모든 노드 사이의 거리가 1이므로 큐를 통해서 순차적으로 배출되는 노드가 최단거리를 가지는 노드임이 보장되기 때문이다. (+1씩 거리가 더해져서 큐에 들어가기 때문.)</p>\n<h1>정답 코드</h1>\n<h2>우선순위 큐를 사용한 방식</h2>\n<pre><code class=\"language-js\">class PriorityQueue {\n  constructor() {\n    this.queue = []\n  }\n\n  swap(aIndex, bIndex) {\n    const temp = this.queue[aIndex]\n    this.queue[aIndex] = this.queue[bIndex]\n    this.queue[bIndex] = temp\n  }\n\n  enqueue(priority, value) {\n    const node = { priority, value }\n    this.queue.push(node)\n\n    let currentIndex = this.queue.length - 1\n    let parentIndex = Math.floor((currentIndex - 1) / 2)\n\n    while (\n      parentIndex >= 0 &#x26;&#x26;\n      this.queue[parentIndex].priority &#x3C; this.queue[currentIndex].priority\n    ) {\n      this.swap(parentIndex, currentIndex)\n      currentIndex = parentIndex\n      parentIndex = Math.floor((currentIndex - 1) / 2)\n    }\n  }\n\n  dequeue() {\n    if (this.queue.length === 0) return undefined\n    if (this.queue.length === 1) return this.queue.pop()\n\n    const root = this.queue[0]\n    const end = this.queue.pop()\n    this.queue[0] = end\n\n    let currentIndex = 0\n    let leftIndex = 1\n    let rightIndex = 2\n\n    while (\n      (this.queue[leftIndex] &#x26;&#x26;\n        this.queue[currentIndex].priority &#x3C; this.queue[leftIndex].priority) ||\n      (this.queue[rightIndex] &#x26;&#x26;\n        this.queue[currentIndex].priority &#x3C; this.queue[rightIndex].priority)\n    ) {\n      if (\n        !this.queue[rightIndex] ||\n        this.queue[leftIndex].priority > this.queue[rightIndex].priority\n      ) {\n        this.swap(currentIndex, leftIndex)\n        currentIndex = leftIndex\n      } else {\n        this.swap(currentIndex, rightIndex)\n        currentIndex = rightIndex\n      }\n      leftIndex = currentIndex * 2 + 1\n      rightIndex = currentIndex * 2 + 2\n    }\n    return root\n  }\n\n  size() {\n    return this.queue.length\n  }\n}\n\nfunction solution(n, roads, sources, destination) {\n  const distance = Array(n + 1).fill(1000001)\n  const visited = Array(n + 1).fill(false)\n\n  const graph = Array(n + 1)\n    .fill()\n    .map(_ => [])\n\n  roads.forEach(([start, end]) => {\n    graph[start].push(end)\n    graph[end].push(start)\n  })\n\n  const priorityQueue = new PriorityQueue()\n\n  distance[destination] = 0\n  priorityQueue.enqueue(0, destination)\n\n  while (priorityQueue.size() > 0) {\n    const { priority: dist, value: node } = priorityQueue.dequeue()\n    if (d[node] > -dist) continue\n\n    graph[node].forEach(end => {\n      distance[end] = Math.min(distance[end], distance[node] + 1)\n      if (distance[end] === distance[node] + 1) {\n        priorityQueue.enqueue(-distance[end], end)\n      }\n    })\n  }\n  return sources.map(v => {\n    return distance[v] === 1000001 ? -1 : distance[v]\n  })\n}\n</code></pre>\n<h2>일반 큐를 사용한 방식</h2>\n<pre><code class=\"language-js\">class Queue {\n  constructor() {\n    this.front = 0\n    this.rear = 0\n    this.queue = []\n  }\n\n  enqueue(data) {\n    this.queue[this.rear++] = data\n  }\n\n  dequeue() {\n    const value = this.queue[this.front]\n    delete this.queue[this.front]\n    this.front++\n    return value\n  }\n\n  size() {\n    return this.rear - this.front\n  }\n}\n\nfunction solution(n, roads, sources, destination) {\n  const graph = Array(n + 1)\n    .fill()\n    .map(_ => [])\n\n  roads.forEach(([start, end]) => {\n    graph[start].push(end)\n    graph[end].push(start)\n  })\n\n  const distance = Array(n + 1).fill(Infinity)\n  const queue = new Queue()\n  queue.enqueue(destination)\n\n  distance[destination] = 0\n\n  while (queue.size() > 0) {\n    const node = queue.dequeue()\n    graph[node].forEach(end => {\n      distance[end] = Math.min(distance[end], distance[node] + 1)\n      if (distance[end] === distance[node] + 1) {\n        queue.enqueue(end)\n      }\n    })\n  }\n\n  return sources.map(v => {\n    return distance[v] === Infinity ? -1 : distance[v]\n  })\n}\n</code></pre>","id":"680faec2-80ac-5ded-97b7-7ea6b00f8745"},"previous":{"fields":{"slug":"/etc/이펙티브타입스크립트/3장/"},"excerpt":"타입 추론 타입스크립트는 타입 추론을 적극적으로 수행한다. 타입 구문의 수를 엄청나게 줄여주기에 코드의 전체적인 안정성이 향상된다. 숙련된 타입스크립트 개발자는 비교적 적은 수의 구문을 사용한다. 추론 가능한 타입을 사용해 장황한 코드 방지하기 위의 예시에서 a에 굳이 number라는 타입을 명시해줄 필요가 없다. 타입스크립트에서 자동으로 추론해주기 때문이다. 객체의 경우 객체의 경우에도, 타입 추론이 의도한 타입과 동일하다면 굳이 타입을 명…","frontmatter":{"date":"2022-11-01T00:00:00.000Z","description":"타입 추론","title":"이펙티브 타입스크립트 3장"},"html":"<h1>타입 추론</h1>\n<p>타입스크립트는 타입 추론을 적극적으로 수행한다. 타입 구문의 수를 엄청나게 줄여주기에 코드의 전체적인 안정성이 향상된다. 숙련된 타입스크립트 개발자는 비교적 적은 수의 구문을 사용한다.</p>\n<h1>추론 가능한 타입을 사용해 장황한 코드 방지하기</h1>\n<pre><code class=\"language-ts\">const a: number = 3\n</code></pre>\n<p>위의 예시에서 a에 굳이 number라는 타입을 명시해줄 필요가 없다. 타입스크립트에서 자동으로 추론해주기 때문이다.</p>\n<h2>객체의 경우</h2>\n<p>객체의 경우에도, 타입 추론이 의도한 타입과 동일하다면 굳이 타입을 명시해줄 필요가 없다.</p>\n<pre><code class=\"language-ts\">interface Person {\n  name: string\n  born: {\n    where: string\n    when: string\n  }\n}\nconst person: Person = {\n  name: \"sssdf\",\n  born: {\n    where: \"Seoul\",\n    when: \"2000-11-01\",\n  },\n}\n</code></pre>\n<p>person 객체만 정의하면 Person과 같은 타입이 자동으로 추론된다. 하지만 만일 객체 리터럴을 정의할 때 잉여속성 체크를 하고 싶다면 꼭 타입을 명시해야한다. 잉여속성 체크를 함으로써, 객체가 사용되는 쪽의 코드에서 문제가 발생하는 것이 아니고, 객체가 정의된 곳에서 문제가 발생되어 문제를 쉽게 파악할 수 있다.</p>\n<h2>리팩토링을 쉽게</h2>\n<p>타입이 추론되면 리팩토링도 쉽게 할 수 있다. 어떻게 보면 기존에 정의된 타입을 이용한다는 것으로 받아들이면 된다.</p>\n<pre><code class=\"language-ts\">interface Product {\n  id: number\n  name: string\n  price: number\n}\n\nfunction logProduct(product: Prodcut) {\n  const id: number = product.id\n  const name: string = product.name\n  const price: number = product.price\n}\n</code></pre>\n<p>위의 예시에서 만일 id가 number 타입이 아닌 string 타입으로 변경되면 logProduct의 함수 const id 부분이 타입 에러가 발생할 것이다. 위와 같은 경우에는 비구조화 할당문으로 리팩토링 해주는게 좋다. 모든 지역 변수의 타입 추론이 되도록 하기 때문이다.</p>\n<pre><code class=\"language-ts\">function logProduct(product: Product) {\n  const { id, name, price } = product\n}\n</code></pre>\n<h2>함수</h2>\n<p>타입 정보가 있는 라이브러리에서 콜백 함수의 매개변수 타입은 자동으로 추론된다. express HTTP 서버 라이브러리를 사용하는 request와 response 타입 선언은 필요하지 않는다.</p>\n<p>함수의 반환에 타입을 명시하면 객체 리터럴에 타입을 명시하는 것과 유사하게 사용되는 쪽의 코드에서 문제가 발생한 곳이 아니고, 구현부에서 문제를 발견할 수 있다.</p>\n<pre><code class=\"language-ts\">const cache: { [ticker: string]: number } = {}\nfunction getQuote(ticker: string) {\n  if (ticker in cache) {\n    return cache[ticker]\n    //number\n  }\n  return fetch(\"...\")\n    .then(response => response.json())\n    .then(quote => {\n      cache[ticker] = quote\n      return quote\n    })\n  //promise\n}\n</code></pre>\n<p>위의 getQuote 함수는 if 구문에서는 number 타입을, fetch에서는 Promise를 리턴하기 때문에 프로미스가 사용되는 부분에서 타입 에러를 발생한다. 해당 문제를 해결하기 위해서는 cache[ticker]를 반환하는게 아닌, Promise.resolve(cache[ticker])를 반환해야한다.</p>\n<p>또한 함수의 반환값에 타입을 명시하면, 해당 타입을 보고 직관적으로 함수를 이해할 수 있다.</p>\n<pre><code class=\"language-ts\">type Vector2D = { x: number; y: number }\nfunction add(a: Vector2D, b: Vector2D) {\n  return { x: a.x + b.x, y: a.y + b.y }\n}\n</code></pre>\n<p>위의 add 함수는 <code>{x:number, y:number}</code> 타입으로 추론할 것이다. 하지만 Vector2D가 들어갔는데, 해당 타입이 나온다는게 개발자 입장에서는 혼란스러울 수 있다. 이럴 때 타입을 명시해주면 혼란을 줄일 수 있다.</p>\n<h1>다른 타입에는 다른 변수 사용하기</h1>\n<pre><code class=\"language-ts\">let id = \"123\"\nfetchProduct(id) // string\n\nid = 123\nfetchProductByNumber(id) //number\n</code></pre>\n<p>자바스크립트에서는 위의 패턴이 허용된다. 하지만 타입스크립트에서는 id에 string 타입이 할당되었기 때문에 그 다음에 number 타입을 할당할 수 없어 오류가 발생한다.</p>\n<pre><code class=\"language-ts\">let id: string | number = \"123\"\n</code></pre>\n<p>위와 같이 유니온 타입으로 타입을 좁혀서 정의하면 코드는 동작한다. 하지만 id를 사용할 때마다 number인지 string인지 확인해야 하기 때문에, 간단한 타입에 비해 다루기 어렵다.\n<strong>따라서 위의 경우에는 변수를 분리한다!</strong>\n변수를 분리하면 더 정확한 변수명을 지을 수 있고, const로 변수를 선언하여 코드 안정성을 향상 시킬 수 있다.</p>\n<h1>타입 넓히기</h1>\n<p>상수를 사용해서 변수를 초기화 할 때 타입을 명시하지 않으면 타입 체커는 타입을 스스로 결정해야 한다. 지정된 단일 값으로 할당 가능한 값들의 집합을 유추해야 한다는 의미이다. 이러한 과정을 타입 넓히기(widening)라고 부른다.</p>\n<pre><code class=\"language-ts\">function onlyGetABC(abc: \"a\" | \"b\" | \"c\") {\n  //...\n}\n\nlet A = \"a\"\nonlyGetABC(A)\n//타입체크 에러 발생\n</code></pre>\n<p>위의 경우 변수 A의 경우 \"a\"라고 정의하였지만, 타입 체커는 타입을 string으로 배치하였다. 타입을 넓혀야 하기 때문이다. 그리고 <code>onlyGetABC</code>는 string이 아닌 <code>\"a\"</code>를 매개변수로 받기 때문에 타입 에러가 발생한다.</p>\n<pre><code class=\"language-ts\">const mixed = [\"x\", 1]\n</code></pre>\n<p>위의 경우 나올 수 있는 경우의 수가 매우 많다. 타입 시스템은 작성자의 의도를 추측하지만, 아무리 영리하더라도 사람의 마음까지는 읽을 수 없다. 위의 경우 작성자는 튜플로 추론되기를 바랬으나 <code>(string|number)[]</code>으로 추론된다.</p>\n<h2>넓히기를 제어하는 방법</h2>\n<h3>let 대신 const로 선언하기.</h3>\n<p>let 대신 const로 선언하면 더 좁은 타입이 된다.</p>\n<pre><code class=\"language-ts\">const A = \"a\"\nonlyGetABC(A)\n//정상\n</code></pre>\n<p>위의 예시에서 A는 <code>\"a\"</code>로 추론된다.\n그러나 const는 만능이 아니다. 객체와 배열의 경우에는 여전히 문제가 존재한다.</p>\n<p>객체의 경우 타입스크립트의 넓히기 알고리즘은 각 요소를 let으로 할당된 것으로 다룬다. 그리고 다른 속성을 추가하지 못한다.</p>\n<h3>명시적 타입 구문을 제공하기</h3>\n<pre><code class=\"language-ts\">const v: {x:1|2|3} {\n  x:1\n}\n</code></pre>\n<h3>타입 체커에 추가적인 문맥을 제공하는 것</h3>\n<p>이후 아이템에서 다룬다고함.</p>\n<h3>const 단언문 사용</h3>\n<p>const로 변수를 선언하는 것과 다른 의미이다.\n값 뒤에 as const를 작성하면 타입스크립트는 최대한 좁은 타입으로 추론한다. 배열을 튜플 타입으로 추론할 때에도 as const를 사용할수 있다.</p>\n<h1>타입 좁히기</h1>\n<p>타입 넓히기의 반대 개념이다. 대표적인 예시는 null 체크이다.</p>\n<pre><code class=\"language-ts\">const el = document.getElementById(\"foo\")\nif (el) {\n  el.innerHTML = \"hello\"\n} else {\n  alert(\"no element\")\n}\n</code></pre>\n<p>위의 예시에서는 분기 처리를 통해 el의 타입이 HTMLElement임을 확인하였다.</p>\n<h2>타입 좁히기 종류</h2>\n<ol>\n<li>\n<p>instanceof를 사용</p>\n</li>\n<li>\n<p>내장 함수(Array.isArray 등)</p>\n</li>\n<li>\n<p>조건문</p>\n<ul>\n<li>\n<p>조건문을 통해서 타입을 좁힐 때는 유의해주어야 한다.</p>\n<pre><code class=\"language-ts\">function foo(x?: number | string | null) {\n  if (!x) {\n  }\n}\n</code></pre>\n<p>위의 예시의 경우 0, '' 모두 falsy이기 때문에 타입이 전혀 좁혀지지 않았다.</p>\n<pre><code class=\"language-ts\">const el = document.getElementById(\"foo\")\nif (typeof el === \"object\") {\n}\n</code></pre>\n<p>위의 예시도 문제는 object도 null이기 떄문에 타입이 좁혀지지 않았다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>명시적 태그를 붙이는 방법</p>\n<ul>\n<li>객체 내에 type 속성을 넣어주고 값을 넣어주는 패턴 등이 존재한다.</li>\n<li>태그된 유니온, 구별된 유니온이라고 불린다.</li>\n</ul>\n</li>\n<li>\n<p>커스텀 함수 도입</p>\n<pre><code class=\"language-ts\">function isInputElement(el: HTMLElement): el is HTMLInputElement {\n  return \"value\" in el\n}\n\nfunction getElementContent(el: HTMLElement) {\n  if (isInputElement(el)) {\n    return el.value\n  }\n  return el.textContent\n}\n</code></pre>\n<ul>\n<li>위와 같은 패턴을 사용자 정의 타입 가드라고 한다.</li>\n</ul>\n<pre><code class=\"language-ts\">const member = [\"a\", \"b\", \"c\", \"d\"]\nconst people = [\"a\", \"e\"]\n\nconst onlyMember = people.map(who => member.find(v => v === who))\n//(string | undefined)[]\n\nconst filteredOnlyMember = people\n  .map(who => member.find(v => v === who))\n  .filter(who => who !== undefined)\n//(string | undefined)[]\n</code></pre>\n<p>위의 경우 filteredOnlyMember 변수도 (string | undefined)[]이다. 이럴 때 타입 가드를 사용하면 타입을 좁힐 수 있다.</p>\n<pre><code class=\"language-ts\">function isDefined&#x3C;T>(x: T | undefined): x is T {\n  return x !== undefined\n}\n\nconst filteredOnlyMember = people\n  .map(who => member.find(v => v === who))\n  .filter(isDefined)\n//string[]\n</code></pre>\n</li>\n</ol>\n<h1>한꺼번에 객체 생성하기</h1>\n<p>자바스크립트의 값은 변경되지만 일반적으로 타입스크립트의 타입은 변경되지 않는다. 객체를 생성할 때는 속성을 하나씩 추가하는 것보다는 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리하다.</p>\n<pre><code class=\"language-ts\">const pt = {}\npt.x = 3\npt.y = 5\n//타입 체크 오류 발생.. {} 형식에 x가 존재하지 않습니다.\n</code></pre>\n<p>아래와 같은 패턴으로 정의하면 오류가 발생하지 않는다.</p>\n<pre><code class=\"language-ts\">const pt = { x: 3, y: 5 }\n</code></pre>\n<p>객체를 반드시 제각각 나눠서 만들어야 한다면 타입 단언문을 사용해야한다.</p>\n<pre><code class=\"language-ts\">interface Point {\n  x: number\n  y: number\n}\nconst pt = {} as Point\npt.x = 3\npt.y = 5\n</code></pre>\n<h2>전개 연산자</h2>\n<p>객체를 합칠 때는 전개 연산자를 사용한다.</p>\n<pre><code class=\"language-ts\">const pt = { x: 3, y: 4 }\nconst id = { name: \"pythagoras\" }\nconst namedPoint = {}\nObject.assign(namedPoint, pt, id)\nnamedPoint.name\n//타입 에러 발생.. name 속성이 없다.\n\nconst namedPoint = { ...pt, ...id }\nnamedPoint.name\n</code></pre>\n<h3>조건부 속성</h3>\n<pre><code class=\"language-ts\">declare let hasMiddle: boolean\nconst firstLast = { first: \"harry\", last: \"potter\" }\nconst president = { ...firstLast, ...(hasMiddle ? { middle: \"S\" } : {}) }\n</code></pre>\n<p>위의 예시에는 middle이 선택적 속성을 가지는 것으로 추론된다.</p>\n<p>만일 전개 연산자로 여러 속성을 추가하면 어떻게 될까? 이때는 유니온 속성으로 추론된다. 속성이 함께 정의되기 때문에 유니온을 사용하는게 값의 집합을 더 정확히 표현할 수 있기 때문이다.</p>\n<p>유니온 방식이 아닌, 선택적 필드로 만들고 싶다면 헬퍼 함수를 사용해야한다.</p>\n<pre><code class=\"language-ts\">function addOptional&#x3C;T extends object, U extends object>(\n  a: T,\n  b: U | null\n): T &#x26; Partial&#x3C;U> {\n  return { ...a, ...b }\n}\n</code></pre>\n<p><strong>객체나 배열을 변환해서 새롤운 객체나 배열을 생성하고 싶다면 루프 대신 내장된 함수형 기법 또는 로대시 같은 유틸리티 라이브러리를 만드는게 한꺼번에 객체 생성하기 관점에서 옳다.</strong></p>\n<h1>일관성 있는 별칭 사용하기</h1>\n<pre><code class=\"language-ts\">const person = {\n  age: 20,\n  name: \"jinwook\",\n  location: { City: \"Seoul\", State: \"gdd\" },\n}\nconst loc = person.location\n</code></pre>\n<p>위의 loc 변수가 별칭이다. 별칭의 속성값을 변경하면 원본 객체의 속성값도 변경한다. 따라서 별칭을 남발하면 제어 흐름을 파악하기 어렵다.</p>\n<p>만일 location의 분기를 여러번 나눠야되는 로직이 있다면 우리는 location 별칭을 사용해서 코드를 짧게 유지할 것이다.</p>\n<pre><code class=\"language-ts\">function saveLocation1(person) {\n  if (person.location) {\n  }\n  //...\n}\n\nfunction saveLocation2(person) {\n  const personLocation = person.location\n  if (person.location) {\n    fn(personLocation)\n    //error 발생.. personLocation은 null일 수 있음.\n    //...\n  }\n}\n\nfunction saveLocation3(person) {\n  const { location } = person\n  if (location) {\n    //...\n  }\n}\n</code></pre>\n<p>saveLocation2의 경우 객체의 속성을 별칭으로 정의했다. 하지만 아래 분기에서는 <code>person.location</code>을 확인하였고 <code>personLocation</code>은 확인하지 않았다. <code>person.location</code>은 <code>null</code>이 사라져 타입이 좁혀졌으나 <code>personLocation</code>은 그대로이다. 별칭을 사용할 것이면 일관성있게 <code>saveLocation3</code>처럼 사용해야한다. 또한 비구조화 할당을 사용해서 일관된 이름을 사용하면 더더욱 좋다.</p>\n<h2>별칭으로 인한 혼동</h2>\n<pre><code class=\"language-ts\">const { bbox } = polygon\nif (!bbox) {\n  caculatePolygonBbox(polygon)\n}\n</code></pre>\n<p>위의 예시에서 bbox와 polygon.bbox는 이제 다른 값을 참조한다..! bbox의 경우 비구조화 할당으로 인해 새로운 변수에 넣었기 때문이다.</p>\n<pre><code class=\"language-ts\">function fn(p: Polygon) {}\n\npolygon.bbox //BoundingBox | undefined\n\nif (polygon.bbox) {\n  fn(polygon)\n  polygon.bbox //BoundingBox\n}\n</code></pre>\n<p>위의 예시에서 fn은 polygon의 bbox 속성을 제거할 수도 있다. 하지만 타입은 그대로 유지된다. 타입스크립트에서 함수가 타입 정제를 무효화하지 않는다고 가정하기 때문이다. 따라서 위의 경우에는 비구조화 할당을 사용해서 새로운 지역변수를 정의하면 타입은 정확히 유지되지만 원본값은 변함이 없는 장점을 누릴 수 있다.</p>\n<h1>비동기 코드에는 콜백 대신 async 함수 사용하기</h1>\n<p>콜백보다는 프로미스, async 함수를 사용하는 것이 코드도 간결하며 타입을 추론하기 쉽다.\n선택의 여지가 있다면 프로미스 보다는 async를 사용하는게 좋다.</p>\n<ol>\n<li>코드가 더 간결하고 직관적이다.</li>\n<li>항상 프로미스를 반환한다.</li>\n</ol>\n<p>async 함수에서 프로미스를 반환하면 또 다른 프로미스로 래핑되지 않는다. Promise&#x3C;<T>>가 아닌 Promise<T>를 반환한다.</p>\n<h1>타입 추론에 문맥이 어떻게 사용되는지 이해하기</h1>\n<pre><code class=\"language-ts\">type Lanuage = \"JavaScript\" | \"TypeScript\"\nfunction setLanuage(lanuage: Lanuage) {\n  //...\n}\n\nsetLanuage(\"JavaScript\") //1\nlet js = \"JavaScript\"\nsetLanuage(js) //2\n</code></pre>\n<p>위의 예시에서 첫 번째로 호출한 함수의 경우 에러가 발생하지 않지만, 두 번째로 호출한 함수의 경우 에러가 발생한다. 이 문제를 해결할 수 있는 방법은 2가지이다.</p>\n<ol>\n<li>타입 선언\n<pre><code class=\"language-ts\">let js: Lanuage = \"JavaScript\"\n</code></pre>\n</li>\n<li>js를 상수로 만드는 것이다.\n<pre><code class=\"language-ts\">const js = \"JavaScript\"\n</code></pre>\n</li>\n</ol>\n<h2>튜플 사용 시 주의 점</h2>\n<pre><code class=\"language-ts\">function panTo(where: [number, number]) {}\n\npanTo([10, 10])\nconst loc = [10, 10]\npanTo(loc)\n</code></pre>\n<p>위의 예시의 경우 loc를 상수로 선언했음에도 불구하고 타입 에러가 발생한다. 그 이유는 loc를 <code>number[]</code>로 추론했기 때문이다. 이 경우도 위와 유사하다. 타입 선언을 하거나 상수로 정의해준다.</p>\n<pre><code class=\"language-ts\">const loc = [10, 10] as const\n</code></pre>\n<p>기존에 const는 참조값이 바뀌지 않는 것이였는데, as const로 정의하면 내부까지 상수라는 사실을 타입스크립트에게 알려준다.</p>\n<p>하지만 위의 코드는 또 문제가 있다. loc의 경우 readonly 상태를 가지게 되는데, panTo가 매개변수의 내용이 불변을 보장하지 못하는 것이다. panTo의 매개변수에 readonly 키워드를 적용해줌으로써 해당 문제를 해결할 수 있다.</p>\n<p>as const를 사용할 때 유의해야 하는 점은 타입 정의에 실수가 있다면 타입이 정의되는 곳이 아닌, 호출되는 곳에서 발생한다는 것을 유의해야한다.</p>\n<h1>함수형 기법과 라이브러리로 타입 흐름 유지하기</h1>\n<p>자바스크립트에서는 서드파티 라이브러리의 도입을 신중해야한다. 타입을 알 수 없기 때문에 서드파티 라이브러리를 사용해서 코드를 줄이는데 시간이 오래들기 때문이다. 반면에 타입스크립트는 타입이 명시되어있어 서드파티 라이브러리 도입에 큰 문제가 없다. 서드파티 라이브러리를 활용해서 생산성을 높이는 편이 낫다.</p>","id":"50dbe5f7-cd08-5ec3-ba3f-fbf7bb12ab62"},"next":{"fields":{"slug":"/etc/이펙티브타입스크립트/4장/"},"excerpt":"유효한 상태만 표현하는 타입을 지향하기 유효한 상태만 표현한다는 것의 의미가 무엇일까. 유효하지 않은 상태가 있음으로써 버그가 생기는 것이라고 할 수 있을 것 같다.\n예시를 통해서 이해해보도록 하자. api를 호출하고 비동기적으로 데이터를 받아옴으로써 페이지의 상태를 다음과 같이 표현할 수 있다. 위와 같은 상태 설계는 유효하지 않은 상태가 존재함으로 버그가 생길 수 있다.\n유효하지 않은 상태는 isLoading이 true이고, error 값…","frontmatter":{"date":"2022-12-01T00:00:00.000Z","description":"타입 설계","title":"이펙티브 타입스크립트 4장"},"html":"<h1>유효한 상태만 표현하는 타입을 지향하기</h1>\n<p>유효한 상태만 표현한다는 것의 의미가 무엇일까. 유효하지 않은 상태가 있음으로써 버그가 생기는 것이라고 할 수 있을 것 같다.\n예시를 통해서 이해해보도록 하자.</p>\n<p>api를 호출하고 비동기적으로 데이터를 받아옴으로써 페이지의 상태를 다음과 같이 표현할 수 있다.</p>\n<pre><code class=\"language-ts\">interface State {\n  data?: string\n  isLoading: boolean\n  error?: string\n}\n</code></pre>\n<p>위와 같은 상태 설계는 유효하지 않은 상태가 존재함으로 버그가 생길 수 있다.\n유효하지 않은 상태는 isLoading이 true이고, error 값이 존재한다면 로딩중인지, 에러인지 파악할 수 없다.</p>\n<p>위의 설계 오류를 아래와 같이 수정할 수 있다.</p>\n<pre><code class=\"language-ts\">interface RequestPending {\n  state: \"pending\"\n}\n\ninterface RequestError {\n  state: \"error\"\n  error: string\n}\n\ninterface RequestSuccess {\n  state: \"success\"\n  data: string\n}\n\ntype RequestState = Requestpending | RequestError | RequestSuccess\n</code></pre>\n<p>RequestState를 위와 같이 정의할 경우, state에 따라서 error 속성과 data 속성의 여부가 변경되기 때문에 유효하지 않은 상태를 가지지 않는다.</p>\n<pre><code class=\"language-ts\">interface RequestState {\n  state: \"pending\" | \"error\" | \"success\"\n  error?: string\n  data?: string\n}\n</code></pre>\n<p>위와 같이 정의할 경우, 유효하지 않은 error와 data가 생길 수 있기 때문에 옳지 않다.</p>\n<p>유효하지 않은 상태가 존재하지 않도록 타입을 정의하고, 어떠한 속성의 값에 따라 상태가 변하는 경우 유니온 속성을 이용하여 깔끔하게 분기처리를 해야한다.</p>\n<h1>사용할 때는 너그럽게, 생성할 때는 엄격하게</h1>\n<blockquote>\n<p>포스텔의 법칙: 당신의 작업은 엄격하게 하고, 다른 사람의 작업은 너그럽게 받아들여야 한다.</p>\n</blockquote>\n<p>함수도 마찬가지이다. 매개변수의 타입의 범위는 넓어도 되지만, 결과를 반환할 때는 타입의 범위가 더 구체적이여야 한다.</p>\n<p>결과를 반환하는 값의 타입의 범위가 좁아야 되는 이유는 타입의 범위가 좁아야 함수를 호출부에서 사용이 편리하기 때문이다.</p>\n<pre><code class=\"language-ts\">interface Argument {\n  a: { x: number; y: number } | { x: number; y: number; z: number }\n}\n\ninterface Return {\n  ans:\n    | { a: number; b: number }\n    | { a: number; c: number }\n    | { a: number; d: number }\n}\n\ndeclare function returnVariousType(arg: Argument): Return\n\nfunction someFunc() {\n  const { c } = returnVariousType({ x: 3, y: 3 })\n}\n</code></pre>\n<p>위의 예제에서 someFunc의 c의 경우 undefined가 될 수 있다. 따라서 분기 처리를 통해 c가 존재한다는 있는 것을 확인해주거나, 리턴값에 속성 타입을 명시하여 분기 처리를 해주어야한다.\n정리하자면, 함수를 호출하는 부분에서 사용이 매우 불편하다..!\n다만 매개변수의 타입은 보다 넓게 설정해주어 함수를 호출할 때 편리함을 증가시켜줄 수 있다.</p>\n<h1>문서에 타입 정보 쓰지 않기.</h1>\n<p>주석으로 타입 정보를 선언해주면, 코드를 수정할 때마다 주석도 수정해주어야 한다. 실무에서 동기화가 안될 떄가 많다. 하지만 타입 시스템은 자동으로 동기화된다.</p>\n<p>또한 타입스크립트는 간결하고, 구체적이며, 읽기 편하게 설계되어 있어 굳이 주석이 필요하지 않다.</p>\n<p>변수명을 지을 때도 타입의 단위를 가지고 있다면 굳이 변수명에 넣지 않아도 좋다. 하지만 단위가 무엇인지 확실하지 않다면 변수명에 표현해줘도 좋다. 전자의 예시로는 ageNum, 후자의 예시로는 temperatureC 등이 있다.</p>\n<h1>타입 주변에 null을 배치하기.</h1>\n<p>한 값의 null이 다른 값의 null에 영향을 미치도록 설계하면 안된다.\n그 이유는 한 값이 null일 때, 아닐 때. 다른 값이 null일 때, 아닐 때 4가지 경우가 생성되기 때문이다. 여러가지 경우의 수가 생긴다. 사용부에서 많은 경우의 수에 대한 분기 처리가 필요하게 되고 가독성 있게 표현하기 힘들어 코드가 복잡하고 읽기 힘들게 된다.</p>\n<p>두 값을 하나의 객체로 정의하고 null 혹은 값을 가지는 상태로 정의한다면 위와 같은 오류를 피할 수 있다.</p>\n<h2>함수의 관점</h2>\n<pre><code class=\"language-ts\">function extent(nums: number[]) {\n  let min, max\n  for (let num of nums) {\n    if (!min) {\n      min = num\n      max = num\n    } else {\n      min = Math.min(min, num)\n      max = Math.max(max, num)\n    }\n  }\n}\n</code></pre>\n<p>strickCheckNull을 키고 다음 함수를 호출한다면, max값에 대해서 오류가 발생할 것이다. 초기 null인 max값에 대해서 값의 대입은 이루어졌지만, 타입 시스템의 검증은 수행되지 않았다. if문에서 min에 대한 체크만 이루어졌기 때문에 max 값은 undefined 혹은 number의 타입을 가지게 된다. number의 타입을 기대하고 함수를 사용했다면 곤란한 상황에 처하게 된다.\n또한 js의 특성상 min이 0일 경우, if(!min)의 분기 처리의 로직을 실행하기 때문에 원하는 최솟값과 최댓값이 나오지 않을 수 있다.</p>\n<p>이 때 max에 대한 분기도 넣어줄 수 있지만, 이는 함수의 구현을 복잡하게 할 뿐만 아니라 추가적인 요청사항이 들어올 경우 에러가 발생할 확률을 높인다.</p>\n<p>min과 max를 하나의 객체로 관리하고, 값의 대입이 이루어졌다면 null이 아니도록 처리해주면 위와 같은 문제를 피할 수 있다.</p>\n<pre><code class=\"language-ts\">function extent(nums: number[]) {\n  const results: { min: number; max: number } | null = null\n\n  for (let num of nums) {\n    if (!results) {\n      results = [num, num]\n    } else {\n      results.max = Math.max(results.max, num)\n      results.min = Math.min(results.min, num)\n    }\n  }\n}\n</code></pre>\n<p>위의 경우 min과 max값이 둘다 null로 묶여 있어서 null 체크를 한번만 해주면 min,max값을 사용할 수 있다.</p>\n<pre><code class=\"language-ts\">function extent(nums: number[]) {\n  return { min: Math.min(...nums), max: Math.max(...nums) }\n}\n</code></pre>\n<pre><code class=\"language-ts\">function extent(nums: number[]) {\n  let min = nums[0]\n  let max = nums[0]\n  //... 이하는 아래와 같다.\n}\n</code></pre>\n<p>위의 2개 함수는 사실 null check가 필요없는 content 함수이다. 2번째 함수의 경우 함수의 초기값을 인자의 첫 번째 요소로 초기화 시켜주어 다른 타입을 가질 가능성을 막아버렸다.</p>\n<h2>클래스의 관점</h2>\n<p>클래스의 경우 초기값(null)을 가지고 메소드에 따라서 값이 변화한다고 한다면, 다른 메소드에서 null 체크가 매번 일어나야 하고, 경우의 수가 생기기 때문에 코드가 복잡해진다.\n클래스의 경우 값을 정확히 가질 때 인스턴스를 정의할 수 있도록 함으로써 null 분기에 필요한 로직을 걷어낼 수 있다. 데이터가 부분적으로 준비한 경우를 다루어야 한다면 null과 관련된 부분을 다룰 수 밖에 없긴하다.</p>\n<h1>유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기</h1>\n<p>유니온 타입의 속성을 가지는 인터페이스를 작성 중이라면, 인터페이스의 유니온 타입을 사용하는 게 더 알맞지는 않을지 검토해봐야 한다.</p>\n<p>그 이유는 유니온 타입에 따른 조합이 생겨 다양한 경우의 수가 생기기 때문이다.</p>\n<p>벡터를 그리는 프로그램을 작성중이고, 특정한 기하학적 타입을 가지는 계층의 인터페이스를 정의한다고 가정해보도록 하자.</p>\n<pre><code class=\"language-ts\">interface Layer {\n  layout: FillLayout | LineLayout | PointLayout\n  paint: FillPaint | LinePaint | PointPaint\n}\n</code></pre>\n<p>위의 경우 layout은 LineLayout을 가지고, paint의 경우 PointPaint를 가지는 상태는 말이 안될 것이다. 위의 같은 경우 인터페이스의 유니온을 사용하여 처리해야한다. 태그된 유니온 방식은 타입스크립트의 타입 체커 시스템과 매우 잘맞기 때문에 해당 방식으로 표현할 수 있다면 사용하는 편이 좋다.</p>\n<pre><code class=\"language-ts\">interface FillLayer {\n  type: \"fill\"\n  layout: FillLayout\n  paint: FillPaint\n}\n\ninterface LineLayer {\n  type: \"line\"\n  layout: LineLayout\n  paint: LinePaint\n}\n\ninterface PointLayer {\n  type: \"point\"\n  layout: PointLayout\n  paint: PointPaint\n}\n\ntype Layer = FillLayer | LineLayer | PointLayer\n</code></pre>\n<p>어떠한 2개의 속성이 있고 둘다 같이 존재하거나, 같이 존재하지 않는 상태라고 가정한다면 이전 아이템에서 배운 타입 주변에 null 배치하기 방식을 이용하면 좋다. 2개의 속성을 하나(객체)로 묶는 것이다.</p>\n<pre><code class=\"language-ts\">interface Person {\n  name: string\n  placeOfBirth?: string\n  dateOfBirth?: Date\n}\n\ninterface Person {\n  name: string\n  birth?: {\n    place: string\n    date: Date\n  }\n}\n</code></pre>\n<h1>string 타입보다 더 구체적인 타입 사용하기</h1>\n<p>string 타입보다 구체적인 타입을 사용해야 하는 이유는 string 타입이 너무 크기 때문이다. 한 글자를 가지던 1만 글자를 가진 문장이던 같은 string 타입이다.</p>\n<p>구체적으로 살펴봤을 때 string 타입보다 구체적인 타입을 사용해야 하는 이유는 3가지이다.</p>\n<ol>\n<li>\n<p>타입을 명시적으로 정의함으로써, 다른 곳으로 값이 전달되어도 타입 정보가 유지된다.</p>\n<ul>\n<li>예시로 다른 함수의 인수의 타입으로 사용될 수 있다. 어떤 배열 내 객체의 속성의 특정한 값을 만족하는 요소를 추출하는 함수를 작성한다고 하였을 떄, 해당 함수의 인자로 타입을 이용하면 좋다. (타입이 변경되었을 떄도 유지보수가 편리하다.)</li>\n</ul>\n</li>\n<li>\n<p>타입을 명시적으로 정의하고 해당 타입의 의미를 설명하는 주석을 붙여넣을 수 있다.</p>\n</li>\n<li>\n<p>keyof 연산자로 더욱 세밀하게 객체의 속성 체크가 가능하다. (이 부분이 여기에 왜 있는지는 잘 모르겠다.)</p>\n<pre><code class=\"language-ts\">interface Albums {\n  recordType: \"studio\" | \"live\"\n  name: string\n  releaseDate: Date\n  follower: number\n}\n\nconst albums: Albums[] = [\n  {\n    recordType: \"studio\",\n    name: \"a\",\n    releaseDate: new Date(\"2022-10-11\"),\n    follower: 200,\n  },\n  {\n    recordType: \"live\",\n    name: \"b\",\n    releaseDate: new Date(\"2022-10-12\"),\n    follower: 300,\n  },\n  {\n    recordType: \"studio\",\n    name: \"c\",\n    releaseDate: new Date(\"2022-10-13\"),\n    follower: 400,\n  },\n]\n\nfunction pluck(arr, key) {\n  return arr.map(v => v[key])\n}\nconst dates1 = pluck(albums, \"releaseDate\")\n//dates1은 any[] 타입을 가진다. 또한 pluck 함수의 두 번째 인수도 첫 번쨰 인수가 보유한 속성값이 언어 서비스에 드러나지 않는다.\n\nfunction pluck2&#x3C;T>(arr: T[], key: keyof T) {\n  return arr.map(v => v[key])\n}\n\nconst dates2 = pluck2(albums, \"releaseDate\")\n//dates2 타입은 (string | Date | number)[]이다. 두 번쨰 인수의 경우 첫 번쨰 인수가 보유한 속성값이 언어 서비스에 드러난다.\n//albums의 속성이 가질 수 있는 모든 타입을 가진다. 원활한 사용을 위해서는 타입을 더 좁혀야한다.\n\nfunction pluck3&#x3C;T, K extends keyof T>(arr: T[], key: K) {\n  return arr.map(v => v[key])\n}\n//keyof T의 범위를 더욱 좁혀야 한다. keyof T의 부분 집합으로 두 번째 매개변수를 도입한다.\n\nconst dates3 = pluck3(albums, \"releaseDate\")\n//dates3의 타입은 Date[]이다. 언어 서비스를 이용하며 명확하게 좁혀진 타입의 결과를 얻어낼 수 있다.\n</code></pre>\n</li>\n</ol>\n<h1>부정확한 타입보다는 미완성 타입을 사용하기</h1>\n<p>타입의 선언의 정밀도를 높이는 일에는 주의를 기울여야 한다. 실수가 발생할 수 있고 잘못된 타입은 있는 것 보다 못하기 때문이다.</p>\n<pre><code class=\"language-ts\">interface Geometry {\n  coordinate: number[] | number[][] | number[][][]\n}\n</code></pre>\n<p>위와 같은 코드에서 coordinate가 위도, 경도로 이루어져있다고 생각하고 타입이 너무 크다고 판단하여 [number, number] 타입으로 변형하였다. 기존에 고도라는 개념이 있어 number[]라고 표현이 되어있던 것이고, 모든 코드에 오류가 발생하게 된다.</p>\n<p>타입을 정교하게 만들어서 부정확함을 바로잡는 방법 대신 테스트를 추가하여 놓친 부분이 없는지 확인하는 방식을 사용해도 좋다. 타입을 정제할 때, 볼쾌한 골짜기 은유를 생각해보면 도움이 될 수 있다.</p>\n<h1>데이터가 아닌 API와 명세를 보고 타입 만들기</h1>\n<p>API 명세서를 읽어보지 않고 데이터만을 받아서 타입을 작성했을 때 예상치않은 오류가 발생할 수 있다.\nAPI 명세서를 참고해서 타입을 만들거나, 공식 타입 선언을 다운로드 받아서 사용하면 좋다.</p>\n<h1>해당 분야의 용어로 타입 이름 짓기</h1>\n<p>해당 분야의 용어는 몇십년에 지나면서 다듬어져 왔다. 가독성을 더 높여준다.</p>\n<p>또한 이미 체계적으로 분류가 잡혀져 있는 경우가 있다. 기후라는 타입을 정의하기 위해서는 미리 정의된 쾨펜 기후 분류 등을 사용하면 편리하고 유지보수에 용이하다.\n유지보수에 용이한 이유는 코드를 작성한 사람에게 조언을 구할 필요가 없기 때문이다.</p>\n<p>동일한 의미를 나타날 때는 꼭 같은 단어를 사용해야한다.</p>\n<h1>공식 명칭에는 상표 붙이기</h1>\n<p>구조적 타이핑의 특성 때문에 가끔 코드가 이상한 결과를 낼 수 있다.</p>\n<pre><code class=\"language-ts\">interface Vector2D {\n  x: number\n  y: number\n}\n\nfunction calculateNorm(p: Vector2D) {\n  return Math.sqrt(p.x * p.x + p.y * p.y)\n}\n\nconst vector3D = { x: 1, y: 2, z: 5 }\ncalculateNorm(vector3D)\n</code></pre>\n<p>위의 코드는 구조적 타이핑 관점에서 오류가 발생하지 않는다. 하지만 수학적으로 따지면 2차원 벡터를 사용하는 것이 이치에 맞다.\n3차원 벡터를 허용하지 않게 하려면 공식 명칭을 사용하면 된다.\n값의 관점에서 vector2D라고 정의해주는 것이다. 타입스크립트에서 흉내내기 위해서는 상표를 붙이면 된다.</p>\n<pre><code class=\"language-ts\">interface Vector2D {\n  _brand: \"2d\"\n  x: number\n  y: number\n}\n\ncalculateNorm({ x: 1, y: 2, _brand: \"2d\" }) //1\ncalculateNorm({ x: 1, y: 2, z: 5, _brand: \"2d\" }) //2\n</code></pre>\n<p>2번째 함수 호출부에서 처럼 악의적으로 공식 명칭을 흉내내는 것을 방지하지는 못한다. 다만 프로그래머에게 실수를 알려주기에는 충분하다.</p>\n<p>상표 기법은 타입 시스템에서 동작하지만 런타임에 상표를 검사하는 것과 동일한 효과를 얻을 수 있다. 타입 시스템으로 런타임 오버헤드가 없고 속성이 없는 string 또는 number와 같은 내장 타입도 상표화 할 수 있다.</p>\n<p>절대 경로를 이용하여 파일 시스템에 접근하는 함수를 통해서 가정해보자.\n런타임에는 절대 경로로 시작하는지 체크하기가 쉽지만, 타입 시스템에서는 판단하기 어렵기 때문에 상표 기법을 사용한다.</p>\n<pre><code class=\"language-ts\">type AbsolutePath = string &#x26; { _brand: \"abs\" }\nfunction listAbsolutePath(path: AbsolutePath) {}\nfunction isAbsolutePath(path: string): path is AbsolutePath {\n  return path.startsWith(\"/\")\n}\n</code></pre>\n<p>AbsolutePath 타입의 경우 string이면서 _brand 속성을 가지는 객체라는게 애초에 말이 안된다. 온전히 타입 시스템의 영역이다.</p>\n<p>만일 절대경로인지, 상대경로인지 확실하지 않다면 타입 가드를 사용해서 오류를 방지할 수 있다.</p>\n<pre><code class=\"language-ts\">function someFunc(path: string) {\n  if (isAbsolutePath(path)) {\n    listAbsolutePath(path)\n  }\n}\n</code></pre>\n<p>로직 분기 대신 타입 단언문을 사용해도 되지만, 타입 단언문은 사용을 지양해야한다.</p>\n<p>추가적인 예시로는 오름차순으로 정렬된 배열인지 체크하는 타입이다.</p>\n<pre><code class=\"language-ts\">type SortedList&#x3C;T> = T[] &#x26; { _brand: \"sorted\" }\nfunction isSorted&#x3C;T>(arr: T[]): arr is SortedList&#x3C;T> {\n  for (let i = 1; i &#x3C; arr.length; i++) {\n    if (arr[i - 1] > arr[i]) return false\n  }\n  return false\n}\n\nfunction binarySearch&#x3C;T>(arr: SortedList&#x3C;T>, target: number): number {\n  //....\n}\n</code></pre>","id":"27f1f9a9-60f2-5cc2-8568-7508e31822cc"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}