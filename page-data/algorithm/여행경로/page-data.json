{"componentChunkName":"component---src-templates-post-template-tsx","path":"/algorithm/여행경로/","result":{"pageContext":{"node":{"fields":{"slug":"/algorithm/여행경로/"},"excerpt":"문제 링크 해결 전략 우리는 주어진 항공권을 모두 이용해야한다. 즉 항공권을 모두 사용하는 케이스를 탐색해야한다.\n만일 가능한 경로가 2개 이상 있을 때, 알파벳 순서가 앞서는 경로를 리턴해야 하므로 BFS로 탐색하고 만족하는 값을 찾으면 탐색을 중지하도록 하겠다. 탐색하는 방법은 간단하다. 티켓 중에서 시작점이 마지막에 방문한 도시와 일치하는 티켓들을 찾고 알파벳 순서로 정렬 후 방문한다. 이 과정을 모든 티켓을 사용(방문)할 떄 까지 반복…","frontmatter":{"date":"2022-10-06T00:00:00.000Z","description":"DFS/BFS","title":"여행 경로"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/43164\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>우리는 주어진 항공권을 모두 이용해야한다. 즉 항공권을 모두 사용하는 케이스를 탐색해야한다.\n만일 가능한 경로가 2개 이상 있을 때, 알파벳 순서가 앞서는 경로를 리턴해야 하므로 BFS로 탐색하고 만족하는 값을 찾으면 탐색을 중지하도록 하겠다.</p>\n<p>탐색하는 방법은 간단하다. 티켓 중에서 시작점이 마지막에 방문한 도시와 일치하는 티켓들을 찾고 알파벳 순서로 정렬 후 방문한다. 이 과정을 모든 티켓을 사용(방문)할 떄 까지 반복한다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-javascript\">class Queue {\n  constructor() {\n    this.front = 0\n    this.rear = 0\n    this.queue = []\n  }\n\n  enqueue(data) {\n    this.queue[this.rear++] = data\n  }\n\n  dequeue() {\n    const value = this.queue[this.front]\n    delete this.queue[this.front]\n    this.front++\n    return value\n  }\n\n  size() {\n    return this.rear - this.front\n  }\n}\n\n//시작점이 마지막에 방문한 도시인 티켓들을 찾고, 알파벳 순서로 정렬하는 코드\nconst findMatchTickets = (start, tickets, visited) => {\n  const result = []\n  for (let i = 0; i &#x3C; tickets.length; i++) {\n    if (!visited[i] &#x26;&#x26; tickets[i][0] === start) {\n      result.push({ i, end: tickets[i][1] })\n    }\n  }\n  result.sort((a, b) => (a.end > b.end) - (a.end &#x3C; b.end))\n  return result\n}\n\nfunction solution(tickets) {\n  const visited = Array(tickets.length).fill(false)\n\n  const queue = new Queue()\n  queue.enqueue({ visited, path: [\"ICN\"] })\n\n  while (queue.size() > 0) {\n    const { visited, path } = queue.dequeue()\n    if (visited.every(v => v)) return path\n\n    const lastVisited = path[path.length - 1]\n    const matchedTickets = findMatchTickets(lastVisited, tickets, visited)\n\n    matchedTickets.forEach(({ i, end }) => {\n      const newVistied = [...visited]\n      newVistied[i] = true\n      queue.enqueue({ visited: newVistied, path: [...path, end] })\n    })\n  }\n}\n</code></pre>\n<h1>추가</h1>\n<p>BFS가 아닌, DFS를 이용해도 문제를 해결할 수 있다. 다만 우리는 알파벳 순서가 앞서는 경로를 리턴해야 하므로 BFS와 동일하게 알파벳 순서가 앞서는 경로를 먼저 넣어주고, 만일 모든 티켓을 방문했다면 즉 정답을 찾았다면 DFS 탐색을 중지한다.</p>\n<pre><code class=\"language-javascript\">const findMatchTickets = (start, tickets) => {\n  const result = []\n  for (let i = 0; i &#x3C; tickets.length; i++) {\n    if (tickets[i][0] === start) {\n      result.push({ i, end: tickets[i][1] })\n    }\n  }\n  result.sort((a, b) => (a.end > b.end) - (a.end &#x3C; b.end))\n  return result\n}\n\nfunction solution(tickets) {\n  let answer = null\n\n  function dfs(leftTickets, lastVisited, path) {\n    if (answer) return\n    if (leftTickets.length === 0) {\n      answer = path\n    }\n\n    findMatchTickets(lastVisited, leftTickets).forEach(({ i, end }) => {\n      dfs(\n        leftTickets.filter((_, index) => index !== i),\n        end,\n        [...path, end]\n      )\n    })\n  }\n  dfs(tickets, \"ICN\", [\"ICN\"])\n  return answer\n}\n</code></pre>","id":"67afa8fd-00e6-5210-b346-9cbaa9fa80c8"},"previous":{"fields":{"slug":"/programming/git/"},"excerpt":"merge 병합은 두 브랜치의 합집합을 구하는 것이다. 병합에는 3가지 종류가 있다. merge commit 서로 다른 변경된 부분이 있을 경우, 새롭게 저장한다. fast-forward 합친 결과물이 한 커밋의 결과물과 동일할 때 새로운 상태를 만들어 줄 필요없이 상태를 바꿔주면 된다. conflict 동일한 부분이 다를 경우 충돌이 일어나게 된다. pull request 정중하게 브랜치 병합을 요청하는 것이다. 풀 리퀘 제목: 동료 개발자…","frontmatter":{"date":"2022-10-06T00:00:00.000Z","description":"merge, pull request, fork, rebase..","title":"git 사용법"},"html":"<h1>merge</h1>\n<p>병합은 두 브랜치의 합집합을 구하는 것이다. 병합에는 3가지 종류가 있다.</p>\n<ol>\n<li>merge commit\n<ul>\n<li>서로 다른 변경된 부분이 있을 경우, 새롭게 저장한다.</li>\n</ul>\n</li>\n<li>fast-forward\n<ul>\n<li>합친 결과물이 한 커밋의 결과물과 동일할 때 새로운 상태를 만들어 줄 필요없이 상태를 바꿔주면 된다.</li>\n</ul>\n</li>\n<li>conflict\n<ul>\n<li>동일한 부분이 다를 경우 충돌이 일어나게 된다.</li>\n</ul>\n</li>\n</ol>\n<h1>pull request</h1>\n<p>정중하게 브랜치 병합을 요청하는 것이다.</p>\n<ul>\n<li>풀 리퀘 제목: 동료 개발자가 한 눈에 이해하기 쉬운 제목을 적어둔다.</li>\n<li>풀 리퀘 내용: 코드를 이해하는데 도움이 되는 설명을 적어준다. 스크린샷 혹은 테스트 방법</li>\n<li>reviewers: 콕 찝어서 풀 리퀘 검토 요청, 같은 팀원 혹은 해당 기능과 연관된 동료 선택</li>\n</ul>\n<h1>fork</h1>\n<p>타인의 원본저장소를 내 계정의 원격저장소로 복사해오는 명령어이다.\n브랜치를 포함한 원본저장소의 모든 커밋 이력을 통째로 복사한다.</p>\n<h3>오픈 소스 기여 방식</h3>\n<p>원본 저장소에는 지정된 collaborators만 코드를 푸쉬할 수 있다. 오픈소스 프로젝트에서 만일 collaborators가 너무 많아진다면 저장소를 관리하는데 어려워질 것이다. 하지만 동시에 많은 개발자들에게 의견을 받고 오픈소스를 개선하고 싶은 니즈가 있다. 이럴 때 개발자는 fork를 해서 원본 저장소를 복사하고, 이곳에 커밋을 올린 다음에 원본 저장소의 소유자에게 풀 리퀘를 요청하면 원본 저장소의 소유자는 개발자의 병합 요청을 검토해서 원본 저장소에 반영한다.</p>\n<h3>원본 저장소에 풀 리퀘 보내기</h3>\n<p>new pull request 버튼을 누르고 head repository, base repository가 뜬다면 성공이다.\n풀 리퀘에 대한 설명을 적고 요청을 보낸다. 만일 원본저장소에 컨트리뷰션 가이드가 있다면 읽고 준수하도록 한다. 보통 README.md에 존재한다.</p>\n<p>풀 리퀘를 승인하는 방법은, 좌측 카테고리에 fork 탭을 클릭하고 pull requests 탭을 클릭하면 요청된 풀 리퀘들을 확인할 수 있다. 댓글만 달고 싶다면 comment를, 댓글을 달고 코드가 좋아보여 바로 병합해도 되면 approve를, 수정을 요청하고 싶으면 request changes를 선택한다.</p>\n<h1>add remote</h1>\n<p>내 원격 저장소에서 원본 저장소의 히스토리도 같이 보고싶다면, add remote를 해주면 된다. 원격 이름에는 upstream을 넣어주고 원본 저장소 주소를 복사해서 넣어주면 된다. upstream은 원본 저장소를 지칭하는 관용적 닉네임이다.</p>\n<p><code>fetch</code>를 하게 되면 원본 저장소에 있는 커밋 히스토리를 받아올 수 있다. pull과는 다른 점은 커밋 이력만 받아오기 때문에 내 코드에는 아무 영향이 없다.</p>\n<h1>rebase</h1>","id":"6a5ee1a7-b8a6-5d22-8968-6a91a6171688"},"next":{"fields":{"slug":"/algorithm/섬연결하기/"},"excerpt":"문제 링크 해결 전략 최소의 비용으로 모든 섬이 통행 가능하도록 만들 때, 필요한 최소 비용을 구하라는 문제이다.\n모든 섬이 통행 가능하도록 이란 의미는 신장 트리를 만족해야 하고, 최소 비용을 구해야 하기 때문에 최소 신장 트리 구조를 만족해야 한다. 크루스칼 알고리즘은 최소 신장트리를 만족하면서 최소 거리를 구할 수 있는 알고리즘이다. 정답 코드","frontmatter":{"date":"2022-10-09T00:00:00.000Z","description":"크루스칼 알고리즘","title":"섬 연결하기"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42861\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>최소의 비용으로 모든 섬이 통행 가능하도록 만들 때, 필요한 최소 비용을 구하라는 문제이다.\n모든 섬이 통행 가능하도록 이란 의미는 신장 트리를 만족해야 하고, 최소 비용을 구해야 하기 때문에 최소 신장 트리 구조를 만족해야 한다. 크루스칼 알고리즘은 최소 신장트리를 만족하면서 최소 거리를 구할 수 있는 알고리즘이다.</p>\n<h1>정답 코드</h1>\n<pre><code class=\"language-js\">function solution(n, costs) {\n  costs.sort((a, b) => a[2] - b[2])\n\n  const parent = Array(n + 1)\n    .fill()\n    .map((_, i) => i)\n\n  const findParent = (parent, x) => {\n    if (parent[x] !== x) {\n      parent[x] = findParent(parent, parent[x])\n    }\n    return parent[x]\n  }\n\n  const union = (parent, a, b) => {\n    a = findParent(parent, a)\n    b = findParent(parent, b)\n    if (a === b) return true\n    //사이클이 발생한다면 수행하지 않음.\n    if (a > b) {\n      parent[a] = b\n    } else {\n      parent[b] = a\n    }\n    return false\n  }\n\n  let sum = 0\n  costs.forEach(([st, end, cost]) => {\n    const cycle = union(parent, st, end)\n    if (!cycle) sum += cost\n  })\n  return sum\n}\n</code></pre>","id":"4f70b8f8-12c8-587f-9e69-0c24e1cf9a28"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}