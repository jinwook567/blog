{"componentChunkName":"component---src-templates-post-template-tsx","path":"/algorithm/섬연결하기/","result":{"pageContext":{"node":{"fields":{"slug":"/algorithm/섬연결하기/"},"excerpt":"문제 링크 해결 전략 최소의 비용으로 모든 섬이 통행 가능하도록 만들 때, 필요한 최소 비용을 구하라는 문제이다.\n모든 섬이 통행 가능하도록 이란 의미는 신장 트리를 만족해야 하고, 최소 비용을 구해야 하기 때문에 최소 신장 트리 구조를 만족해야 한다. 크루스칼 알고리즘은 최소 신장트리를 만족하면서 최소 거리를 구할 수 있는 알고리즘이다. 정답 코드","frontmatter":{"date":"2022-10-09T00:00:00.000Z","description":"크루스칼 알고리즘","title":"섬 연결하기"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42861\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>최소의 비용으로 모든 섬이 통행 가능하도록 만들 때, 필요한 최소 비용을 구하라는 문제이다.\n모든 섬이 통행 가능하도록 이란 의미는 신장 트리를 만족해야 하고, 최소 비용을 구해야 하기 때문에 최소 신장 트리 구조를 만족해야 한다. 크루스칼 알고리즘은 최소 신장트리를 만족하면서 최소 거리를 구할 수 있는 알고리즘이다.</p>\n<h1>정답 코드</h1>\n<pre><code class=\"language-js\">function solution(n, costs) {\n  costs.sort((a, b) => a[2] - b[2])\n\n  const parent = Array(n + 1)\n    .fill()\n    .map((_, i) => i)\n\n  const findParent = (parent, x) => {\n    if (parent[x] !== x) {\n      parent[x] = findParent(parent, parent[x])\n    }\n    return parent[x]\n  }\n\n  const union = (parent, a, b) => {\n    a = findParent(parent, a)\n    b = findParent(parent, b)\n    if (a === b) return true\n    //사이클이 발생한다면 수행하지 않음.\n    if (a > b) {\n      parent[a] = b\n    } else {\n      parent[b] = a\n    }\n    return false\n  }\n\n  let sum = 0\n  costs.forEach(([st, end, cost]) => {\n    const cycle = union(parent, st, end)\n    if (!cycle) sum += cost\n  })\n  return sum\n}\n</code></pre>","id":"4f70b8f8-12c8-587f-9e69-0c24e1cf9a28"},"previous":{"fields":{"slug":"/algorithm/여행경로/"},"excerpt":"문제 링크 해결 전략 우리는 주어진 항공권을 모두 이용해야한다. 즉 항공권을 모두 사용하는 케이스를 탐색해야한다.\n만일 가능한 경로가 2개 이상 있을 때, 알파벳 순서가 앞서는 경로를 리턴해야 하므로 BFS로 탐색하고 만족하는 값을 찾으면 탐색을 중지하도록 하겠다. 탐색하는 방법은 간단하다. 티켓 중에서 시작점이 마지막에 방문한 도시와 일치하는 티켓들을 찾고 알파벳 순서로 정렬 후 방문한다. 이 과정을 모든 티켓을 사용(방문)할 떄 까지 반복…","frontmatter":{"date":"2022-10-06T00:00:00.000Z","description":"DFS/BFS","title":"여행 경로"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/43164\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>우리는 주어진 항공권을 모두 이용해야한다. 즉 항공권을 모두 사용하는 케이스를 탐색해야한다.\n만일 가능한 경로가 2개 이상 있을 때, 알파벳 순서가 앞서는 경로를 리턴해야 하므로 BFS로 탐색하고 만족하는 값을 찾으면 탐색을 중지하도록 하겠다.</p>\n<p>탐색하는 방법은 간단하다. 티켓 중에서 시작점이 마지막에 방문한 도시와 일치하는 티켓들을 찾고 알파벳 순서로 정렬 후 방문한다. 이 과정을 모든 티켓을 사용(방문)할 떄 까지 반복한다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-javascript\">class Queue {\n  constructor() {\n    this.front = 0\n    this.rear = 0\n    this.queue = []\n  }\n\n  enqueue(data) {\n    this.queue[this.rear++] = data\n  }\n\n  dequeue() {\n    const value = this.queue[this.front]\n    delete this.queue[this.front]\n    this.front++\n    return value\n  }\n\n  size() {\n    return this.rear - this.front\n  }\n}\n\n//시작점이 마지막에 방문한 도시인 티켓들을 찾고, 알파벳 순서로 정렬하는 코드\nconst findMatchTickets = (start, tickets, visited) => {\n  const result = []\n  for (let i = 0; i &#x3C; tickets.length; i++) {\n    if (!visited[i] &#x26;&#x26; tickets[i][0] === start) {\n      result.push({ i, end: tickets[i][1] })\n    }\n  }\n  result.sort((a, b) => (a.end > b.end) - (a.end &#x3C; b.end))\n  return result\n}\n\nfunction solution(tickets) {\n  const visited = Array(tickets.length).fill(false)\n\n  const queue = new Queue()\n  queue.enqueue({ visited, path: [\"ICN\"] })\n\n  while (queue.size() > 0) {\n    const { visited, path } = queue.dequeue()\n    if (visited.every(v => v)) return path\n\n    const lastVisited = path[path.length - 1]\n    const matchedTickets = findMatchTickets(lastVisited, tickets, visited)\n\n    matchedTickets.forEach(({ i, end }) => {\n      const newVistied = [...visited]\n      newVistied[i] = true\n      queue.enqueue({ visited: newVistied, path: [...path, end] })\n    })\n  }\n}\n</code></pre>\n<h1>추가</h1>\n<p>BFS가 아닌, DFS를 이용해도 문제를 해결할 수 있다. 다만 우리는 알파벳 순서가 앞서는 경로를 리턴해야 하므로 BFS와 동일하게 알파벳 순서가 앞서는 경로를 먼저 넣어주고, 만일 모든 티켓을 방문했다면 즉 정답을 찾았다면 DFS 탐색을 중지한다.</p>\n<pre><code class=\"language-javascript\">const findMatchTickets = (start, tickets) => {\n  const result = []\n  for (let i = 0; i &#x3C; tickets.length; i++) {\n    if (tickets[i][0] === start) {\n      result.push({ i, end: tickets[i][1] })\n    }\n  }\n  result.sort((a, b) => (a.end > b.end) - (a.end &#x3C; b.end))\n  return result\n}\n\nfunction solution(tickets) {\n  let answer = null\n\n  function dfs(leftTickets, lastVisited, path) {\n    if (answer) return\n    if (leftTickets.length === 0) {\n      answer = path\n    }\n\n    findMatchTickets(lastVisited, leftTickets).forEach(({ i, end }) => {\n      dfs(\n        leftTickets.filter((_, index) => index !== i),\n        end,\n        [...path, end]\n      )\n    })\n  }\n  dfs(tickets, \"ICN\", [\"ICN\"])\n  return answer\n}\n</code></pre>","id":"67afa8fd-00e6-5210-b346-9cbaa9fa80c8"},"next":{"fields":{"slug":"/algorithm/기지국설치/"},"excerpt":"문제 링크 해결 전략 이 문제는 아이디어로 푸는 문제이다. 우리가 구하고자 하는 값은 추가적으로 설치된 기지국의 개수이다. 즉, 기지국이 어디에 설치되는지는 알 필요가 없다는 의미이다. 작은 예시를 통해서 설치해야 할 기지국 개수를 알아본다. 만일 기지국이 전혀 없는 4개의 아파트가 있다고 가정하고, 전파 도달 거리가 1이라면 몇 개의 기지국 설치가 필요할까? 1개의 기지국이 차지하는 영역은 본인의 자리 + 앞 뒤로 w 만큼이다. 즉 2*w+…","frontmatter":{"date":"2022-10-12T00:00:00.000Z","description":"투포인터","title":"기지국 설치"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/12979\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>이 문제는 아이디어로 푸는 문제이다.</p>\n<p><strong>우리가 구하고자 하는 값은 추가적으로 설치된 기지국의 개수이다.</strong> 즉, 기지국이 어디에 설치되는지는 알 필요가 없다는 의미이다.</p>\n<p>작은 예시를 통해서 설치해야 할 기지국 개수를 알아본다. 만일 기지국이 전혀 없는 4개의 아파트가 있다고 가정하고, 전파 도달 거리가 1이라면 몇 개의 기지국 설치가 필요할까?</p>\n<p>1개의 기지국이 차지하는 영역은 본인의 자리 + 앞 뒤로 w 만큼이다. 즉 <code>2*w+1</code>의 길이만큼 차지하게 된다. 위의 예시의 경우 총 2개의 기지국 설치가 필요하다. 기지국의 영역이 4를 넘어가기는 하지만, 전체 영역을 채워야 하기에 2개가 필요하다. <code>3 * 2 > 4</code></p>\n<p>문제에서는 기지국이 설치된 <code>stations</code> 배열이 주어진다. <strong>추가적으로 기지국을 설치해야 할 부분은 설치된 기지국들이 포함하지 못하는 기지국이 전혀 없는 영역이다.</strong></p>\n<p>우리는 방금 예시를 통해서 기지국이 전혀 없는 영역에서 몇개의 기지국을 설치해야 하는지 알게되었다. 그렇다면 이제 필요한 것은 기지국이 전혀 없는 영역을 구하는 것이다.</p>\n<p>기지국이 전혀 없는 영역을 구하기 위해서는 투포인터 알고리즘을 사용하면 된다.</p>\n<pre><code>before = 이전 기지국의 전파가 도달하지 않는 우측 위치.\ncurrent = 현재 기지국의 전파가 마지막으로 도달하는 좌측 위치.\n</code></pre>\n<p>또한 가장 중요한 부분은 포인터에 넣을 위치를 기지국이 마지막으로 포함하는 거리인지, 아니면 바로 못미치는 영역인지 정의해주어야 한다.</p>\n<p>나는 기지국이 처음 시작할 때의 환경을 고려하여 <code>before</code> 변수에는 기지국이 존재하지 않는 상태의 위치, <code>current</code> 변수에는 기지국이 마지막으로 포함하는 거리로 넣어주었다.</p>\n<pre><code class=\"language-js\">let current = 1\nlet before = 1\n\nlet answer = 0\nconst area = w => w * 2 + 1\n\nfor (let i = 0; i &#x3C; stations.length; i++) {\n  current = stations[i] - w\n\n  const diff = current - before\n\n  if (diff > 0) {\n    answer += Math.ceil(diff / area(w))\n  }\n\n  before = stations[i] + w + 1\n}\n</code></pre>\n<p>마지막 라인에 <code>before</code>변수를 <code>stations[i] + w + 1</code>로 초기화 시켜준 이유는 i번째 기지국이 이제 이전 기지국이 되었으며 <code>stations[i] + w + 1</code>이 전파가 도달하지 않는 우측 위치이다.</p>\n<pre><code class=\"language-js\">if (before &#x3C;= n) {\n  answer += Math.ceil((n - before + 1) / area(w))\n}\n</code></pre>\n<p>마지막으로 위의 코드가 필요하다. 왜냐면 마지막 기지국이 n까지 전파가 닿지 않는다면 해당 부분을 채워주어야 하기 때문이다. 여기서 n은 기지국이 설치되어 있지 않는 상태이기 때문에 <code>before &#x3C;=n</code>으로 작성했으며 <code>n-before+1</code>을 한 값을 <code>area(w)</code>로 나누었다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-js\">function solution(n, stations, w) {\n  let current = 1\n  let before = 1\n\n  let answer = 0\n  const area = w => w * 2 + 1\n\n  for (let i = 0; i &#x3C; stations.length; i++) {\n    current = stations[i] - w\n\n    const diff = current - before\n\n    if (diff > 0) {\n      answer += Math.ceil(diff / area(w))\n    }\n\n    before = stations[i] + w + 1\n  }\n\n  if (before &#x3C;= n) {\n    answer += Math.ceil((n - before + 1) / area(w))\n  }\n  return answer\n}\n</code></pre>","id":"64862fdb-5291-5542-a334-ce268422ecc5"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}