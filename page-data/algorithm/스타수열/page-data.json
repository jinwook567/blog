{"componentChunkName":"component---src-templates-post-template-tsx","path":"/algorithm/스타수열/","result":{"pageContext":{"node":{"fields":{"slug":"/algorithm/스타수열/"},"excerpt":"문제 링크 해결 전략 처음에 이 문제를 완전탐색 형태로 해결하고자 하였다. a의 부분 수열을 모두 만들고, 스타 수열인지 확인하는 방식으로 알고리즘을 짰다. 하지만 이 방식은, a의 길이가 최대 500,000이므로 절대 만족할 수 없다. 조합의 경우 O(2^n)의 시간 복잡도를 가지기 때문이다. 그렇다면 반대로 생각해봐야 한다. 모든 부분 수열을 만들어보고 스타 수열인지 검증하는 대신, 주어진 배열을 활용해서 직접 스타 수열을 만들어보면 된다…","frontmatter":{"date":"2022-10-13T00:00:00.000Z","description":"백트래킹","title":"스타수열"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/70130\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>처음에 이 문제를 완전탐색 형태로 해결하고자 하였다. a의 부분 수열을 모두 만들고, 스타 수열인지 확인하는 방식으로 알고리즘을 짰다. 하지만 이 방식은, a의 길이가 최대 500,000이므로 절대 만족할 수 없다. 조합의 경우 O(2^n)의 시간 복잡도를 가지기 때문이다.</p>\n<p>그렇다면 <strong>반대로 생각해봐야 한다.</strong> 모든 부분 수열을 만들어보고 스타 수열인지 검증하는 대신, 주어진 배열을 활용해서 직접 스타 수열을 만들어보면 된다!</p>\n<p>스타수열을 만들 때, 우리는 중복된 숫자가 꼭 필요하다. 따라서 중복된 숫자가 많을수록 더 길이가 긴 스타수열을 만들 수 있다. 하지만 중복된 숫자가 많다고 해서 꼭 스타수열의 길이가 긴 것은 아니기에, 중복된 숫자의 개수가 큰 순서대로 검증해나가는 백트래킹 방식을 사용하면 된다.</p>\n<p><code>[1,1,1,1,1,1,1,1,1,1,2,3,2,3,2]</code>과 같은 배열의 경우 1이 가장 많은 중복된 숫자지만, 1을 교집합으로 두었을 때 스타 수열을 만들 수 없다. 1이 연속적으로 배치되어 있어 i번쨰와 i+1번째가 같기 때문이다. 따라서 그 다음으로 중복된 개수가 많은 2를 검증해야 한다.</p>\n<p>스타 수열 조건을 만족하는 부분 수열들을 찾아나가면서 합하는 방식으로 스타 수열의 최대 길이를 구할 것이다. 최대한 길이가 긴 스타 수열을 구하기 위해서는 좌측부터 만족시키면서 나가면 된다. 그래야 우측에 남은 배열의 길이가 길어져 더 길이가 긴 부분 수열을 만들 수 있다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-js\">function solution(a) {\n  //배열 내에서, 중복된 숫자의 순서가 많은 순서대로 정렬한다.\n  const obj = {}\n  a.forEach(v => {\n    if (!obj[v]) obj[v] = 1\n    else obj[v] += 1\n  })\n\n  const sameNumberCounts = Object.entries(obj).sort((a, b) => b[1] - a[1])\n\n  //스타 수열을 만족하는 최대 부분 수열을 찾는다.\n  let answer = 0\n\n  for (let [number, cnt] of sameNumberCounts) {\n    number = Number(number)\n    if (answer > cnt) break\n\n    let len = 0\n    for (let i = 0; i &#x3C; a.length; i++) {\n      if (a[i + 1] === undefined) continue\n\n      if (a[i] === number &#x26;&#x26; a[i + 1] !== number) {\n        len += 2\n        i++\n        continue\n      }\n      //좌측부터 만족하는지 확인, 좌측부터 만족하는지 확인해야 남는 우측 길이가 김.\n\n      if (a[i] !== number &#x26;&#x26; a[i + 1] === number) {\n        len += 2\n        i++\n        continue\n      }\n      //좌측이 만족하지 않는다면 우측으로 확인\n    }\n    answer = Math.max(answer, len)\n  }\n  return answer\n}\n</code></pre>","id":"49b9c8f7-4c12-5e61-8886-048e71e5abec"},"previous":{"fields":{"slug":"/programming/함수형 자바스크립트/2장/"},"excerpt":"함수형 대 객체지향 프로그래밍 객체지향은 잘게 나뉜 기능을 구현하기위해 상속을 통하여 특수한 자료형을 생성한다.\n예시로 학습 관리 시스템의 Student 객체를 모형화 해보면 해당 클래스는 Person 클래스의 하위형이다. 만일 대학교를 다니는 학생이라면, ColleageStudent 같은 형식을 만들어서 붙인다.\nOOP는 새로운 파생 객체를 생성하여 코드를 재사용한다. 하지만 이러한 방식은 모든 하위형에 적용할 필요가 없는 기능을 기존 객체…","frontmatter":{"date":"2022-10-13T00:00:00.000Z","description":"고계 자바스크립트","title":"함수형 자바스크립트 2장"},"html":"<h1>함수형 대 객체지향 프로그래밍</h1>\n<p>객체지향은 잘게 나뉜 기능을 구현하기위해 상속을 통하여 특수한 자료형을 생성한다.\n예시로 학습 관리 시스템의 <code>Student</code> 객체를 모형화 해보면 해당 클래스는 <code>Person</code> 클래스의 하위형이다. 만일 대학교를 다니는 학생이라면, <code>ColleageStudent</code> 같은 형식을 만들어서 붙인다.\n<strong>OOP는 새로운 파생 객체를 생성하여 코드를 재사용한다.</strong></p>\n<p>하지만 이러한 방식은 모든 하위형에 적용할 필요가 없는 기능을 기존 객체에 추가할 때 문제가 발생한다. 예를 들면 <code>Person</code>에 <code>workAddress</code>라는 속성이 있다고 가정해보자. 이는 <code>Student</code>, <code>ColleageStudent</code> 객체에서 전혀 쓸모가 없다.</p>\n<p>명령형 코드인 OOP는 인스턴스 메소드를 통해 가변 상태를 노출하고 조작하는데 이를 위해서 캡슐화에 지나치게 의존하여 무결성을 유지한다. 데이터와 기능이 단단히 응집된다.</p>\n<p>반면에 함수형은 호출자로부터 데이터를 숨길 필요 없이 소규모의, 아주 단순한 자료형만을 대상으로 움직인다. 즉 데이터와 기능이 느슨하게 결합되어 있다.</p>\n<p>FP와 OOP를 적절히 조합하면 최고의 생산성으로 코드를 짤 수 있다. 그러기 위해서는 객체를 불변 개체나 불변 값으로 바라보고 기능을 함수로 분리하여 객체 내에서 작동되게끔 해야한다. <code>Person</code> 객체를 통해서 예시를 들어보자.</p>\n<pre><code class=\"language-js\">//oop\nget fullname(){\n    return [this._firstname, this._lastname].join('')\n}\n\n//함수로 분리\nconst fullname = (person) => [person._firstname, person._lastname].join('')\n</code></pre>\n<p>기반형을 레퍼런스를 사용하는 함수라면 파생형 객체에서도 문제없이 작동한다. (<code>Student</code>나 <code>ColleageStudent</code>에도 <code>Person</code>의 <code>_firstname</code>, <code>_lastname</code>을 상속받기 때문.)\n독립형 함수로 분리함으로써 객체 데이터를 this로 접근할 이유가 사라진다. this를 사용한다는 것이 메소드에 범위의 벗어나 인스턴스 수준의 데이터에 접근한다는 것으로 부수효과를 발생한다. 또한 범용성이 높아졌다.</p>\n<h1>JS 객체의 상태 관리</h1>\n<p>프로그램의 상태란 어느 한 시점에 찍은 모든 객체에 저장된 데이터의 스냅샷이다. JS는 객체 상태를 보호하는 측면에서 최악의 언어 중 하나이기에 함수형 프로그래밍을 하기 위해서는 객체의 상태 관리에 유의해야 한다. 불변성 관리를 위한 지침과 패턴을 소개하도록 한다.</p>\n<ol>\n<li>객체를 값으로 취급</li>\n<li>가동부를 깊이 동결</li>\n<li>객체 그래프를 렌즈로 탐색 수정</li>\n</ol>\n<h2>1. 객체를 값으로 취급</h2>\n<p>숫자와, 문자열 같은 자료형은 불변값이다. FP에서는 이러한 불변값을 값(value)이라고 한다.</p>\n<p>객체 구조가 단순하다면 값-객체 패턴도 괜찮은 방안이다. 값 객체는 객체의 동등성이 항등성이나 레퍼런스가 아닌 오직 값에 따라 좌우되는 객체이다. 일단 값 객체를 선언한 이후엔 그 상태는 절대 변하지 않는다. 예시로 클로저를 사용하고 내부 상태 변화를 일으키지 않는 메소드만을 제공한다면, 외부에서 접근하여 값을 변경할 수 없다. 동일한 모형의 값이 다른 객체가 필요한 경우 사본을 만들어서 리턴한다.</p>\n<h2>2. 가동부를 깊이 동결</h2>\n<p>실무에서 모든 객체를 값-객체 패턴으로 만들 수 없다. 또한 Student-Person과 같은 계층적 데이터를 처리하는 코드가 필요할 때가 있다.\nwritable처럼 숨겨진 메타속성을 제어하면 내부 조작이 가능하다. Object.freeze() 함수는 writable 속성을 전부 false로 세팅하여 객체 상태를 못 바꾸도록 동결한다. 하지만 객체 내부의 객체와 같은 중첩 객체의 경우에는 동결되지 않는 얕은 동결이기에 만일 객체 내부의 모든 값을 동결시키기를 원한다면 재귀함수를 이용하여 구현해줘야 한다.</p>\n<p>하지만 상태를 전혀 바꿀 수 없는 애플리케이션이란 현실적이지 않다. 원본 객체에서 새 객체를 만드는 엄격한 정책을 적용하면 도움이 된다.</p>\n<h2>3. 객체 그래프를 렌즈로 탐색/수정</h2>\n<p>해당 방식은 원본 객체에서, 새 객체를 만드는 방식이다. 다만 내부 저장소 컴포넌트를 이용하기에 한번 등록 시켜놓으면 매번 새로운 객체를 만드는 행위를 할 필요가 없다. 람다JS라는 라이브러리가 해당 기능을 제공한다. R.set 함수는 원래 상태는 그대로 유지한 채 새로운 값이 포함된 객체 사본을 새로 만들어 반환한다. 중첩 객체까지 지원한다.</p>\n<h1>함수</h1>\n<h2>함수를 일급 시민으로</h2>\n<p>JS의 함수는 실제로 객체이기 때문에 일급이다.</p>\n<p><em>일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 뜻한다. 3가지 원칙을 만족해야한다. 1. 변수에 담을 수 있다. 2. 인자로 전달할 수 있다. 3. 반환값으로 전달할 수 있다.</em></p>\n<p><em>함수를 다른 변수와 동일하게 다루는 언어는 일급 함수를 가졌다라고 표현한다. 함수를 다른 함수의 인수로 제공하거나 함수가 함수를 반환할 수 있고, 변수에도 할당할 수 있다. 자바스크립트는 일급 함수를 가졌다.</em></p>\n<h2>고계 함수</h2>\n<p>함수를 함수 인수로 전달하거나 함수를 반환받을 수 있다. 이러한 함수를 고계함수(higher-order-function)이라고 한다. 예시로 Array.sort()의 comparator 함수도 고계함수이다.</p>\n<p>JS에서 함수는 일급+고계여서 여느 값이나 다름이 없다. 즉 자신이 받은 입력값을 기반으로 정의된 언제가는 실행될 값에 지나지 않는다.</p>\n<p>고계함수를 사용하면 아주 장황했을 프로그램이 매우 단순해진다. 미국 거주자 명단을 출력하는 프로그램 예시를 통해서 알아보도록 한다.</p>\n<pre><code class=\"language-js\">//명령형\nfunction printPeopleInUs(people) {\n  for (let person of people) {\n    if (person.address.country === \"US\") {\n      console.log(person)\n    }\n  }\n}\n</code></pre>\n<pre><code class=\"language-js\">//고계함수 이용\nfunction printPeople(people, action) {\n  for (let person of people) {\n    action(person)\n  }\n}\n\nfunction action(person) {\n  if (person.address.county === \"US\") {\n    console.log(person)\n  }\n}\n</code></pre>\n<pre><code class=\"language-js\">//범용성을 위한 리팩토링\nfunction printPeople(people, selector, printer) {\n  people.forEach(person => {\n    if (selector(person)) {\n      printer(person)\n    }\n  })\n}\n\nconst selector = person => person.address.country === \"US\"\nconst printer = somthing => console.log(somthing)\nprintPeople(people, selector, printer)\n</code></pre>\n<p>리팩토링을 통해서 데이터를 고르는 기준을 변경할 수 있고 출력 대상을 바꾸는 일도 자유롭다.</p>\n<h2>함수 호출 유형</h2>\n<ol>\n<li>전역 함수로 호출\n<ul>\n<li>this 레퍼런스는 전역 객체, 엄격 모드일 경우에는 undefined를 가르킨다.</li>\n</ul>\n</li>\n<li>메소드로 호출\n<ul>\n<li>this 레퍼런스는 해당 메서드를 소유한 객체이다.</li>\n</ul>\n</li>\n<li>new를 붙여 생성자로 호출\n<ul>\n<li>새로 만든 객체의 레퍼런스를 암시적으로 반환한다.</li>\n</ul>\n</li>\n</ol>\n<h2>함수 메서드</h2>\n<p>apply, call, map, filter와 같은 메소드가 있다.</p>\n<h1>클로저</h1>\n<p><a href=\"https://ko.javascript.info/closure\">클로저 상세 설명 링크</a></p>\n<p>클로저는 다음과 같이 응용될 수 있다.</p>\n<ol>\n<li>프라이빗 변수를 모방</li>\n<li>서버 측 비동기 호출</li>\n<li>가상의 블록 스코프 변수 생성</li>\n</ol>\n<h2>프라이빗 변수 모방</h2>\n<p>다른 프로그래밍 언어는 private 접근자로 객체 내부 속성을 세팅할 수 있으나 JS는 불가능하다. 클로저를 활용하면 프라이빗 변수를 모방할 수 있다.</p>\n<p>자바스크립트 라이브러리나 모듈 개발자는 전체 모듈의 프라이빗 메서드와 데이터를 숨길 때 클로저를 적극 활용한다. 이를 모듈 패턴이라고 한다. 전역 레퍼런스 개수를 줄이기 위해서 즉시 실행 함수를 사용한다.</p>\n<pre><code class=\"language-js\">var myModule = (function myModule(export){\n    //에러 발생 시 스택을 보며 추적할 수 있도록 함수에 이름을 붙인다.\n    let privateVar;\n\n    export.method1 = function () {\n        //작업 수행\n    }\n\n    export.method2 = function () {\n        //작업 수행\n    }\n    return export\n})(myModule || {})\n</code></pre>\n<h3>전역 스코프의 문제점</h3>\n<p>전역 스코프는 가장 단순하면서 나쁜 스코프이다. JS의 함수는 스코프 체인을 따라서 변수를 확인하기 떄문에 전역 스코프를 사용하는 것이 관찰 가능한 어떤 변화를 함수에 전파하는 것과 동일하다. 또한 전역 데이터는 변수 상태가 언제 어떻게 바뀌는지 디버깅하기 어렵다.</p>\n<h2>서버 측 비동기 호출</h2>\n<p>콜백 함수(고계 함수)를 사용하여 비동기 처리를 할 수 있다.</p>\n<h2>가상의 블록 스코프 변수 생성</h2>\n<p>루프 카운터 문제 역시 클로저로 해결할 수 있다. let을 쓴다면 기존 루프 체제 문제는 해결이 되지만, 클로저와 함수 스코프를 활용한 forEach가 정답이다. 루프 카운터와 다른 변수들을 스코프 내부에 묶느라 고민하지 않아도 루프문에 함수 스코프 블록이 존재하는 것처럼 루프 본체를 효과적으로 감쌀 수 있다.</p>\n<pre><code class=\"language-js\">const arr = [1, 2, 3, 4]\narr.forEach(el => {\n  let blockScopeVar = \"hi\"\n})\n</code></pre>","id":"8b6ed648-4502-5ab2-94ea-7b151bb8595d"},"next":{"fields":{"slug":"/tech/react/global-state/"},"excerpt":"React에서 전역 상태 관리는 왜 필요할까? 리액트는 단방향 데이터 바인딩이라는 특징을 가진다. 단방향 데이터 바인딩 특징은 어플리케이션이 예측 가능하다는 장점이 있지만, 뷰를 업데이트 해주는 부분을 매번 작성해주어야 한다는 단점이 있다. 리액트의 경우 뷰가 state에 따라서 자동으로 갱신되어 뷰를 업데이트 해주는 코드를 작성할 필요는 없지만, 이 state를 어플리케이션 구조에 맞게 잘 전달해주는 과정이 필요하다. 만일 컴포넌트 구조가 …","frontmatter":{"date":"2022-10-17T00:00:00.000Z","description":"전역 상태 관리는 왜 필요하고, 어떤 도구들이 있나","title":"React의 전역 상태 관리"},"html":"<h1>React에서 전역 상태 관리는 왜 필요할까?</h1>\n<p>리액트는 단방향 데이터 바인딩이라는 특징을 가진다. 단방향 데이터 바인딩 특징은 어플리케이션이 예측 가능하다는 장점이 있지만, 뷰를 업데이트 해주는 부분을 매번 작성해주어야 한다는 단점이 있다. 리액트의 경우 뷰가 state에 따라서 자동으로 갱신되어 뷰를 업데이트 해주는 코드를 작성할 필요는 없지만, 이 state를 어플리케이션 구조에 맞게 잘 전달해주는 과정이 필요하다. 만일 컴포넌트 구조가 매우 깊은 트리 구조라면 해당 state를 넘겨주는데 여러 단계를 거쳐야하고, 이 state가 어디서부터 전달되었는지 추적하기 어려울 것이다.</p>\n<p>이러한 문제를 해결하기위해 전역 상태 관리 도구는 어떠한 컴포넌트에서도 전역으로 관리되는 state에 바로 접근할 수 있도록 해준다. state를 전달하기위해 여러 단계를 거칠 필요가 없는 것이다.</p>\n<p>해당 상태가 어플리케이션 전반에 이용되어 상태를 전달하기 위한 단계가 복잡할 경우, 혹은 전반에 이용되지 않더라도 상태를 전달하기 위한 단계가 복잡할 경우 사용된다.</p>\n<h1>전역 상태 관리를 위한 도구들</h1>\n<h2>Redux</h2>\n<p>리덕스는 리액트 이외에도 자바스크립트로 만들어진 어플리케이션이라면 사용할 수 있다.</p>\n<p>리덕스는 액션이라고 불리는 이벤트를 통해서만 state를 업데이트 시킬 수 있다. 이는 리액트가 사용하는 단방향 데이터 바인딩과 같은 원리로 상태 변경을 예측하기 쉽도록 한다. 언제, 어디서, 왜, 어떻게 state가 변경되었는지 파악할 수 있다.</p>\n<p>리덕스의 이러한 구조는 상태의 변경이 예측 가능하다는 장점도 있지만, 러닝 커브가 있고 구현하기위해 더 많은 코드를 작성해야한다.</p>\n<h3>언제 리덕스를 도입하면 좋을까</h3>\n<ul>\n<li>어플리케이션이 많은 상태를 보유하고, 어플리케이션의 여러 공간에서 사용될 때</li>\n<li>상태가 매우 자주 변경될 때</li>\n<li>상태 변경 로직이 복잡할 때</li>\n<li>어플리케이션의 규모가 클 때, 많은 사람들과 작업해야 할 때</li>\n</ul>\n<p>예측 가능하고, 테스트가 쉽다는 장점에 대규모 어플리케이션에 적합하다. 또한 상태 변경을 손쉽게 추적할 수 있기에 상태 변경 로직이 복잡할 때도 사용하면 좋다.</p>\n<h3>주요 개념</h3>\n<ul>\n<li>스토어는 전역 state를 저장하는 곳으로 자바스크립트 object인데 특별한 함수와 기능을 내장하고 있어 순수 전역 객체와 다르다.</li>\n<li>우리는 스토어 내부의 state를 직접적으로 수정하면 안된다. 이는 정해진 방식으로만 state를 조작하여 예측가능하다는 redux의 원칙을 위배한다.</li>\n<li>state를 변경하는 방법은 순수 액션 객체를 만들고 활용함으로써 가능하다. 액션 객체는 어플리케이션에 무슨 일이 발생할 것인지 알려준다. 그리고 dispatch를 사용해서, action을 전달한다.</li>\n<li>액션이 dispatch되면, reducer를 실행시키고 old state를 기반으로 new state를 계산하여 업데이트한다. old state에서 new state로 변경시킬 때 immutable을 유지해야한다. 만약 immutable하지 않다면 old state와 new state를 비교할 때 문제가 발생하고 리듀서가 올바르게 작동하지 않는다. (객체는 참조값이기 때문에.)</li>\n<li>마지막으로 스토어는 subscribers에게 구독중인 state가 변경되었다고 알려주고 UI가 변경되게 된다.</li>\n</ul>\n<h2>Recoil</h2>\n<p>Recoil은 facebook에서 출시한 상태관리 라이브러리이다.</p>\n<p>state는 공통된 상위 컴포넌트로 끌어올려야만 공유될 수 있으며 이 과정에서 거대한 트리가 다시 렌더링 되는 문제와 Context는 단일값만 저장할 수 있으며, 자체 소비자를 가지는 여러 값들의 집합을 담을 수 없다는 문제를 해결하기위해 탄생했다.</p>\n<h3>Recoil의 특징</h3>\n<p>boiler-plate free api로 redux는 간단한 상태 한개만 처리하려고 해도 수많은 보일러 플레이트 코드가 필요하였으나 recoil은 매우 간단하게 사용할 수 있다. 즉 러닝커브가 낮다고 할 수 있다.\n또한 비동기처리를 하기 위해서 redux의 경우는 redux-thunk와 같은 비동기 처리 라이브러리에 의존했지만 recoil에는 내장되어 있다.</p>\n<h3>주요 개념</h3>\n<ol>\n<li>atoms\n<ul>\n<li>atoms는 상태의 단위이며 업데이트와 구독이 가능하다. atom이 업데이트되면 각각의 구독된 컴포넌트는 새로운 값을 받아 리렌더링 된다. atoms는 런타임 중에서도 생성될 수 있다.</li>\n</ul>\n</li>\n<li>selectors\n<ul>\n<li>atoms나 다른 selectors를 입력으로 받아들이는 순수 함수다. 상위의 atoms 또는 selectors가 업데이트되면 하위의 selector 함수도 다시 실행된다. 컴포넌트들은 selectors를 atoms처럼 구독할 수 있으며 selectors가 변경되면 컴포넌트들도 다시 렌더링된다. selectors는 상태를 기반으로 파생된 데이터를 사용하는데 이용된다. <strong>최소한의 상태 집합만 atoms에 저장하고 파생된 데이터는 selectos를 통해서 처리함으로써 불필요한 상태의 보존을 방지할 수 있다.</strong></li>\n</ul>\n</li>\n</ol>\n<h2>Context api</h2>\n<p>Context api는 react에 자체적으로 내장된 전역 상태 관리 도구이다.</p>\n<h3>언제 Context api를 사용하면 좋을까?</h3>\n<p>상태 변경이 빈번하게 일어나지 않을 때, 간단한 데이터를 전역으로 공유하고 싶을 때 사용하면 좋다. Provider의 모든 하위 컴포넌트가 렌더링이 일어나기 때문이다. 예시로 언어 설정이나, 다크 모드 변경과 같은 스타일 설정을 저장해놓는데 적합하다.</p>\n<h1>API Response 캐싱을 위한 전역 상태 관리 이용</h1>\n<p>위투디 정식 서비스를 제작할 때, 나는 API Response를 캐싱하기로 했다. 기존에는 local state,useEffect로 구현되어 있어 컴포넌트가 렌더링 될 때마다 api를 요청했다. 유저 입장에서는 이미 한번 불러온 데이터를 다시 불러오는데 불필요한 로딩 시간이 생겼고, 성능적으로도 불필요한 네트워크 요청을 하기에 좋지 않았기 때문이다.</p>\n<p>초기에 Redux를 선택했다. 하지만 Redux는 비동기 처리가 불가능하기에 redux-thunk와 같은 비동기 미들웨어를 사용해야 하였고, 하나의 api 결과값을 캐싱하는데 매우 많은 코드가 필요하였다. 또한 redux를 활용하여 캐싱할 경우 결과값이 언제까지 유효할지에 대해서도 직접 설정을 해주어야했다.</p>\n<p>이후에는 react-query라는 라이브러리를 사용했다. redux와 같은 많은 보일러플레이트 코드들이 필요없었고, 유효 시간을 정해줄 수 있어 매우 유용했다. 또한 최근에는 Suspense와 연동이 되기에 데이터를 fetch 할 동안 fallback-ui를 보여줄 수 있다. 매번 컴포넌트마다 loading 관련 분기를 만들어 처리하지 않아도 된다. 마치 try-catch 구문처럼 관심사를 분리하여 더 효율적이고 가독성 높은 코드를 만들 수 있는 것이다.</p>\n<p>recoil의 경우, 비동기 처리를 별도의 라이브러리 없이 할 수 있고 fetch 중에는 Promise를 리턴하기에 Suspense 기능도 react-query와 마찬가지로 적용할 수 있다.</p>\n<p>만일 API Response를 캐싱하기 위해서 Redux를 선택한다면, 나는 기술에 대한 올바른 선택이 아니라고 말하고 싶다. Redux는 위에서 작성했듯 상태 변경이 빈번하게 일어나고, 상태 변경이 매우 복잡할 때 사용하면 좋다. 나의 경우 웹기반 디자인 에디터를 만들 때 리덕스를 활용했는데 리덕스의 특징에 따라 상태 변경이 매우 예측가능 하였고, 상태 변경을 쉽게 추적할 수 있다는 장점이 있었다.</p>\n<p>기술의 특징과 컨셉을 파악하고, 상황에 맞게 올바른 기술을 선택한다면 개발 생산성 향상을 통해 많은 시간을 세이브 할 수 있을 것이다!</p>","id":"8ad817f0-aae0-5bb9-acda-d76f90fc3e82"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}