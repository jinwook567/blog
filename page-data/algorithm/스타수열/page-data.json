{"componentChunkName":"component---src-templates-post-template-tsx","path":"/algorithm/스타수열/","result":{"pageContext":{"node":{"fields":{"slug":"/algorithm/스타수열/"},"excerpt":"문제 링크 해결 전략 처음에 이 문제를 완전탐색 형태로 해결하고자 하였다. a의 부분 수열을 모두 만들고, 스타 수열인지 확인하는 방식으로 알고리즘을 짰다. 하지만 이 방식은, a의 길이가 최대 500,000이므로 절대 만족할 수 없다. 조합의 경우 O(2^n)의 시간 복잡도를 가지기 때문이다. 그렇다면 반대로 생각해봐야 한다. 모든 부분 수열을 만들어보고 스타 수열인지 검증하는 대신, 주어진 배열을 활용해서 직접 스타 수열을 만들어보면 된다…","frontmatter":{"date":"2022-10-13T00:00:00.000Z","description":"백트래킹","title":"스타수열"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/70130\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>처음에 이 문제를 완전탐색 형태로 해결하고자 하였다. a의 부분 수열을 모두 만들고, 스타 수열인지 확인하는 방식으로 알고리즘을 짰다. 하지만 이 방식은, a의 길이가 최대 500,000이므로 절대 만족할 수 없다. 조합의 경우 O(2^n)의 시간 복잡도를 가지기 때문이다.</p>\n<p>그렇다면 <strong>반대로 생각해봐야 한다.</strong> 모든 부분 수열을 만들어보고 스타 수열인지 검증하는 대신, 주어진 배열을 활용해서 직접 스타 수열을 만들어보면 된다!</p>\n<p>스타수열을 만들 때, 우리는 중복된 숫자가 꼭 필요하다. 따라서 중복된 숫자가 많을수록 더 길이가 긴 스타수열을 만들 수 있다. 하지만 중복된 숫자가 많다고 해서 꼭 스타수열의 길이가 긴 것은 아니기에, 중복된 숫자의 개수가 큰 순서대로 검증해나가는 백트래킹 방식을 사용하면 된다.</p>\n<p><code>[1,1,1,1,1,1,1,1,1,1,2,3,2,3,2]</code>과 같은 배열의 경우 1이 가장 많은 중복된 숫자지만, 1을 교집합으로 두었을 때 스타 수열을 만들 수 없다. 1이 연속적으로 배치되어 있어 i번쨰와 i+1번째가 같기 때문이다. 따라서 그 다음으로 중복된 개수가 많은 2를 검증해야 한다.</p>\n<p>스타 수열 조건을 만족하는 부분 수열들을 찾아나가면서 합하는 방식으로 스타 수열의 최대 길이를 구할 것이다. 최대한 길이가 긴 스타 수열을 구하기 위해서는 좌측부터 만족시키면서 나가면 된다. 그래야 우측에 남은 배열의 길이가 길어져 더 길이가 긴 부분 수열을 만들 수 있다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-js\">function solution(a) {\n  //배열 내에서, 중복된 숫자의 순서가 많은 순서대로 정렬한다.\n  const obj = {}\n  a.forEach(v => {\n    if (!obj[v]) obj[v] = 1\n    else obj[v] += 1\n  })\n\n  const sameNumberCounts = Object.entries(obj).sort((a, b) => b[1] - a[1])\n\n  //스타 수열을 만족하는 최대 부분 수열을 찾는다.\n  let answer = 0\n\n  for (let [number, cnt] of sameNumberCounts) {\n    number = Number(number)\n    if (answer > cnt) break\n\n    let len = 0\n    for (let i = 0; i &#x3C; a.length; i++) {\n      if (a[i + 1] === undefined) continue\n\n      if (a[i] === number &#x26;&#x26; a[i + 1] !== number) {\n        len += 2\n        i++\n        continue\n      }\n      //좌측부터 만족하는지 확인, 좌측부터 만족하는지 확인해야 남는 우측 길이가 김.\n\n      if (a[i] !== number &#x26;&#x26; a[i + 1] === number) {\n        len += 2\n        i++\n        continue\n      }\n      //좌측이 만족하지 않는다면 우측으로 확인\n    }\n    answer = Math.max(answer, len)\n  }\n  return answer\n}\n</code></pre>","id":"49b9c8f7-4c12-5e61-8886-048e71e5abec"},"previous":{"fields":{"slug":"/algorithm/기지국설치/"},"excerpt":"문제 링크 해결 전략 이 문제는 아이디어로 푸는 문제이다. 우리가 구하고자 하는 값은 추가적으로 설치된 기지국의 개수이다. 즉, 기지국이 어디에 설치되는지는 알 필요가 없다는 의미이다. 작은 예시를 통해서 설치해야 할 기지국 개수를 알아본다. 만일 기지국이 전혀 없는 4개의 아파트가 있다고 가정하고, 전파 도달 거리가 1이라면 몇 개의 기지국 설치가 필요할까? 1개의 기지국이 차지하는 영역은 본인의 자리 + 앞 뒤로 w 만큼이다. 즉 2*w+…","frontmatter":{"date":"2022-10-12T00:00:00.000Z","description":"투포인터","title":"기지국 설치"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/12979\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>이 문제는 아이디어로 푸는 문제이다.</p>\n<p><strong>우리가 구하고자 하는 값은 추가적으로 설치된 기지국의 개수이다.</strong> 즉, 기지국이 어디에 설치되는지는 알 필요가 없다는 의미이다.</p>\n<p>작은 예시를 통해서 설치해야 할 기지국 개수를 알아본다. 만일 기지국이 전혀 없는 4개의 아파트가 있다고 가정하고, 전파 도달 거리가 1이라면 몇 개의 기지국 설치가 필요할까?</p>\n<p>1개의 기지국이 차지하는 영역은 본인의 자리 + 앞 뒤로 w 만큼이다. 즉 <code>2*w+1</code>의 길이만큼 차지하게 된다. 위의 예시의 경우 총 2개의 기지국 설치가 필요하다. 기지국의 영역이 4를 넘어가기는 하지만, 전체 영역을 채워야 하기에 2개가 필요하다. <code>3 * 2 > 4</code></p>\n<p>문제에서는 기지국이 설치된 <code>stations</code> 배열이 주어진다. <strong>추가적으로 기지국을 설치해야 할 부분은 설치된 기지국들이 포함하지 못하는 기지국이 전혀 없는 영역이다.</strong></p>\n<p>우리는 방금 예시를 통해서 기지국이 전혀 없는 영역에서 몇개의 기지국을 설치해야 하는지 알게되었다. 그렇다면 이제 필요한 것은 기지국이 전혀 없는 영역을 구하는 것이다.</p>\n<p>기지국이 전혀 없는 영역을 구하기 위해서는 투포인터 알고리즘을 사용하면 된다.</p>\n<pre><code>before = 이전 기지국의 전파가 도달하지 않는 우측 위치.\ncurrent = 현재 기지국의 전파가 마지막으로 도달하는 좌측 위치.\n</code></pre>\n<p>또한 가장 중요한 부분은 포인터에 넣을 위치를 기지국이 마지막으로 포함하는 거리인지, 아니면 바로 못미치는 영역인지 정의해주어야 한다.</p>\n<p>나는 기지국이 처음 시작할 때의 환경을 고려하여 <code>before</code> 변수에는 기지국이 존재하지 않는 상태의 위치, <code>current</code> 변수에는 기지국이 마지막으로 포함하는 거리로 넣어주었다.</p>\n<pre><code class=\"language-js\">let current = 1\nlet before = 1\n\nlet answer = 0\nconst area = w => w * 2 + 1\n\nfor (let i = 0; i &#x3C; stations.length; i++) {\n  current = stations[i] - w\n\n  const diff = current - before\n\n  if (diff > 0) {\n    answer += Math.ceil(diff / area(w))\n  }\n\n  before = stations[i] + w + 1\n}\n</code></pre>\n<p>마지막 라인에 <code>before</code>변수를 <code>stations[i] + w + 1</code>로 초기화 시켜준 이유는 i번째 기지국이 이제 이전 기지국이 되었으며 <code>stations[i] + w + 1</code>이 전파가 도달하지 않는 우측 위치이다.</p>\n<pre><code class=\"language-js\">if (before &#x3C;= n) {\n  answer += Math.ceil((n - before + 1) / area(w))\n}\n</code></pre>\n<p>마지막으로 위의 코드가 필요하다. 왜냐면 마지막 기지국이 n까지 전파가 닿지 않는다면 해당 부분을 채워주어야 하기 때문이다. 여기서 n은 기지국이 설치되어 있지 않는 상태이기 때문에 <code>before &#x3C;=n</code>으로 작성했으며 <code>n-before+1</code>을 한 값을 <code>area(w)</code>로 나누었다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-js\">function solution(n, stations, w) {\n  let current = 1\n  let before = 1\n\n  let answer = 0\n  const area = w => w * 2 + 1\n\n  for (let i = 0; i &#x3C; stations.length; i++) {\n    current = stations[i] - w\n\n    const diff = current - before\n\n    if (diff > 0) {\n      answer += Math.ceil(diff / area(w))\n    }\n\n    before = stations[i] + w + 1\n  }\n\n  if (before &#x3C;= n) {\n    answer += Math.ceil((n - before + 1) / area(w))\n  }\n  return answer\n}\n</code></pre>","id":"64862fdb-5291-5542-a334-ce268422ecc5"},"next":{"fields":{"slug":"/etc/이펙티브타입스크립트/1장/"},"excerpt":"타입스크립트와 자바스크립트의 관계 타입스크립트는 자바스크립트의 상위 집합이다. 즉 모든 자바스크립트 프로그램은 타입스크립트 프로그램이다. 하지만 타입스크립트의 경우 타입 선언 등 별도의 문법을 가지고 있기 때문에 유효한 자바스크립트 프로그램이라고는 할 수 없다. 자바스크립트가 타입스크립트 프로그램이기에 마이그레이션 하는데 큰 이점을 가진다. 타입 시스템 타입스크립트는 자바스크립트에 타입 시스템을 더한 것이다. 타입 시스템의 목표 중 하나는 런…","frontmatter":{"date":"2022-10-17T00:00:00.000Z","description":"타입스크립트 알아보기","title":"이펙티브 타입스크립트 1장"},"html":"<h1>타입스크립트와 자바스크립트의 관계</h1>\n<p>타입스크립트는 자바스크립트의 상위 집합이다. 즉 모든 자바스크립트 프로그램은 타입스크립트 프로그램이다. 하지만 타입스크립트의 경우 타입 선언 등 별도의 문법을 가지고 있기 때문에 유효한 자바스크립트 프로그램이라고는 할 수 없다. 자바스크립트가 타입스크립트 프로그램이기에 마이그레이션 하는데 큰 이점을 가진다.</p>\n<h2>타입 시스템</h2>\n<p>타입스크립트는 자바스크립트에 타입 시스템을 더한 것이다. 타입 시스템의 목표 중 하나는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것이다. '정적'타입 시스템이라는 것은 바로 이런 특징을 말하는 것이다. 하지만 타입 체커가 모든 오류를 찾아내지는 않으니 유의해야한다.</p>\n<p>타입을 선언하지 않아도 타입스크립트는 오류는 발생시키지 않지만 의도와 다르게 동작하는 코드를 찾아내기도 한다. 하지만 정확하지 않기에 명시적으로 타입을 선언해야한다.</p>\n<pre><code class=\"language-typescript\">interface State {\n  name: string\n  capital: string\n}\n\nconst states: State[] = [\n  { name: \"Alaska\", capital: \"Juneau\" },\n  { name: \"Korea\", capitol: \"Seoul\" },\n]\n//만일 State 타입을 명시하지 않았다면, 에러를 발생시키지 않지만 State 타입을 명시함으로써 capitol 속성 부분에 에러를 표시해준다. 이는 잠재적으로 생길 수 있는 문제를 해결해준다.\n</code></pre>\n<p>타입스크립트 타입 시스템은 자바스크립트의 런타임 동작을 모델링한다.</p>\n<pre><code class=\"language-ts\">const x = 2 + \"3\"\nconst a = null + 7\nconst b = [] + 12\nalert(\"hi\", \"ts\")\n</code></pre>\n<p>변수 x의 경우 문자열 \"23\"이 되는 자바스크립트 런타임 동작으로 모델링된다. 하지만 변수 a,b, alert 함수의 경우에 자바스크립에서는 정상적으로 동작하지만 타입스크립에서는 타입 체커가 문제점을 표시한다.</p>\n<p>이러한 불명확함이 타입스크립트를 사용하는데 의문이 들 수 있지만, 타입스크립트를 사용하면 오류가 적은 프로그램을 만들 수 있다. <code>null+7</code>과 같은 코드가 당연하다고 생각된다면 타입스크립트를 안쓰는게 낫다.</p>\n<h1>타입스크립트 설정 이해하기</h1>\n<pre><code class=\"language-ts\">function sum(a, b) {\n  return a + b\n}\n</code></pre>\n<p>다음 함수가 타입스크립트에서 오류를 발생시키는지, 아닌지 알 수 있을까? 해당 프로그램의 타입스크립트 설정을 보지 않는 이상 알 수 없다. 설정은 커맨드라인에서도 사용할 수 있지만, 설정 파일을 만들어서 동료 개발자나 다른 도구들이 알 수 있도록 해야한다.</p>\n<h2>주요 설정</h2>\n<h3>noImplicitAny</h3>\n<p>noImplicitAny는 변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어한다.\n위의 <code>sum</code> 함수는 noImplicitAny가 설정되었다면 유효하지 않다. a,b가 any 타입으로 간주되기 때문이다. 되도록이면 noImplicitAny로 설정하도록 하고 새 프로젝트를 한다면 꼭 noImplicitAny로 설정하도록 한다.</p>\n<h3>strictNullChecks</h3>\n<p>null과 undefined가 모든 타입에서 허용되는지 확인하는 설정이다.</p>\n<pre><code class=\"language-ts\">const x: number = null\n</code></pre>\n<p>위의 예시는 정상이다. 하지만 strictNullChecks 설정하면 오류가 발생한다.</p>\n<pre><code class=\"language-ts\">const x: number | null = null\n</code></pre>\n<p>만일 null을 허용하려면 위와같이 명시적으로 null을 타입에 넣어주어야 한다.</p>\n<p>만일 null을 허용하지 않으려면 null을 체크하는 코드나 단언문을 추가해야한다.</p>\n<pre><code class=\"language-ts\">const el = document.getElementById(\"status\")\n//el.textContent = \"ready'; -> 개체가 null인 것 같습니다.\n\nif (el) {\n  el.textContent = \"ready\"\n}\nel!.textContent = \"ready\"\n</code></pre>\n<p>strictNullChecks 설정은 null, undefined 관련된 오류를 잡는데 큰 도움을 주지만 코드 작성을 어렵게 한다. 새 프로젝트를 시작한다면 가급적 사용을 권장하고 처음이거나 마이그레이션 중이라면 설정하지 않아도 좋다.</p>\n<h3>strict</h3>\n<p>모든 체크를 설정하고 싶다면 strict 설정을 하면 된다. 타입스크립트에 strict 설정을 하면 대부분 오류를 잡아낸다.</p>\n<h1>코드 생성과 타입이 관계없음을 이해하기</h1>\n<p>타입스크립트의 컴파일러는 두 가지 역할을 수행한다.</p>\n<ol>\n<li>최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일 한다.</li>\n<li>코드의 타입 오류를 체크한다.</li>\n</ol>\n<p>여기서 주의해야 할 점은 두 가지가 완벽히 독립적이라는 점이다. <strong>타입스크립트가 자바스크립트로 변환될 때 타입은 영향을 미치지 않는다. 타입과 관련된 코드는 전부 사라진다!</strong></p>\n<h2>독립적이기에 생기는 특징</h2>\n<h3>1. 타입 오류가 있는 코드도 컴파일 가능</h3>\n<p>타입 오류가 있어도 컴파일 된다는 것은 엉성해보이지만, 실제로는 도움이 되는 경우가 있다. 애플리케이션에서 어떤 부분이 오류가 발생했다고 했을 때, 컴파일이 가능하기에 다른 부분에 대한 테스트가 가능하다.</p>\n<p>만일 오류가 있을 때 컴파일 하지 않으려면 noEmitOnError를 설정하면 된다.</p>\n<h3>2. 런타임에는 타입 체크가 불가능하다.</h3>\n<p>만일 어떤 코드에서 <code>instanceof</code>와 타입을 사용하여 분기를 만든다면, 런타임 환경에서 타입은 사라지기에 전혀 유효하지 않다. 런타임에 타입 정보를 유지하는 방법으로는 3가지가 있다.</p>\n<ol>\n<li>\n<p>속성이 존재하는지 체크 - 속성 체크는 런타임에 접근 가능한 값에만 관련되지만, 타입 체커 역시 보정해주기 때문에 오류가 사라진다.</p>\n</li>\n<li>\n<p>타입 정보를 명시적으로 저장하는 태그 기법</p>\n<pre><code class=\"language-ts\">interface Square {\n  kind: \"square\"\n  width: number\n}\n\ninterface Rectangle {\n  kind: \"rectangle\"\n  width: number\n  height: number\n}\n</code></pre>\n<p>kind 속성을 추가해서, 명시해준다. 타입스크립트에서 흔하게 볼 수 있는 패턴이다.</p>\n</li>\n<li>\n<p>타입을 클래스로 만든다.</p>\n<pre><code class=\"language-ts\">class Square {\n  constructor(public width: number) {}\n}\nclass Rectangle extends Square {\n  constructor(public width: number, public height: number) {\n    super(width)\n  }\n}\ntype Shape = Square | Rectangle\n\nfunction calculateArea(shape: Shape) {\n  if (shape instanceof Rectangle) {\n    //...\n  }\n}\n</code></pre>\n<p><code>type Shape = Square | Rectangle</code> 부분에서 Rectangle은 타입으로 참조되지만, <code>shape instanceof Rectangle</code> 부분에서는 값으로 참조되어 분기가 가능한 것이다.</p>\n</li>\n</ol>\n<h3>3. 타입 연산은 런타임에 영향을 주지 않는다.</h3>\n<p>타입이 사라지기 때문에 당연히 타입 연산도 런타임에 어떠한 영향을 주지 않는다.</p>\n<pre><code class=\"language-ts\">function asNumber(val: number | string): number {\n  return val as number\n}\n</code></pre>\n<pre><code class=\"language-js\">function asNumber(val) {\n  return val\n}\n</code></pre>\n<p>위의 코드는 아래와 같이 컴파일 되기 때문에 해당 인수가 해당 함수를 통과하더라도 그대로이다. 즉 어떠한 영향도 받지 않는다.</p>\n<h3>4. 런타임 타입은 선언된 타입과 다를 수 있다.</h3>\n<p>만약 API값을 수신할 때, API값을 잘못 파악하고 타입을 입력해놨다면 런타임 타입과 선언된 타입이 다르다.</p>\n<h3>5. 함수 오버로드 할 수 없다.</h3>\n<p>타입스크립트가 함수 오버로딩 기능을 지원하기는 하지만, 실제 컴파일 되어있을 때 선언문을 여러개 작성하더라도 구현체는 오직 하나뿐이다. 자바스크립트에서 함수 선언문으로 작성할 경우, 함수명이 동일하면 맨 마지막 함수로 덮어써진다. 이는 자바스크립트의 특징이다.</p>\n<h1>구조적 타이핑 익숙해지기</h1>\n<p>자바스크립트는 덕 타이핑 기반이다.</p>\n<p><em>덕 타이핑이란, 객체가 어떤 타입에 부합하는 변수와 메소드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주한다. 독수리가 오리처럼 걷고, 헤엄치고, 꽥꽥거린다면 독수리는 오리라고 할 수 있다.</em></p>\n<pre><code class=\"language-ts\">function calculateLength(v: { a: number; b: number }) {\n  return v.a + v.b\n}\n\nconst v1 = { a: 1, b: 2, c: 3 }\ncalculateLength(v1) //3\n</code></pre>\n<p>calculateLength의 매개변수 v는 a,b의 속성만 가지지만 c의 속성도 가지고 있는 v1을 해당 함수에 넣어도 문제로 인식하지 않는다. 구조적 관점에서 a,b가 있기 때문에 호환되기 때문이다.</p>\n<p>함수를 작성할 때 호출에 사용되는 매개변수의 속성들이 매개변수의 타입에 선언된 속성만을 가질거라 생각하기 쉽다. 이러한 타입은 봉인된 또는 정확한 타입이라고 불리며 타입스크립트 타입 시스템에서는 표현할 수 없다. 좋든 싫든 타입은 열려있다. 이러한 특성때문에 발생하는 오류는 아래와 같다.</p>\n<pre><code class=\"language-ts\">let sum: number = 0\nfor (let p of Object.keys(v1)) {\n  const num = v1[p]\n  //string은 v1의 인덱스로 사용할 수 없다.\n  sum += num\n}\nreturn sum\n</code></pre>\n<p>Object.keys(v1)을 호출하면 도출되는 배열은 무조건 객체의 속성 중 하나이지만, 타입은 확장될 수 있기 때문에 Object.keys(v1)의 타입은 string[]가 될 수도 있다. 즉 v1이 <code>{a:1,b:2,c:3, d: \"this is string\"}</code>이라면 NaN을 반환한다.\n이럴 경우에 루프보다는, 모든 속성을 각각 더하는 구현이 더 간결하다.</p>\n<p>정확한 타입으로 객체를 순회하는 방법은 추후에 다루도록 하겠다.</p>\n<p>클래스 역시 구조적 타이핑을 따른다. 클래스의 인스턴스가 예상과 다를 수 있음을 유의해야한다.</p>\n<h2>구조적 타이핑의 장점</h2>\n<p>구조적 타이핑은 테스트하는데 유리하다. 함수를 테스트하기 위해서는 모킹한 객체를 생성해야 하는데, 테스트에 필요한 객체의 속성만 작성해주면 되기 때문이다.</p>\n<h1>any 타입 지양하기</h1>\n<p>any의 위험성..</p>\n<h2>any 타입에는 타입 안정성이 없다.</h2>\n<pre><code class=\"language-ts\">let age: number = 10\nconst one = \"1\" as any\nage += one\n//age \"101:\n</code></pre>\n<p>age는 number 타입이지만, any를 설정함으로써 string 타입을 할당할 수 있게 된다. 런타임에서 age는 string이다..</p>\n<h2>함수 시그니처를 무시해버린다.</h2>\n<p>함수를 작성할 때는 시그니처를 명시해야 한다. 호출하는 쪽은 약속된 타입의 입력을 제공하고, 함수는 약속된 타입의 출력을 반환한다. any는 이런 약속을 무시해버릴 수 있다.</p>\n<pre><code class=\"language-ts\">function sum(a: number, b: number): number {\n  return a + b\n}\n\nconst a = \"3\" as number\nconst b = 5\nsum(a, b) //정상적으로 작동함.\n</code></pre>\n<h2>언어 서비스가 적용되지 않는다.</h2>\n<p>자동완성 기능 제공하지 않는다. 또한 Rename Symbol 기능을 사용하면 프로그램 내 모든 속성의 이름을 변경해주지만 any 타입이라면 적용되지 않는다.</p>\n<h2>타입 설계를 감춘다.</h2>\n<p>상태 객체의 설계를 감추기 때문에, 설계가 어떻게 되어있는지 전혀 알 수 없다. 내가 아닌 다른 사람이 코드를 본다면 파악하기 위해 코드를 재구성 해봐야 한다.</p>\n<h2>신뢰도를 떨어트린다.</h2>\n<p>런타임 오류가 더 자주 발생한다. 또한 타입 오류를 고쳐야하고 머릿속에 실제 타입을 기억해야 하기 때문에 번거롭다.</p>","id":"d3c8cc37-7a91-5de3-a427-6039f4eca882"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}