{"componentChunkName":"component---src-templates-post-template-tsx","path":"/algorithm/표현가능한이진트리/","result":{"pageContext":{"node":{"fields":{"slug":"/algorithm/표현가능한이진트리/"},"excerpt":"문제 링크 해결 전략 문제에 접근법은 처음에 구상한 게 맞았으나, 구현에서 조금 애를 먹었다. 알고리즘 풀 때는 타입스크립트가 아닌 자바스크립트를 사용해서 그런가 자잘한 타이핑 오류가 있었다. 우리에게는 십진수가 주어진다. 완전이진트리를 사용하여 이진법을 제작했을 때, 해당 십진수를 이진법으로 표현할 수 있는지 문제이다. 우리가 해결해야 할 문제는 이진법으로 표현할 수 있는지, 즉 완전이진트리모양을 만족시킬 수 있는지이다. 부모 노드 아래 더…","frontmatter":{"date":"2023-03-11T00:00:00.000Z","description":"재귀, 구현","title":"표현 가능한 이진트리"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/150367\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>문제에 접근법은 처음에 구상한 게 맞았으나, 구현에서 조금 애를 먹었다. 알고리즘 풀 때는 타입스크립트가 아닌 자바스크립트를 사용해서 그런가 자잘한 타이핑 오류가 있었다.</p>\n<p>우리에게는 십진수가 주어진다. 완전이진트리를 사용하여 이진법을 제작했을 때, 해당 십진수를 이진법으로 표현할 수 있는지 문제이다.</p>\n<p>우리가 해결해야 할 문제는 이진법으로 표현할 수 있는지, 즉 완전이진트리모양을 만족시킬 수 있는지이다.<br>\n부모 노드 아래 더미 노드를 완전이진트리 모양을 만족시키면서 자유롭게 추가할 수 있지만, 부모 노드가 더미 노드라면 자식 노드로 더미 노드가 아닌 노드를 추가할 수 없다.</p>\n<ol>\n<li>\n<p>우선 십진수를 이진법으로 변환한다. 이진법은 뒤가 아닌 앞에 0을 추가하면 값은 그대로이므로, 만약 이진법이 완전이진트리의 모양을 충족시키지 않는다면 해당 모양을 충족시키도록 앞쪽에 0을 삽입해준다. 모양을 충족시킨 이후에 0을 더 삽입하여 완전이진트리 모양을 또 만들수는 있으나, 이 경우 루트 노드가 무조건 0이 되기 때문에 고려하지 않아도 된다.</p>\n</li>\n<li>\n<p>완전이진트리에서 루트 노드, 왼쪽 자식 노드, 오른쪽 자식 노드를 구하는 알고리즘을 작성한다. 루트 노드의 경우 배열의 중앙값이고, 왼쪽 자식 노드의 경우는 왼쪽 자식 노드 본인의 자식 노드의 개수만큼 빼주고 또 1을 빼준다. 위 방식이 가능한 이유는 다음과 같은 가정이 있어서이다.</p>\n<p><em>이진트리에서 리프 노드가 아닌 노드는 자신의 왼쪽 자식이 루트인 서브트리의 노드들보다 오른쪽에 있으며, 자신의 오른쪽 자식이 루트인 서브트리의 노드들보다 왼쪽에 있다고 가정합니다.</em></p>\n<p>오른쪽 자식 노드의 경우는 오른쪽 자식 노드 본인의 자식 노드의 개수만큼 더해주고 또 1을 더해준다.</p>\n<p>자식 노드를 구하는 다른 방식은, 루트 노드를 구하는 방식을 활용하는 것이다. 완전이진트리는 트리의 일부분을 떼어내도 완전이진트리 모양이다. 따라서 왼쪽 자식노드를 구한다고 가정하면 자신의 왼쪽 노드를 기준으로 트리를 뜯어내고, 해당 트리의 루트를 찾으면 왼쪽 노드를 구할 수 있다.</p>\n</li>\n<li>\n<p>재귀를 활용하여 루트를 기점으로 완전이진트리를 순회한다. 순회하면서 위에서 언급한 완전이진트리 모양을 만족시킬 수 있는 조건을 검사한다. 만일 만족시킬 수 없다면 재귀를 멈추고 0을 반환한다. 완전 이진트리를 만족시킨다면 1을 반환한다.</p>\n</li>\n</ol>\n<h1>정답 코드</h1>\n<pre><code class=\"language-js\">function solution(numbers) {\n  return numbers.map(number => {\n    const binary = number.toString(2);\n\n    const floor = getFloor(binary.length);\n    const treeBinary = makeTreeBinary(binary, getNodeCount(floor));\n\n    const rootIndex = getRootIndex(treeBinary);\n\n    let flag = true;\n    function validate(binary, floor, index) {\n      if (floor === 1) return; // 1층일 때 순회를 종료한다. 리프 노드를 검증할 필요가 없다.\n\n      const leftChildIndex = index - getNodeCount(floor - 2) - 1;\n      const rightChildIndex = index + getNodeCount(floor - 2) + 1;\n\n      if (\n        binary.charAt(index) === '0' &#x26;&#x26;\n        (binary.charAt(leftChildIndex) === '1' ||\n          binary.charAt(rightChildIndex) === '1')\n      ) {\n        flag = false;\n        return;\n      }\n\n      validate(binary, floor - 1, leftChildIndex);\n      validate(binary, floor - 1, rightChildIndex);\n    }\n\n    validate(treeBinary, floor, rootIndex);\n    return flag ? 1 : 0;\n  });\n}\n\nfunction makeTreeBinary(binary, count) {\n  let result = binary;\n  for (let i = 0; i &#x3C; count - binary.length; i++) {\n    result = '0' + result;\n  }\n  return result;\n}\n\nfunction getRootIndex(binary) {\n  return Math.floor(binary.length / 2);\n}\n\nfunction getFloor(nodeCount) {\n  return nodeCount.toString(2).length;\n}\n\nfunction getNodeCount(floor) {\n  if (floor === 0) return 0;\n  let byte = '';\n  for (let i = 0; i &#x3C; floor; i++) {\n    byte += '1';\n  }\n  return parseInt(byte, 2);\n}\n</code></pre>\n<p>코드가 조금 장황하다.</p>","id":"c9d97b10-330d-5938-99fe-95e0d763cc71"},"previous":{"fields":{"slug":"/algorithm/미로탈출명령어/"},"excerpt":"문제 링크 간만에 알고리즘을 푼다. 알고리즘은 역시 재밌는 것 같다. 카카오 문제를 풀어봤는데, 그렇게 어렵지는 않았다. 작년 하반기에 카카오 공채를 응시하지 못한 것이 매우 아쉬울 따름이다. 판단 기준이 없어서 잘못된 선택을 내렸다. 반면교사하여 다시는 잘못된 선택을 하지 않으면 된다. 해결 전략 격자 미로에서 출발지와 도착지를 가는 길 중 문자열이 사전 순서에서 가장 작은 길을 구해야한다. 격자 미로: 격자 미로일 경우 우리는 어느 한 지…","frontmatter":{"date":"2023-03-10T00:00:00.000Z","description":"그리디","title":"미로탈출명령어"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/150365\">문제 링크</a></p>\n<p>간만에 알고리즘을 푼다. 알고리즘은 역시 재밌는 것 같다.<br>\n카카오 문제를 풀어봤는데, 그렇게 어렵지는 않았다. 작년 하반기에 카카오 공채를 응시하지 못한 것이 매우 아쉬울 따름이다. 판단 기준이 없어서 잘못된 선택을 내렸다. 반면교사하여 다시는 잘못된 선택을 하지 않으면 된다.</p>\n<h1>해결 전략</h1>\n<p>격자 미로에서 출발지와 도착지를 가는 길 중 문자열이 사전 순서에서 가장 작은 길을 구해야한다.</p>\n<ol>\n<li>\n<p>격자 미로: 격자 미로일 경우 우리는 어느 한 지점에서, 다른 지점까지의 최단 거리를 매우 쉽게 알 수 있다. 예시로 (a1,b1), (a2,b2) 두 좌표일 때 최단 거리는 |a1-a2|+|b1-b2| 이다.</p>\n</li>\n<li>\n<p>사전 순서에서 가장 작은 길: 방향을 문자열로 치환하였을 때, 사전 순으로 나열하면 d, l, r, u이다. 단어를 사전 순으로 정렬했을 때 앞에 위치하려면, 단어 내 앞에 있는 문자가 최대한 사전순으로 정렬되어야 한다. 그 의미는 drrr이 rddd 보다 사전 앞에 위치한다. 단어 내 앞에 배치된 문자가 중요도가 훨씬 높다는 의미이다.</p>\n</li>\n<li>\n<p>k번: 우리는 k번 움직일 수 있다. 왔던 길을 다시 돌아갈 수도 있다. 다시 말하면 우리는 이동한 지점으로부터 도착지까지 남은 k번 내에 도달할 수 있다면 어디를 가던 상관이 없다.</p>\n</li>\n</ol>\n<p>2번 항목에서 그리디 알고리즘을 떠올리게 되었고,\n내가 고안한 알고리즘은 다음과 같다.</p>\n<ol>\n<li>우리는 k번 만큼 움직인다. 방향의 우선 순위는 방향을 문자열로 치환했을 때의 사전 순서이다. (d,l,r,u)</li>\n<li>d,l,r,u 순서대로 순회하며 다음의 이동 지점을 구해본다.</li>\n<li>만일 다음의 이동 지점에서 도착지까지 도달할 수 없다면, 다음 순회로 넘어간다. (남은 k가 모자라는 경우)</li>\n<li>만일 다음의 이동 지점에서 도착지까지 도달할 수 있다면 k를 1개 줄여주고, 해당 방향을 기록해준다. 2번의 순회를 멈춘다.</li>\n<li>이 과정을 k가 0이 될 때 까지 반복한다.</li>\n<li>k가 0이 되었을 때 도착한 지점이 목적지와 다르다면 'impossible'을 출력한다. 그게 아니라면 기록한 방향을 출력해준다.</li>\n</ol>\n<h1>정답 코드</h1>\n<pre><code class=\"language-js\">function solution(n, m, x, y, r, c, k) {\n  const direction = ['d', 'l', 'r', 'u'];\n  const dx = [0, -1, 1, 0];\n  const dy = [1, 0, 0, -1];\n\n  let answer = '';\n\n  const start = [x - 1, y - 1];\n  const end = [r - 1, c - 1];\n\n  while (k > 0) {\n    for (let i = 0; i &#x3C; 4; i++) {\n      const next = [start[0] + dy[i], start[1] + dx[i]];\n      if (check(next, n, m)) {\n        if (getDistance(next, end) &#x3C;= k) {\n          k -= 1;\n          start[0] = next[0];\n          start[1] = next[1];\n          answer += direction[i];\n          break;\n        }\n      }\n      if (i === 3) return 'impossible'; // 아래 설명 참조\n    }\n  }\n  if (start[0] !== end[0] || start[1] !== end[1]) return 'impossible';\n  return answer;\n}\n\nfunction getDistance(pos1, pos2) {\n  const [y1, x1] = pos1;\n  const [y2, x2] = pos2;\n  return Math.abs(x2 - x1) + Math.abs(y2 - y1);\n}\n\nfunction check(pos, n, m) {\n  const [pos_y, pos_x] = pos;\n  return pos_y >= 0 &#x26;&#x26; pos_y &#x3C;= n - 1 &#x26;&#x26; pos_x >= 0 &#x26;&#x26; pos_x &#x3C;= m - 1;\n}\n</code></pre>\n<p>for 문내에 <code>if (i === 3) return 'impossible'</code> 이라는 코드를 삽입한 이유는 모든 방향으로 가봤을 때 도달할 수 있는 경우가 없다면 불가능한 경우이기 때문에 루프를 종료시킨다. 루프를 종료시키지 않으면 k가 줄지 않기 때문에 while문을 벗어날 수 없다.</p>","id":"c95bf2f7-a8b0-51a8-8b8e-c9fb5cf894c7"},"next":{"fields":{"slug":"/programming/인덱스시그니처/"},"excerpt":"다음과 같이 인덱스 시그니처가 정의되어 있는 타입이 있다. TypeWithIndexSignature에서 c라는 속성을 제거하고 싶어 Omit 유틸리티를 사용했을 때 원하는 타입을 얻을 수 있을까? 내가 원하는 타입의 형태는 아래와 같다. 하지만 아래와 같이 엉뚱한 타입을 얻게된다. 왜 그럴까? 이유를 알기 위해서는 Omit 유틸리티에 사용되는 Exclude 유틸리티와, Omit 유틸리티 타입에 대해서 이해해야 한다. Exclude 타입에 대해…","frontmatter":{"date":"2023-03-15T00:00:00.000Z","description":"인덱스 시그니처, Exclude, Omit 타입 유틸리티에 대한 이해","title":"인덱스 시그니처가 정의된 타입에서 Omit 유틸리티 타입을 사용하면?"},"html":"<p>다음과 같이 인덱스 시그니처가 정의되어 있는 타입이 있다.</p>\n<pre><code class=\"language-ts\">type TypeWithIndexSignature = {\n  a: number;\n  b: number;\n  c: number;\n  [index: string]: number;\n};\n\ntype Omitted = Omit&#x3C;TypeWithIndexSignature, 'c'>;\n</code></pre>\n<p><code>TypeWithIndexSignature</code>에서 c라는 속성을 제거하고 싶어 Omit 유틸리티를 사용했을 때 원하는 타입을 얻을 수 있을까?</p>\n<p>내가 원하는 타입의 형태는 아래와 같다.</p>\n<pre><code class=\"language-ts\">type Omitted = {\n  a: number;\n  b: number;\n  [index: string]: number;\n};\n</code></pre>\n<p>하지만 아래와 같이 엉뚱한 타입을 얻게된다.</p>\n<pre><code class=\"language-ts\">type Omitted = {\n  [x: string]: number;\n  [x: number]: number;\n};\n</code></pre>\n<p>왜 그럴까? 이유를 알기 위해서는 Omit 유틸리티에 사용되는 Exclude 유틸리티와, Omit 유틸리티 타입에 대해서 이해해야 한다.</p>\n<p>Exclude 타입에 대해서 먼저 이해해보자.</p>\n<pre><code class=\"language-ts\">type Exclude&#x3C;T, U> = T extends U ? never : T;\n</code></pre>\n<p>Exclude는 조건부 타입으로 이루어져있다. T가 U에 할당 가능하다면, (T가 U보다 작은 범위라면) never, 아니라면 T를 반환한다. 근데 분산 조건부 타입이라는 것이 있는데 T에 유니온 태그가 할당되었고 naked type parameter라면, 모든 유니온에 대해서 조건부 타입에 대한 검증을 수행하여 타입을 반환한다.</p>\n<pre><code class=\"language-ts\">type Excluded = Exclude&#x3C;'monkey' | 'lion' | 'tiger', 'lion'>;\ntype Excluded =\n  | Exclude&#x3C;'monkey', 'lion'>\n  | Exclude&#x3C;'lion', 'lion'>\n  | Exclude&#x3C;'tiger', 'lion'>;\ntype Excluded = 'monkey' | never | 'tiger';\ntype Excluded = 'monkey' | 'tiger';\n</code></pre>\n<p>never 타입이 유니온 타입에 존재하는 것은 의미가 전혀 없기에 타입스크립트에서 해당 타입을 제거한다.</p>\n<p>Omit 타입에 대해서 이해해보자.</p>\n<pre><code class=\"language-ts\">type Omit&#x3C;T, K extends string | number | symbol> = {\n  [P in Exclude&#x3C;keyof T, K>]: T[P];\n};\n</code></pre>\n<p>Mapped Type에 대한 이해가 선행되어야 한다.\nMapped Type은 다른 타입을 바탕으로 새로운 타입을 생성할 수 있다.\nMapped Type을 활용하여 Alphabet 타입의 속성을 가지되, 속성의 타입이 모두 <code>string | number</code>인 타입을 생성해보도록 하겠다.</p>\n<pre><code class=\"language-ts\">type Alphabet = {\n  a: string;\n  b: string;\n  c: string;\n};\n\ntype Mapped = {\n  [P in keyof Alphabet]: string | number;\n};\n\ntype Mapped = {\n  a: string | number;\n  b: string | number;\n  c: string | number;\n};\n</code></pre>\n<p>Mapped Type은 키를 통해 타입을 순회하며 타입을 생성한다. <code>TypeWithIndexSignature</code>의 key 타입을 구해보자.</p>\n<pre><code class=\"language-ts\">type Key = keyof TypeWithIndexSignature;\ntype Key = 'a' | 'b' | 'c' | string | number;\ntype Key = string | number;\n</code></pre>\n<p><code>'a' | 'b' | 'c'</code>는 string이라는 타입에 포함되기 때문에 string으로 합쳐진다. 그런데 number라는 타입은 왜 갑자기 생긴걸까?</p>\n<pre><code class=\"language-ts\">type Obj = {\n  '1': string;\n  '2': string;\n};\n\nconst obj: Obj = {\n  '1': '1',\n  '2': '2',\n};\n\nobj['1']; // '1'\nobj[1]; // '1'\n</code></pre>\n<p>javascript에서 객체의 속성에 접근할 때 숫자라면 암묵적으로 문자로 형변환이 일어난다. 이는 타입스크립트에서도 동일하게 동작한다. 따라서 인덱스 시그니처에 키의 타입으로 <code>string</code>이 할당되었다면 사실은 <code>string | number</code>인 것이다.</p>\n<pre><code class=\"language-ts\">type IndexSignature = {\n  [key: string]: number;\n};\ntype IndexSignature = {\n  [key: string | number]: number;\n};\n</code></pre>\n<p>Omit 타입 유틸리티의 도출 과정을 정리해보면 아래와 같다.</p>\n<pre><code class=\"language-ts\">type TypeWithIndexSignature = {\n  a: number;\n  b: number;\n  c: number;\n  [index: string | number]: number;\n};\n\ntype Key = string | number;\ntype Excluded = Exclude&#x3C;Key, 'c'>;\n// string은 c에 할당될 수 없기에 string, number 또한 c에 할당될 수 없기에 number\ntype Excluded = string | number;\n\ntype Omitted = {\n  [P in string | number]: TypeWithIndexSignature[P];\n};\n\ntype Omitted = {\n  [x: string]: number;\n  [x: number]: number;\n};\n</code></pre>\n<p>라이브러리에서 제공하는 타입을 제어하기 위해서 Omit 유틸리티를 사용했는데, 너무 엉뚱한 타입이 나와서 혼란스러웠다. 해당 타입에 인덱스 시그니처가 정의되었다는 사실을 몰랐다. Omit 유틸리티에 대해서 분석해본 결과 인덱스 시그니처가 정의되어 생기는 문제였음을 알게되었고 상속이 중첩된 구조인 라이브러리의 타입을 타고 타고 가다보니, 인덱스 시그니처가 정의되어 있는 것을 확인할 수 있었다.</p>\n<p>다음과 같은 제너릭 타입을 정의하여 인덱스 시그니처를 제거한 이후에 Omit 유틸리티를 사용하여 특정 속성을 제거하고, 다시 인덱스 시그니처를 정의해주어 라이브러리 타입과 유사하게 만들어주었다.</p>\n<pre><code class=\"language-ts\">export type RemoveIndex&#x3C;T> = {\n  [K in keyof T as string extends K\n    ? never\n    : number extends K\n    ? never\n    : K]: T[K];\n};\n</code></pre>","id":"33979aad-a6f4-5480-b6f7-2a0a5143a06b"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}