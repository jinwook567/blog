{"componentChunkName":"component---src-templates-post-template-tsx","path":"/algorithm/스티커모으기/","result":{"pageContext":{"node":{"fields":{"slug":"/algorithm/스티커모으기/"},"excerpt":"문제 링크 다이나믹 프로그래밍인 이유 문제의 해결 전략이 다이나믹 프로그래밍으로 도출되어야 하는 이유는 2가지이다. 시간 복잡도를 줄여야 한다. 작은 문제의 해답이 그것을 포함하는 큰 문제에서도 동일하다. 1. 시간 복잡도 스티커의 최대 길이는 100,000개이다. 만일 완전 탐색으로 어떤 스티커를 뜯었는지, 안뜯었는지 고려하여 구한다면 시간 복잡도는 최대 O(2^50000)으로 불가능하다. 2. 작은 문제의 해답이.. 스티커 전체 배열이 […","frontmatter":{"date":"2022-09-30T00:00:00.000Z","description":"다이나믹 프로그래밍","title":"스티커 모으기"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/12971\">문제 링크</a></p>\n<h1>다이나믹 프로그래밍인 이유</h1>\n<p>문제의 해결 전략이 다이나믹 프로그래밍으로 도출되어야 하는 이유는 2가지이다.</p>\n<ol>\n<li>시간 복잡도를 줄여야 한다.</li>\n<li>작은 문제의 해답이 그것을 포함하는 큰 문제에서도 동일하다.</li>\n</ol>\n<h3>1. 시간 복잡도</h3>\n<p>스티커의 최대 길이는 100,000개이다. 만일 완전 탐색으로 어떤 스티커를 뜯었는지, 안뜯었는지 고려하여 구한다면 시간 복잡도는 최대 O(2^50000)으로 불가능하다.</p>\n<h3>2. 작은 문제의 해답이..</h3>\n<p>스티커 전체 배열이 <code>[1,3,5,6,4]</code>라고 가정해보자. 부분 배열 <code>[1,3,5]</code>가 있다고 하였을 때, 뽑을 수 있는 가장 최댓값인 5이다. 부분 배열 <code>[1,3,5,6]</code>에서 <code>[1,3,5]</code>의 최댓값은 5로 만족한다. 하지만 5를 뽑는 경우 6을 뽑을 수 없다. 따라서 이 부분 배열의 경우 3과 6을 뽑아야 최댓값이다. 3의 경우는 부분 배열 <code>[1,3]</code>의 최댓값이라고 할 수 있다. 현재에 해당되는 스티커를 뗀다면, 2번 째 전 부분 배열의 최댓값과 현재의 스티커 점수를 더한 것이고 떼지 않는다면 1번 째 전 부분 배열의 최댓값과 동일하다.</p>\n<h1>해결 전략</h1>\n<p>다이나믹 프로그래밍이라는 사실도 알아냈고 규칙도 찾았으니 점화식을 세워보도록 한다.</p>\n<pre><code>d[i] = max(d[i-2]+i번째 스티커점수, d[i-1])\n(단, d[i]는 부분 배열 i까지의 최댓값을 의미한다.)\n</code></pre>\n<p>하지만 위 점화식은 맨 처음 스티커를 떼는 경우를 만족시키지 못한다. 맨 처음 스티커를 떼는 경우 맨 마지막 스티커도 제거 되어야 하기 때문이다. 따라서 맨 처음 스티커를 떼는 경우, 맨 처음 스티커를 떼지 않는 경우 2가지로 나눠서 문제를 풀어보도록 한다.</p>\n<pre><code class=\"language-javascript\">if (sticker.length &#x3C;= 2) return Math.max(...sticker)\n</code></pre>\n<p>만일 스티커의 개수가 2개 이하라면, 배열 내의 최댓값을 리턴하면 된다. 맨 처음 스티커를 떼지 않는 경우를 고려할 때 스티커 배열의 3번째 요소에 접근하기 때문에 위와 같이 처리해준다.</p>\n<pre><code class=\"language-javascript\">const len = sticker.length\nconst d = Array(len - 1).fill(0)\n\nd[0] = sticker[0]\nd[1] = d[0]\nfor (let i = 2; i &#x3C; d.length; i++) {\n  d[i] = Math.max(d[i - 2] + sticker[i], d[i - 1])\n}\n\nconst max_first = Math.max(...d)\n</code></pre>\n<p>첫 번째 스티커를 뜯어냈을 경우 코드는 위와 같다. <code>d[1] = d[0]</code>인 이유는 <code>d[1]</code>의 경우 스티커를 뜯어낼 수 없기 떄문에 <code>d[0]</code>의 값과 동일하게 넣어주어야 한다.</p>\n<pre><code class=\"language-javascript\">const d2 = Array(len - 1).fill(0)\nd2[0] = sticker[1]\nd2[1] = Math.max(d2[0], sticker[2])\n\nfor (let i = 2; i &#x3C; d.length; i++) {\n  d2[i] = Math.max(d2[i - 2] + sticker[i + 1], d2[i - 1])\n}\nconst max_second = Math.max(...d2)\n\nreturn Math.max(max_first, max_second)\n</code></pre>\n<p>첫 번째 스티커를 뜯어내지 않았을 경우 코드는 위와 같다. 첫 번째 스티커를 뜯지 않았기 때문에(제외시켰기 떄문에) 테이블은 스티커의 첫 번째 요소에서부터 시작하도록 한다. 그리고 <code>d2[1]</code>의 경우 만일 <code>sticker[2]</code>의 크기가 <code>d2[0]</code>의 크기보다 크다면, <code>sticker[2]</code>를 뜯는게 더 값이 크기 때문에 둘 중 큰 값을 가지도록 한다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-javascript\">function solution(sticker) {\n  if (sticker.length &#x3C;= 2) return Math.max(...sticker)\n\n  const len = sticker.length\n  const d = Array(len - 1).fill(0)\n\n  d[0] = sticker[0]\n  d[1] = d[0]\n  for (let i = 2; i &#x3C; d.length; i++) {\n    d[i] = Math.max(d[i - 2] + sticker[i], d[i - 1])\n  }\n  const max_first = Math.max(...d)\n\n  const d2 = Array(len - 1).fill(0)\n  d2[0] = sticker[1]\n  d2[1] = Math.max(d2[0], sticker[2])\n\n  for (let i = 2; i &#x3C; d.length; i++) {\n    d2[i] = Math.max(d2[i - 2] + sticker[i + 1], d2[i - 1])\n  }\n  const max_second = Math.max(...d2)\n\n  return Math.max(max_first, max_second)\n}\n</code></pre>","id":"22a5aab2-66b9-5717-bdb8-1e8b06438abb"},"previous":null,"next":{"fields":{"slug":"/algorithm/야근지수/"},"excerpt":"문제 링크 해결 전략 초기에는 완전 탐색으로 접근해보았다. 하지만 n을 works에 분배하는 과정에서 무조건 시간 초과가 발생할 수 밖에 없다. 따라서 문제의 특성을 이용한 다른 접근 방법이 필요하다.\n우리는 배열 내 요소의 제곱의 합의 최솟값을 구해야한다. 제곱의 그래프는 우측으로 이동할수록 급격히 증가하는 그래프 형태를 띄게 된다. 반대로 말하자면 좌측으로 이동할수록 급격히 감소한다는 의미이다. 우리는 최솟값을 구해야 하므로 감소하는 폭을…","frontmatter":{"date":"2022-10-04T00:00:00.000Z","description":"최대힙","title":"야근지수"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/12927\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>초기에는 완전 탐색으로 접근해보았다. 하지만 n을 works에 분배하는 과정에서 무조건 시간 초과가 발생할 수 밖에 없다.</p>\n<p>따라서 문제의 특성을 이용한 다른 접근 방법이 필요하다.\n우리는 배열 내 요소의 제곱의 합의 최솟값을 구해야한다. 제곱의 그래프는 우측으로 이동할수록 급격히 증가하는 그래프 형태를 띄게 된다.</p>\n<p>반대로 말하자면 좌측으로 이동할수록 급격히 감소한다는 의미이다. 우리는 최솟값을 구해야 하므로 감소하는 폭을 최대한 크게 만들어야 한다. 감소하는 폭을 최대한 크게 만들기 위해서는 배열 내에서 가장 큰 요소를 뽑아서 줄여주는 전략을 택하면 된다. 가장 큰 요소를 어떻게 줄여주느냐가 시간 복잡도에 큰 영향을 미친다.</p>\n<p>내가 작성한 초기 알고리즘은 최댓값을 구하고, 최댓값보다 바로 작은 숫자만큼 빼주는 방식이였다. 하지만 이렇게 작성할 경우 배열 내 모든 원소가 최댓값과 같은 경우를 고려해줘야 하기 때문에 알고리즘이 복잡해진다.</p>\n<p>최댓값을 구하고 최댓값과 n을 1씩 빼는 알고리즘을 사용한다면 간결하게 정답을 구할 수 있다. 하지만 n이 1,000,000이고 works 배열의 길이는 20,000이기 때문에 배열을 순회하면서 최댓값을 찾는 방식을 사용한다면 1,000,000 * 20,000 으로 시간 복잡도를 초과하게 된다. 최댓값을 구할 때 우리는 최대힙을 사용한다면 log(20,000) 시간으로 최댓값을 구할 수 있고 시간 복잡도를 초과하지 않게 된다.</p>\n<h1>교훈</h1>\n<p>시간 복잡도를 기반으로 방법을 생각해내는 것도 좋지만, 문제의 특성에 따라 방법을 생각하고 시간 복잡도를 줄이는 방안도 생각해봐야 한다. (이진탐색, 우선순위 큐 등)</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-javascript\">class MaxHeap {\n  constructor() {\n    this.heap = []\n  }\n\n  swap(aIndex, bIndex) {\n    ;[this.heap[aIndex], this.heap[bIndex]] = [\n      this.heap[bIndex],\n      this.heap[aIndex],\n    ]\n  }\n\n  push(value) {\n    this.heap.push(value)\n    let currentIndex = this.heap.length - 1\n    let parentIndex = Math.floor((currentIndex - 1) / 2)\n\n    while (parentIndex >= 0 &#x26;&#x26; this.heap[parentIndex] &#x3C; value) {\n      this.swap(parentIndex, currentIndex)\n      currentIndex = parentIndex\n      parentIndex = Math.floor((currentIndex - 1) / 2)\n    }\n  }\n\n  pop() {\n    if (this.heap.length === 0) return undefined\n    if (this.heap.length === 1) return this.heap.pop()\n\n    const root = this.heap[0]\n    const end = this.heap.pop()\n    this.heap[0] = end\n\n    let currentIndex = 0\n    let leftIndex = 1\n    let rightIndex = 2\n\n    while (\n      this.heap[currentIndex] &#x3C; this.heap[leftIndex] ||\n      this.heap[currentIndex] &#x3C; this.heap[rightIndex]\n    ) {\n      if (this.heap[leftIndex] &#x3C; this.heap[rightIndex]) {\n        this.swap(currentIndex, rightIndex)\n        currentIndex = rightIndex\n      } else {\n        this.swap(currentIndex, leftIndex)\n        currentIndex = leftIndex\n      }\n      leftIndex = currentIndex * 2 + 1\n      rightIndex = currentIndex * 2 + 2\n    }\n    return root\n  }\n}\n\nfunction solution(n, works) {\n  const heap = new MaxHeap()\n  works.forEach(v => heap.push(v))\n\n  while (n > 0) {\n    const max = heap.pop()\n    n -= 1\n    if (max === 0) return 0\n    //만일 최댓값이 0이라면 해야할 일이 없다는 뜻으로 0을 리턴하고 함수를 종료한다.\n    heap.push(max - 1)\n  }\n  return heap.heap.reduce((acc, cur) => acc + cur * cur, 0)\n}\n</code></pre>\n<h1>추가</h1>\n<p>재귀와 sort 메소드를 사용하는 방법을 생각해보았는데, sort 메소드의 경우 시간 복잡도가 NlogN이라서 효율성 테스트를 통과할 수 없었다. 코드는 아래와 같다.</p>\n<pre><code class=\"language-javascript\">function solution(n, works) {\n  function recursive(n, works) {\n    if (n === 0) return works.reduce((acc, cur) => acc + cur * cur, 0)\n\n    works.sort((a, b) => b - a)\n    if (works[0] === 0) return 0\n\n    works[0] -= 1\n    return recursive(n - 1, works)\n  }\n  return recursive(n, works)\n}\n</code></pre>","id":"709f0900-a461-544b-9ac2-f9e722f4b122"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}