{"componentChunkName":"component---src-templates-post-template-tsx","path":"/algorithm/미로탈출명령어/","result":{"pageContext":{"node":{"fields":{"slug":"/algorithm/미로탈출명령어/"},"excerpt":"문제 링크 간만에 알고리즘을 푼다. 알고리즘은 역시 재밌는 것 같다. 카카오 문제를 풀어봤는데, 그렇게 어렵지는 않았다. 작년 하반기에 카카오 공채를 응시하지 못한 것이 매우 아쉬울 따름이다. 판단 기준이 없어서 잘못된 선택을 내렸다. 반면교사하여 다시는 잘못된 선택을 하지 않으면 된다. 해결 전략 격자 미로에서 출발지와 도착지를 가는 길 중 문자열이 사전 순서에서 가장 작은 길을 구해야한다. 격자 미로: 격자 미로일 경우 우리는 어느 한 지…","frontmatter":{"date":"2023-03-10T00:00:00.000Z","description":"그리디","title":"미로탈출명령어"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/150365\">문제 링크</a></p>\n<p>간만에 알고리즘을 푼다. 알고리즘은 역시 재밌는 것 같다.<br>\n카카오 문제를 풀어봤는데, 그렇게 어렵지는 않았다. 작년 하반기에 카카오 공채를 응시하지 못한 것이 매우 아쉬울 따름이다. 판단 기준이 없어서 잘못된 선택을 내렸다. 반면교사하여 다시는 잘못된 선택을 하지 않으면 된다.</p>\n<h1>해결 전략</h1>\n<p>격자 미로에서 출발지와 도착지를 가는 길 중 문자열이 사전 순서에서 가장 작은 길을 구해야한다.</p>\n<ol>\n<li>\n<p>격자 미로: 격자 미로일 경우 우리는 어느 한 지점에서, 다른 지점까지의 최단 거리를 매우 쉽게 알 수 있다. 예시로 (a1,b1), (a2,b2) 두 좌표일 때 최단 거리는 |a1-a2|+|b1-b2| 이다.</p>\n</li>\n<li>\n<p>사전 순서에서 가장 작은 길: 방향을 문자열로 치환하였을 때, 사전 순으로 나열하면 d, l, r, u이다. 단어를 사전 순으로 정렬했을 때 앞에 위치하려면, 단어 내 앞에 있는 문자가 최대한 사전순으로 정렬되어야 한다. 그 의미는 drrr이 rddd 보다 사전 앞에 위치한다. 단어 내 앞에 배치된 문자가 중요도가 훨씬 높다는 의미이다.</p>\n</li>\n<li>\n<p>k번: 우리는 k번 움직일 수 있다. 왔던 길을 다시 돌아갈 수도 있다. 다시 말하면 우리는 이동한 지점으로부터 도착지까지 남은 k번 내에 도달할 수 있다면 어디를 가던 상관이 없다.</p>\n</li>\n</ol>\n<p>2번 항목에서 그리디 알고리즘을 떠올리게 되었고,\n내가 고안한 알고리즘은 다음과 같다.</p>\n<ol>\n<li>우리는 k번 만큼 움직인다. 방향의 우선 순위는 방향을 문자열로 치환했을 때의 사전 순서이다. (d,l,r,u)</li>\n<li>d,l,r,u 순서대로 순회하며 다음의 이동 지점을 구해본다.</li>\n<li>만일 다음의 이동 지점에서 도착지까지 도달할 수 없다면, 다음 순회로 넘어간다. (남은 k가 모자라는 경우)</li>\n<li>만일 다음의 이동 지점에서 도착지까지 도달할 수 있다면 k를 1개 줄여주고, 해당 방향을 기록해준다. 2번의 순회를 멈춘다.</li>\n<li>이 과정을 k가 0이 될 때 까지 반복한다.</li>\n<li>k가 0이 되었을 때 도착한 지점이 목적지와 다르다면 'impossible'을 출력한다. 그게 아니라면 기록한 방향을 출력해준다.</li>\n</ol>\n<h1>정답 코드</h1>\n<pre><code class=\"language-js\">function solution(n, m, x, y, r, c, k) {\n  const direction = ['d', 'l', 'r', 'u'];\n  const dx = [0, -1, 1, 0];\n  const dy = [1, 0, 0, -1];\n\n  let answer = '';\n\n  const start = [x - 1, y - 1];\n  const end = [r - 1, c - 1];\n\n  while (k > 0) {\n    for (let i = 0; i &#x3C; 4; i++) {\n      const next = [start[0] + dy[i], start[1] + dx[i]];\n      if (check(next, n, m)) {\n        if (getDistance(next, end) &#x3C;= k) {\n          k -= 1;\n          start[0] = next[0];\n          start[1] = next[1];\n          answer += direction[i];\n          break;\n        }\n      }\n      if (i === 3) return 'impossible'; // 아래 설명 참조\n    }\n  }\n  if (start[0] !== end[0] || start[1] !== end[1]) return 'impossible';\n  return answer;\n}\n\nfunction getDistance(pos1, pos2) {\n  const [y1, x1] = pos1;\n  const [y2, x2] = pos2;\n  return Math.abs(x2 - x1) + Math.abs(y2 - y1);\n}\n\nfunction check(pos, n, m) {\n  const [pos_y, pos_x] = pos;\n  return pos_y >= 0 &#x26;&#x26; pos_y &#x3C;= n - 1 &#x26;&#x26; pos_x >= 0 &#x26;&#x26; pos_x &#x3C;= m - 1;\n}\n</code></pre>\n<p>for 문내에 <code>if (i === 3) return 'impossible'</code> 이라는 코드를 삽입한 이유는 모든 방향으로 가봤을 때 도달할 수 있는 경우가 없다면 불가능한 경우이기 때문에 루프를 종료시킨다. 루프를 종료시키지 않으면 k가 줄지 않기 때문에 while문을 벗어날 수 없다.</p>","id":"c95bf2f7-a8b0-51a8-8b8e-c9fb5cf894c7"},"previous":{"fields":{"slug":"/algorithm/이모티콘할인행사/"},"excerpt":"문제 링크 해결 전략 우리는 문제에 주어진 우선순위에 맞게 최대 이모티콘 서비스 가입자수와 판매액을 구해야한다. 이 문제는 완전 탐색으로 해결할 수 있는 문제이다. 우리는 이모티콘별 적정 할인률을 구해야하는데, 이모티콘의 할인률은 10%,20%,30%,40% 중 하나이다.\nemoticons의 최대 길이는 7로 최대의 시간 복잡도를 계산해보면, 100 * (4 ** 7)로 충분하다. (n=100, emoticons의 길이 7) 완전 탐색 알고리…","frontmatter":{"date":"2023-02-09T00:00:00.000Z","description":"중복 순열, 완전 탐색","title":"이모티콘 할인행사"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/150368\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>우리는 문제에 주어진 우선순위에 맞게 최대 이모티콘 서비스 가입자수와 판매액을 구해야한다.</p>\n<p>이 문제는 완전 탐색으로 해결할 수 있는 문제이다. 우리는 이모티콘별 적정 할인률을 구해야하는데, 이모티콘의 할인률은 10%,20%,30%,40% 중 하나이다.\nemoticons의 최대 길이는 7로 최대의 시간 복잡도를 계산해보면, <code>100 * (4 ** 7)</code>로 충분하다. (n=100, emoticons의 길이 7)</p>\n<p>완전 탐색 알고리즘을 설계하면 된다.</p>\n<ol>\n<li>가능한 할인율을 전부 생성한다. 중복 순열 알고리즘을 사용한다.</li>\n<li>순열 경우의 수를 순회하면서 이모티콘 서비스 가입자 수와 판매액을 구한다.</li>\n<li>우선순위에 따라서 최대 이모티콘 서비스 가입자수와 판매액을 갱신한다.</li>\n</ol>\n<h1>정답 코드</h1>\n<pre><code class=\"language-js\">const getSum = (user, emoticons, discountRates) => {\n  const [rate] = user;\n  let sum = 0;\n\n  const n = emoticons.length;\n  for (let i = 0; i &#x3C; n; i++) {\n    if (discountRates[i] >= rate) {\n      sum += emoticons[i] * (100 - discountRates[i]) * 0.01;\n    }\n  }\n  return sum;\n};\n\nfunction getPermutation(arr, n) {\n  const result = [];\n  if (n === 1) return arr.map(el => [el]);\n\n  arr.forEach((v, i) => {\n    const permutation = getPermutation(arr, n - 1);\n    const attached = permutation.map(el => [v, ...el]);\n    result.push(...attached);\n  });\n  return result;\n}\n\nfunction solution(users, emoticons) {\n  const discountRates = getPermutation([10, 20, 30, 40], emoticons.length);\n\n  let answer_plus = 0;\n  let answer_price = 0;\n\n  for (let discountRate of discountRates) {\n    let plus = 0;\n    let price = 0;\n    for (let user of users) {\n      const sum = getSum(user, emoticons, discountRate);\n      if (sum >= user[1]) plus++;\n      else price += sum;\n    }\n\n    if (plus > answer_plus) {\n      answer_plus = Math.max(answer_plus, plus);\n      answer_price = price;\n    }\n\n    if (plus === answer_plus) {\n      answer_price = Math.max(answer_price, price);\n    }\n  }\n\n  return [answer_plus, answer_price];\n}\n</code></pre>","id":"1c6ad7e6-be48-5d9f-835b-9ddc01d12fb4"},"next":null}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}