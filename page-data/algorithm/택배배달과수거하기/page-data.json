{"componentChunkName":"component---src-templates-post-template-tsx","path":"/algorithm/택배배달과수거하기/","result":{"pageContext":{"node":{"fields":{"slug":"/algorithm/택배배달과수거하기/"},"excerpt":"문제 링크 해결 전략 우리가 구해야 하는 것은 트럭의 최소 이동 거리이다.\n트럭이 최소의 거리로 모든 상자를 배달하고 수거하기 위해서는, 출발지로부터 가장 거리가 먼 집부터 처리해야한다. 출발지로부터 가장 거리가 먼 집부터 처리하는 이유는, 짧은 거리는 긴 거리에 포함이 되기 때문에 짧은 거리에 있는 집을 먼저 처리해도 긴 거리에 있는 집을 가기 위해서는 동일한 루트를 반복해서 가야한다.\n하지만 긴 거리에 있는 집부터 처리하면 반복해서 가야하…","frontmatter":{"date":"2023-02-09T00:00:00.000Z","description":"그리디","title":"택배 배달과 수거하기"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/150369\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>우리가 구해야 하는 것은 트럭의 최소 이동 거리이다.\n트럭이 최소의 거리로 모든 상자를 배달하고 수거하기 위해서는, 출발지로부터 가장 거리가 먼 집부터 처리해야한다.</p>\n<p>출발지로부터 가장 거리가 먼 집부터 처리하는 이유는, 짧은 거리는 긴 거리에 포함이 되기 때문에 짧은 거리에 있는 집을 먼저 처리해도 긴 거리에 있는 집을 가기 위해서는 동일한 루트를 반복해서 가야한다.\n하지만 긴 거리에 있는 집부터 처리하면 반복해서 가야하는 루트를 줄일 수 있다.</p>\n<p>그리고 배달과 수거는 병렬적으로 생각해도 좋다. 배달이든 수거든 가장 먼 도착지까지 갈 때, 배달을 완료하고 출발지로 돌아올 때 수거를 완료하면 된다.</p>\n<p>배달과 수거를 가장 거리가 먼 집부터 완료하는 알고리즘을 설계하면 된다.</p>\n<ol>\n<li>배달이든 수거든 관계없이 해야할 가장 먼 집을 찾고, 해당 집까지의 거리*2를 누적 거리에 더해준다.</li>\n<li>배열의 마지막 요소부터 cap의 한도 내에서 물건의 개수를 줄여준다. 배달과 수거 각각 수행한다.</li>\n<li>배열의 모든 요소가 0(더이상 배달과 수거를 할 필요가 없을 때)일 때까지 반복한다.</li>\n</ol>\n<p>시간 복잡도를 생각해봐야 한다.</p>\n<p>배열의 모든 요소를 순회하며 요소가 0인지 확인해보는 알고리즘은 최대 <code>100,000 * 100 * 100,000</code> 번 연산을 수행해야한다. (cap=1, n=100,000, delivers 모든 원소 50, pickups 모든 원소 50)</p>\n<p>문제의 특성을 살펴보면, 가장 거리가 먼 집을 우선으로 방문함으로써 반복해서 가야하는 루트를 줄일 수 있다고 하였다.\n그렇다면 가장 마지막 집의 위치 정보를 기억하고 있다면, 배열의 마지막 요소부터 물건의 개수를 줄이는 알고리즘의 시간 복잡도를 줄일 수 있다. (배열의 마지막 요소가 아닌, 기억하고 있는 위치부터 수행하면 되므로) 또한 마지막 집의 위치 정보가 배달과 수거 전부 0이라면 모든 배다과 수거를 완료한 것으로 생각할 수 있다. 이 방식은 시간 복잡도를 초과하지 않는다. <code>100,000 * 100</code></p>\n<h1>정답 코드</h1>\n<pre><code class=\"language-js\">function process(arr, index, cap) {\n  while (true) {\n    if (index === 0) break;\n    if (arr[index - 1] > 0 &#x26;&#x26; cap === 0) break;\n\n    if (cap >= arr[index - 1]) {\n      cap -= arr[index - 1];\n      arr[index - 1] = 0;\n      index--;\n    } else {\n      arr[index - 1] -= cap;\n      cap = 0;\n    }\n  }\n  return index;\n}\n\nconst getInitialLast = arr =>\n  arr.reduce((acc, cur, index) => (cur > 0 ? index + 1 : acc), 0);\n\nfunction solution(cap, n, deliveries, pickups) {\n  let deliver_last = getInitialLast(delivers);\n  let pickup_last = getInitialLast(pickups);\n  let distance = 0;\n\n  while (deliver_last > 0 || pickup_last > 0) {\n    distance += Math.max(deliver_last, pickup_last) * 2;\n\n    deliver_last = process(deliveries, deliver_last, cap);\n    pickup_last = process(pickups, pickup_last, cap);\n  }\n\n  return distance;\n}\n</code></pre>","id":"bf3ea1e2-fb92-590b-8aef-3719dc24436d"},"previous":{"fields":{"slug":"/algorithm/이모티콘할인행사/"},"excerpt":"문제 링크 해결 전략 우리는 문제에 주어진 우선순위에 맞게 최대 이모티콘 서비스 가입자수와 판매액을 구해야한다. 이 문제는 완전 탐색으로 해결할 수 있는 문제이다. 우리는 이모티콘별 적정 할인률을 구해야하는데, 이모티콘의 할인률은 10%,20%,30%,40% 중 하나이다.\nemoticons의 최대 길이는 7로 최대의 시간 복잡도를 계산해보면, 100 * (4 ** 7)로 충분하다. (n=100, emoticons의 길이 7) 완전 탐색 알고리…","frontmatter":{"date":"2023-02-09T00:00:00.000Z","description":"중복 순열, 완전 탐색","title":"이모티콘 할인행사"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/150368\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>우리는 문제에 주어진 우선순위에 맞게 최대 이모티콘 서비스 가입자수와 판매액을 구해야한다.</p>\n<p>이 문제는 완전 탐색으로 해결할 수 있는 문제이다. 우리는 이모티콘별 적정 할인률을 구해야하는데, 이모티콘의 할인률은 10%,20%,30%,40% 중 하나이다.\nemoticons의 최대 길이는 7로 최대의 시간 복잡도를 계산해보면, <code>100 * (4 ** 7)</code>로 충분하다. (n=100, emoticons의 길이 7)</p>\n<p>완전 탐색 알고리즘을 설계하면 된다.</p>\n<ol>\n<li>가능한 할인율을 전부 생성한다. 중복 순열 알고리즘을 사용한다.</li>\n<li>순열 경우의 수를 순회하면서 이모티콘 서비스 가입자 수와 판매액을 구한다.</li>\n<li>우선순위에 따라서 최대 이모티콘 서비스 가입자수와 판매액을 갱신한다.</li>\n</ol>\n<h1>정답 코드</h1>\n<pre><code class=\"language-js\">const getSum = (user, emoticons, discountRates) => {\n  const [rate] = user;\n  let sum = 0;\n\n  const n = emoticons.length;\n  for (let i = 0; i &#x3C; n; i++) {\n    if (discountRates[i] >= rate) {\n      sum += emoticons[i] * (100 - discountRates[i]) * 0.01;\n    }\n  }\n  return sum;\n};\n\nfunction getPermutation(arr, n) {\n  const result = [];\n  if (n === 1) return arr.map(el => [el]);\n\n  arr.forEach((v, i) => {\n    const permutation = getPermutation(arr, n - 1);\n    const attached = permutation.map(el => [v, ...el]);\n    result.push(...attached);\n  });\n  return result;\n}\n\nfunction solution(users, emoticons) {\n  const discountRates = getPermutation([10, 20, 30, 40], emoticons.length);\n\n  let answer_plus = 0;\n  let answer_price = 0;\n\n  for (let discountRate of discountRates) {\n    let plus = 0;\n    let price = 0;\n    for (let user of users) {\n      const sum = getSum(user, emoticons, discountRate);\n      if (sum >= user[1]) plus++;\n      else price += sum;\n    }\n\n    if (plus > answer_plus) {\n      answer_plus = Math.max(answer_plus, plus);\n      answer_price = price;\n    }\n\n    if (plus === answer_plus) {\n      answer_price = Math.max(answer_price, price);\n    }\n  }\n\n  return [answer_plus, answer_price];\n}\n</code></pre>","id":"1c6ad7e6-be48-5d9f-835b-9ddc01d12fb4"},"next":{"fields":{"slug":"/algorithm/미로탈출명령어/"},"excerpt":"문제 링크 해결 전략 격자 미로에서 출발지와 도착지를 가는 길 중 문자열이 사전 순서에서 가장 작은 길을 구해야한다. 격자 미로: 격자 미로일 경우 우리는 어느 한 지점에서, 다른 지점까지의 최단 거리를 매우 쉽게 알 수 있다. 예시로 (a1,b1), (a2,b2) 두 좌표일 때 최단 거리는 |a1-a2|+|b1-b2| 이다. 사전 순서에서 가장 작은 길: 방향을 문자열로 치환하였을 때, 사전 순으로 나열하면 d, l, r, u이다. 단어를 …","frontmatter":{"date":"2023-03-10T00:00:00.000Z","description":"그리디","title":"미로탈출명령어"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/150365\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>격자 미로에서 출발지와 도착지를 가는 길 중 문자열이 사전 순서에서 가장 작은 길을 구해야한다.</p>\n<ol>\n<li>\n<p>격자 미로: 격자 미로일 경우 우리는 어느 한 지점에서, 다른 지점까지의 최단 거리를 매우 쉽게 알 수 있다. 예시로 (a1,b1), (a2,b2) 두 좌표일 때 최단 거리는 |a1-a2|+|b1-b2| 이다.</p>\n</li>\n<li>\n<p>사전 순서에서 가장 작은 길: 방향을 문자열로 치환하였을 때, 사전 순으로 나열하면 d, l, r, u이다. 단어를 사전 순으로 정렬했을 때 앞에 위치하려면, 단어 내 앞에 있는 문자가 최대한 사전순으로 정렬되어야 한다. 그 의미는 drrr이 rddd 보다 사전 앞에 위치한다. 단어 내 앞에 배치된 문자가 중요도가 훨씬 높다는 의미이다.</p>\n</li>\n<li>\n<p>k번: 우리는 k번 움직일 수 있다. 왔던 길을 다시 돌아갈 수도 있다. 다시 말하면 우리는 이동한 지점으로부터 도착지까지 남은 k번 내에 도달할 수 있다면 어디를 가던 상관이 없다.</p>\n</li>\n</ol>\n<p>2번 항목에서 그리디 알고리즘을 떠올리게 되었고,\n내가 고안한 알고리즘은 다음과 같다.</p>\n<ol>\n<li>우리는 k번 만큼 움직인다. 방향의 우선 순위는 방향을 문자열로 치환했을 때의 사전 순서이다. (d,l,r,u)</li>\n<li>d,l,r,u 순서대로 순회하며 다음의 이동 지점을 구해본다.</li>\n<li>만일 다음의 이동 지점에서 도착지까지 도달할 수 없다면, 다음 순회로 넘어간다. (남은 k가 모자라는 경우)</li>\n<li>만일 다음의 이동 지점에서 도착지까지 도달할 수 있다면 k를 1개 줄여주고, 해당 방향을 기록해준다. 2번의 순회를 멈춘다.</li>\n<li>이 과정을 k가 0이 될 때 까지 반복한다.</li>\n<li>k가 0이 되었을 때 도착한 지점이 목적지와 다르다면 'impossible'을 출력한다. 그게 아니라면 기록한 방향을 출력해준다.</li>\n</ol>\n<h1>정답 코드</h1>\n<pre><code class=\"language-js\">function solution(n, m, x, y, r, c, k) {\n  const direction = ['d', 'l', 'r', 'u'];\n  const dx = [0, -1, 1, 0];\n  const dy = [1, 0, 0, -1];\n\n  let answer = '';\n\n  const start = [x - 1, y - 1];\n  const end = [r - 1, c - 1];\n\n  while (k > 0) {\n    for (let i = 0; i &#x3C; 4; i++) {\n      const next = [start[0] + dy[i], start[1] + dx[i]];\n      if (check(next, n, m)) {\n        if (getDistance(next, end) &#x3C;= k) {\n          k -= 1;\n          start[0] = next[0];\n          start[1] = next[1];\n          answer += direction[i];\n          break;\n        }\n      }\n      if (i === 3) return 'impossible'; // 아래 설명 참조\n    }\n  }\n  if (start[0] !== end[0] || start[1] !== end[1]) return 'impossible';\n  return answer;\n}\n\nfunction getDistance(pos1, pos2) {\n  const [y1, x1] = pos1;\n  const [y2, x2] = pos2;\n  return Math.abs(x2 - x1) + Math.abs(y2 - y1);\n}\n\nfunction check(pos, n, m) {\n  const [pos_y, pos_x] = pos;\n  return pos_y >= 0 &#x26;&#x26; pos_y &#x3C;= n - 1 &#x26;&#x26; pos_x >= 0 &#x26;&#x26; pos_x &#x3C;= m - 1;\n}\n</code></pre>\n<p>for 문내에 <code>if (i === 3) return 'impossible'</code> 이라는 코드를 삽입한 이유는 모든 방향으로 가봤을 때 도달할 수 있는 경우가 없다면 불가능한 경우이기 때문에 루프를 종료시킨다. 루프를 종료시키지 않으면 k가 줄지 않기 때문에 while문을 벗어날 수 없다.</p>","id":"c95bf2f7-a8b0-51a8-8b8e-c9fb5cf894c7"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}