{"componentChunkName":"component---src-templates-post-template-tsx","path":"/tech/node.js/","result":{"pageContext":{"node":{"fields":{"slug":"/tech/node.js/"},"excerpt":"Node.js란 Node.js는 Chrome의 V8 엔진으로 빌드된 자바스크립트 런타임이다. 기존에 자바스크립트는 브라우저에서만 구동 가능한 언어였다. 구글이 매우 빠른 자바스크립트 엔진인 V8을 출시하자 이를 바탕으로 브라우저 외 환경에서 자바스크립트 런타임을 구축하기 시작했다. 이벤트 기반 이벤트 기반이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미한다. 예시로 클릭이나 네트워크 요청 등이 있을 수 있다. 논 블로킹 논 …","frontmatter":{"date":"2022-10-19T00:00:00.000Z","description":"Node.js, Express, MongoDB란?","title":"Node.js, Express, MongoDB"},"html":"<h1>Node.js란</h1>\n<p>Node.js는 Chrome의 V8 엔진으로 빌드된 자바스크립트 런타임이다. 기존에 자바스크립트는 브라우저에서만 구동 가능한 언어였다. 구글이 매우 빠른 자바스크립트 엔진인 V8을 출시하자 이를 바탕으로 브라우저 외 환경에서 자바스크립트 런타임을 구축하기 시작했다.</p>\n<h2>이벤트 기반</h2>\n<p>이벤트 기반이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미한다. 예시로 클릭이나 네트워크 요청 등이 있을 수 있다.</p>\n<h2>논 블로킹</h2>\n<p>논 블로킹이란 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행함을 뜻한다. 반대로 블로킹이란 이전 작업이 끝나야만 다음 작업을 수행하는 것을 의미한다. 논 블로킹 방식은 모든 작업이 동시에 처리될 수 있다는 전제하에 블로킹 방식보다 훨씬 빠르다. (ex. 시간이 오래 걸리는 블로킹 코드를 setTimeout으로 묶어 백그라운드에서 처리하도록 함.)</p>\n<h2>싱글 스레드</h2>\n<p>엄밀히 말하자면 싱글 스레드로 동작하지 않는다. 노드를 실행하면 프로세스를 하나 생성하고, 해당 프로세스에서 스레드들을 생성하는데 내부적으로 스레드를 여러개 생성한다. 그중에서 우리가 제어할 수 있는 스레드는 하나이기에 싱글 스레드라고 여겨진다. Node.js는 싱글 스레드 논블로킹 방식으로 움직이기 때문에 매우 효율적으로 일처리가 가능하고 멀티 스레드에 비해서 프로그래밍이 비교적 쉽다는 장점이 있다. (워커 스레드라는 기능을 사용하면 멀티 스레드 구현이 가능하다. 스레드풀의 경우는 자동으로 멀티스레드를 사용한다. 암호화, 파일 입출력 등 작업에서 사용된다.)</p>\n<h2>그렇다면 언제 Node.js를 사용하면 좋을까?</h2>\n<p>노드는 싱글 스레드, 논블로킹 모델로 사용하므로 해당 모델의 장단점과 크게 다르지 않다.\n서버는 기본적으로 I/O를 많이 수행하는데 노드는 많은 양의 I/O 작업을 논블로킹 모델로 효율적으로 처리할 수 있다. 하지만 CPU 부하가 큰 작업에는 적합하지 않다. 스레드 하나가 혼자서 감당하기 어렵기 때문이다. 정리를 하자면, 개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는 데 적합하다. 네트워크, 데이터베이스, 디스크 작업 같은 I/O에 특화되어 있기 때문이다. 예시로 실시간 채팅 어플리케이션, 주식 차트, JSON 데이터를 제공하는 API 서버가 노드를 많이 사용한다.</p>\n<p>싱글 스레드 방식의 프로그래밍은 러닝 커브가 멀티 스레드 방식보다 상대적으로 낮다. 하지만 싱글 스레드의 경우 하나뿐인 스레드가 오류가 발생하면 멈추기 때문에 잘 관리하도록 해야한다.</p>\n<h1>Express란</h1>\n<p>Express는 웹 서버 프레임워크이다. 웹 서버를 구성하기 위해서 많은 편의 기능들이 내장되어 있다.\n대표적으로 미들웨어와 라우팅이라는 장점이 있다.</p>\n<p>Express의 핵심은 미들웨어라고 해도 과언이 아니다. 뒤에 나오는 라우터도 미들웨어의 일종이다. 미들웨어를 통해 요청과 응답에 다양한 기능을 추가할 수 있다. 로그인 여부 체크 등..</p>\n<p>라우팅의 경우 http 모듈을 사용해서 처리하려면, 굉장히 많은 분기가 필요하지만 Express 라우팅 기능을 사용하면 손쉽게 가능하다.</p>\n<h1>MongoDB란?</h1>\n<p>MongoDB는 NoSQL 데이터베이스로 자바스크립트 문법을 사용한다는 특징이 있다. MongoDB를 사용하면 자바스크립트만으로 웹 애플리케이션을 구축할 수 있다.</p>\n<h2>NoSQL, SQL 특징</h2>\n<p>NoSQL에는 고정된 테이블이 없다. SQL의 경우 테이블을 만들 때, 칼럼과 자료형, 옵션 등을 정의하지만 몽고디비는 컬렉션을 만들면 끝이다. 어떠한 데이터든 들어갈 수 있다.</p>\n<p>MongoDB는 MySQL과 달리 JOIN 기능이 없다. 흉내를 낼수는 있지만, 하나의 쿼리로 여러 테이블을 합치는 작업이 항상 가능하지는 않다.</p>\n<p>몽고디비의 가장 큰 장점은 확장성과 가용성이다. 데이터의 일관성을 보장해주는 기능이 약한 대신, 데이터를 빠르게 넣을 수 있고 여러 서버에 데이터를 쉽게 분산시킬 수 있다.</p>\n<p>어플리케이션에 꼭 한가지 데이터베이스만 써야되는 것은 아니다. 상황에 맞게 올바른 데이터베이스를 선택하면 된다. 데이터의 일관성이 필요한 항공 예약의 경우는 MySQL로, 채팅 혹은 빅데이터와 같은 일관성이 필요없고 데이터 양이 많은 경우는 MongoDB 도입을 고려해볼 수 있다.</p>\n<h2>Mongoose란?</h2>\n<p>ODM(Object Document Mapping)이라고 불린다. 몽고디비 자체가 이미 자바스크립트인데 굳이 자바스크립트 객체와 매핑시키는 이유는 몽고디비에 없어서 불편한 기능들을 몽구스가 보완해주기 때문이다.\n(참고. MySQL은 ORM은 시퀄라이즈가 있다.)</p>\n<p><em>ODM이란 프로그래밍 언어 Object와 Document를 매핑시켜 호환성을 만들어내고 간편한 CRUD를 가능케한다.</em></p>\n<p>스키마라는 기능을 사용할 수 있다. NoSQL은 테이블이 없어서 자유롭게 데이터를 넣을 수 있지만, 때로는 자유로움이 불편함을 초래한다. 잘못된 자료형을 넣을 수 있고 다른 도큐멘트에는 없는 필드의 데이터를 넣을 수도 있다. 몽구스는 몽고디비에 데이터를 넣기 전에 노드 서버단에서 데이터를 한번 필터링 하는 역할을 한다.</p>\n<p>MySQL에 있는 JOIN 기능을 populate로 어느정도 보완한다. 관계가 있는 데이터를 쉽게 가져올 수 있다. 쿼리 한번에 데이터를 합쳐서 가져오는 것은 아니지만, 이 작업을 우리가 직접 하지 않아도 되므로 편리하다.</p>\n<h1>참고</h1>\n<p><a href=\"http://www.yes24.com/Product/Goods/91860680\">Node.js 교과서 개정 2판</a></p>","id":"c8a81d5e-a70b-5c15-b698-7a380d614956"},"previous":{"fields":{"slug":"/programming/이펙티브타입스크립트/2장/"},"excerpt":"편집기를 사용하여 타입 시스템 탐색하기 많은 개발자들이 vscode를 이용하는데 typescript를 제작한 ms에서 만든 것이다. 따라서 vscode를 사용하면 typescript의 언어 서비스를 잘 활용할 수 있다. 편집기를 통해서 어떻게 타입 시스템이 동작하는지, 타입스크립트가 어떻게 타입을 추론하는지 개념을 잡을 수 있다. Go to Definition 기능을 통해서 타입 선언 파일로 이동할 수 있고, 타입 선언 파일을 보면서 어떻게 …","frontmatter":{"date":"2022-10-18T00:00:00.000Z","description":"타입스크립트의 타입 시스템","title":"이펙티브 타입스크립트 2장"},"html":"<h1>편집기를 사용하여 타입 시스템 탐색하기</h1>\n<p>많은 개발자들이 vscode를 이용하는데 typescript를 제작한 ms에서 만든 것이다. 따라서 vscode를 사용하면 typescript의 언어 서비스를 잘 활용할 수 있다.</p>\n<p>편집기를 통해서 어떻게 타입 시스템이 동작하는지, 타입스크립트가 어떻게 타입을 추론하는지 개념을 잡을 수 있다.</p>\n<pre><code class=\"language-ts\">const num = 3\n//num은 number로 자동으로 추론한다.\n</code></pre>\n<p>Go to Definition 기능을 통해서 타입 선언 파일로 이동할 수 있고, 타입 선언 파일을 보면서 어떻게 모델링 되었는지 파악할 수 있다.</p>\n<h1>타입이 값들의 집합이라고 생각하기</h1>\n<p>타입이 값들의 집합이라고 생각하라는 의미는 무엇일까. 1,2,3이라는 값들은 number라는 타입에 해당된다. 즉 1,2,3이라는 숫자 값들의 집합은 number 타입에 해당된다는 것이다. 1000도 숫자 값의 집합의 요소이기 때문에 number 타입에 해당된다.</p>\n<h2>타입의 종류</h2>\n<ol>\n<li>never 타입\n<ul>\n<li>공집합으로, never에는 아무런 값도 할당할 수 없다.</li>\n</ul>\n</li>\n<li>유닛 타입 혹은 리터럴 타입\n<ul>\n<li>한 가지 값만 포함하는 타입이다.</li>\n</ul>\n<pre><code class=\"language-ts\">type A = \"a\"\ntype B = \"b\"\n</code></pre>\n</li>\n<li>유니온 타입 - 값 집합들의 합집합을 말한다.\n<pre><code class=\"language-ts\">type AB = \"A\" | \"B\"\ntype AB12 = \"A\" | \"B\" | 12\n</code></pre>\n</li>\n<li>집합의 범위가 한정되어 있지 않은 타입들\n<ul>\n<li>number, string 등의 타입은 범위가 무한대이다. 나올 수 있는 경우의 수가 무수히 많기 때문이다.</li>\n</ul>\n</li>\n<li>서브 타입\n<pre><code class=\"language-ts\">interface Person {\n  name: string\n}\ninterface PersonSpan extends Person {\n  birth: Date\n  death?: Date\n}\n</code></pre>\nPersonSpan은 Person의 서브타입이라고 할 수 있다. PersonSpan은 Person의 모든 조건을 만족해야한다.</li>\n</ol>\n<h2>키워드</h2>\n<h3>&#x26;</h3>\n<p>두 타입의 인터섹션(교집합)을 계산한다. 예시를 통해서 알아보도록 한다.</p>\n<pre><code class=\"language-ts\">interface Person {\n  name: string\n}\n\ninterface LifeSpan {\n  birth: Date\n  death?: Date\n}\n\ntype PersonSpan = Person &#x26; LifeSpan\n\nconst ps: PersonSpan = {\n  name: \"hi\",\n  birth: new Date(),\n}\n</code></pre>\n<p>위의 PersonSpan의 경우 두 인터페이스가 공통적으로 가지는 속성이 없기 때문에 공집합이라고 생각할 수 있지만 이것은 틀린 것이다. 덕 타이핑으로 인해서 Person 인터페이스의 경우 어떤 객체가 name 속성을 보유하고 그것이 문자열이면 모두 만족한다. LifeSpan 인터페이스의 경우 마찬가지로 birth의 속성이 날짜인 객체도 전부 만족한다. 따라서 교집합이므로, name 속성과 birth 속성 2개다 존재해야 하는 것이다.</p>\n<p>하지만 유니온에 대해서는 다른 형태를 보여준다.</p>\n<pre><code class=\"language-ts\">type union = Person | LifeSpan\n\ntype K = keyof union\ntype M = typeof (Person &#x26; LifeSpan)\n</code></pre>\n<p>K는 never이고, M은 <code>name | birth | death</code>이다.\nK가 never인 이유는 union의 키는 (name) | (birth | death) 인데 둘 중 무슨 값이 될지 모르기 때문에 2개 다 만족하는 값이 나와야한다(?)</p>\n<pre><code class=\"language-ts\">keyof (A|B) = (keyof A) &#x26; (keyof B)\n</code></pre>\n<h3>extends</h3>\n<p>extends 키워드를 활용하여 서브 타입을 만들어낼 수 있다.</p>\n<p>extends 키워드는 제너릭 타입에서 한정자로도 쓰인다. 해당 문맥에서는 ~의 부분 집합을 의미하기도 한다.</p>\n<pre><code class=\"language-ts\">function getKey&#x3C;K extends string>(val: any, key: K) {\n  //....\n}\n\ngetKey(val, \"3\")\ngetKey(val, 12)\n//오류가 발생한다. K는 string의 부분 집합이므로.\n</code></pre>\n<h1>타입 공간과 값 공간의 심벌 구분하기</h1>\n<p>타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재한다.</p>\n<p><em>symbol이란 es5에서 추가로 명세된 원시값이다. 고유하기 때문에 충돌이 없어 객체의 키값으로 주로 사용된다.</em></p>\n<pre><code class=\"language-ts\">interface Cylinder {\n  radius: number\n  height: number\n}\n\nconst Cyclinder = (radius: number, height: number) => ({ radius, height })\n</code></pre>\n<p>interface에서는 Cylinder는 타입으로, const에서는 값으로 사용된다. 심벌에 어떤 키워드가 사용되었는지 잘파악하여 문맥으로 유추해야한다.</p>\n<p>클래스의 경우 타입으로 쓰일 때는 형태(속성과 메소드)가 사용되는 반면, 값으로 쓰일 때는 생성자가 사용된다.</p>\n<p>typeof, this 그리고 많은 다른 연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.</p>\n<h1>타입 단언보다는 타입 선언하기</h1>\n<p>타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법은 타입 단언, 타입 선언 두가지이다.\n타입 단언이 꼭 필요한 경우가 아니라면 타입 선언을 사용해야한다. 타입 단언의 경우 강제로 타입을 지정한 것과 마찬가지이다. 타입 체커의 오류도 나타나지 않는다.</p>\n<pre><code class=\"language-ts\">interface Person {\n  name: string\n}\n\nconst person: Person = { name: \"jinwook\" }\nconst e_person = { nickname: \"jinwook\" } as Person\n//e_person의 경우 타입 체커에 의해서 오류가 발생해야 하지만, 타입 단언으로 인해서 오류가 발생하지 않음.\n</code></pre>\n<pre><code class=\"language-ts\">document.querySelector(\"#myButton\").addEventListener(\"click\", e => {\n  const button = e.currentTarget as HTMLButtonElement\n})\n</code></pre>\n<p>타입 단언이 꼭 필요한 경우는 타입 체커가 추론한 타입보다 내가 판단하는 타입이 더 정확할 때 의미가 있다.\n예를 들어 DOM 엘리먼트에 대해서는 타입스크립트보다 개발자가 더 정확히 알고있다. 타입스크립트는 DOM에 접근할 수 없기 때문에 myButton이 버튼 엘리먼트인지 알 수 없다.</p>\n<h2>화살표 함수에서 타입 선언</h2>\n<p>화살표 함수의 타입 선언은 추론된 타입이 모호할 때가 있다.</p>\n<pre><code class=\"language-ts\">const people = [\"jinwook\"].map(name => ({ name }))\n//{name:string}[] 형태이다. 원하는 Person[]이 나오지 않는다.\n</code></pre>\n<p>타입 단언을 써도 문제가 해결되긴 하지만, 런타임에 문제가 발생한다.</p>\n<pre><code class=\"language-ts\">const people = [\"jinwook\"].map(name => ({ name } as Person))\nconst e_people = [\"jinwook\"].map(name => ({} as Person))\n//e_people의 경우 Person 형태를 만족하지 않지만 에러를 반환하지 않음.\n</code></pre>\n<p>화살표 함수의 반환값에 타입을 선언하거나 화살표 함수 내에서 타입과 함께 변수를 선언함으로써 이러한 문제를 해결할 수 있다.</p>\n<pre><code class=\"language-ts\">const people = [\"jinwook\"].map((name): Person => ({ name }))\n\nconst people = [\"jinwook\"].map((name): Person => {\n  const person: Person = { name }\n  return person\n})\n</code></pre>\n<p>타입 단언을 사용하더라도, 서로의 서브타입이 아니면 변환이 불가능하다.</p>\n<pre><code class=\"language-ts\">const body = document.getElementById(\"foo\") //HTMLElement | null\nconst el = body as Person //타입 체커 오류 발생.\n</code></pre>\n<h1>객체 래퍼 타입 피하기</h1>\n<pre><code class=\"language-ts\">\"Thisisstring\".charAt(3)\n</code></pre>\n<p>위와 같은 코드는 어떻게 동작하는 것일까? string은 기본형으로 불변이며 메소드를 가지지 않는데 말이다.\n정확히 알아보면 charAt 메소드는 string의 메소드가 아니라 String 객체의 메소드이다. 자바스크립트는 기본형과 객체 타입을 서로 자유롭게 변환한다.</p>\n<p><strong>string 기본형에 charAt과 같은 메서드를 사용할 때, 기본형을 String 객체로 래핑하고 메소드를 호출하고 마지막에 래핑한 객체를 버린다.</strong></p>\n<p>이 String 객체는 오직 자기 자신하고만 동일하다.</p>\n<p>객체 래퍼 타입의 자동 변환은 종종 당황스러운 동작을 보인다.</p>\n<pre><code class=\"language-ts\">x = \"hello\"\nx.lanuage = \"English\"\nx.lanuage //undefined\n</code></pre>\n<p>String 객체로 변환되었다가 lanuage 속성을 할당하고 객체는 버려진다. 따라서 해당 속성으로 접근해도 undefined가 출력되는 것이다.</p>\n<p>이러한 래퍼 타입들 덕분에 기본형 값에 메소드를 사용할 수 있고, 정적 메소드(String.fromCharCode)도 사용할 수 있다. 타입스크립트는 기본형과 객체 래퍼 타입을 별도로 모델링한다.</p>\n<p>기본형은 객체 래퍼 타입에 할당될 수 있지만, 객체 래퍼 타입은 기본형에 할당될 수 없다. 객체 래퍼 타입의 할당은 지양해야 한다.</p>\n<pre><code class=\"language-ts\">const getStrLen = (foo: String): number => foo.length\ngetStrLen(\"hello\") //정상 작동\n\nconst isGreeting = (phrase: String) => [\"hi\", \"hello\"].includes(phrase)\n//타입 체크 에러 발생. includes에 들어가는 인수는 객체 래퍼 타입이 아니라 기본형이여햐함.\n</code></pre>\n<h1>잉여 속성 체크 한계 인지하기</h1>\n<p>타입이 명시된 변수에 <strong>객체 리터럴을 할당할 때 타입스크립트는 해당 타입의 속성이 있는지 그리고 그외의 속성은 없는지 확인한다.</strong>\n덕 타이핑 관점에서 본다면, 타입스크립트의 해당 타입의 속성만 만족시키면 되는데 왜 이런 현상이 발생할까?</p>\n<pre><code class=\"language-ts\">interface Room {\n  num: number\n  isSuite: boolean\n}\n\nconst r: Room = {\n  num: 10,\n  isSuite: false,\n  elephant: \"present\", //타입 체커 오류 발생. Room 형식에 elephant는 존재하지 않음.\n}\n\nconst r2 = {\n  num: 10,\n  isSuite: false,\n  elephant: \"present\",\n}\n\nconst r3: Room = r2 //오류 발생하지 않음.\n</code></pre>\n<p>위와 같이 객체 리터럴이 아닌, 임시 변수를 도입하면 구조적 타이핑 관점에서 타입이 할당이 가능한 것을 볼 수 있다.</p>\n<p>이러한 시스템이 도입된 이유는 단순히 런타임에 예외를 던지는 코드에 오류를 표시하는 것뿐만 아니라, 의도와 다르게 작성된 코드까지 찾으려고 하기 때문이다. 잉여 속성 체크는 할당 가능 검사와 별도의 과정으로 구조적 타이핑의 개념과 헷갈려서는 안된다.</p>\n<pre><code class=\"language-ts\">interface Options {\n  title: string\n  darkMode: boolean\n}\n\nfunction createWindow(options: Options) {\n  if (options.darkMode) {\n    setDarkMode()\n  }\n}\n\ncreateWindow({ title: \"blahblah\", darkmode: true })\n//타입 체커 오류 발생. darkMode를 쓰려고 했습니까?\n</code></pre>\n<p>위의 코드는 런타임에서 어떠한 오류도 발생시키지 않는다. 하지만 의도한대로 동작하지 않을 수 있다.</p>\n<p>Options 타입에는 실제로 무수히 많은 타입이 할당될 수 있다. document 객체도 할당이 가능하다. <code>title:string</code>속성이 있기 때문이다. <strong>잉여 속성 체크를 이용하면 기본적으로 타입 시스템의 구조적 본질을 해치지 않으면서 객체 리터럴에 알 수 없는 속성을 허용하지 않음으로써, 앞에 예시에서 다룬 문제를 해결할 수 있다.</strong></p>\n<p>만일 잉여 속성 체크를 원하지 않는다면 인덱스 시그니처를 활용하여 추가적으로 속성이 할당될 수 있음을 명시해주시면 된다.</p>\n<h2>약한 타입</h2>\n<p>선택적 속성만 가지는 타입을 약한(weak) 타입이라고 한다.</p>\n<pre><code class=\"language-ts\">interface Animal {\n  hasLeg?: boolean\n  isHerbivores?: boolean\n}\n\nconst elephant = { isBig: true }\n//타입 체크 에러 발생. 공통적인 속성이 없음.\n</code></pre>\n<p>구조적인 관점에서 Animal 타입은 모든 속성이 선택적이므로 모든 객체를 포함할 수 있다. 이런 약한 타입에 대해서 타입스크립트는 값 타입과 선언 타입에 공통된 속성이 있는지 확인하는 별도의 체크를 수행한다. 객체 리터럴에만 수행하는 잉여 속성 체크와 다르게 모든 할당문에서 수행된다. 따라서 임시 변수 패턴을 사용하더라도 공통 속성 체크는 여전히 동작한다.</p>\n<h1>함수 표현식에 타입 적용하기</h1>\n<p>함수를 정의하는 방법은 함수 선언문, 함수 표현식 2가지가 있다. 타입스크립트의 경우 함수 표현식으로 정의하면 좋다. 그 이유는 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용 할 수 있기 때문이다.</p>\n<pre><code class=\"language-ts\">type BinaryFn = (a: number, b: number) => number\nconst sum: BinaryFn = (a, b) => a + b\nconst mul: BinaryFn = (a, b) => a * b\nconst sub: BinaryFn = (a, b) => a - b\n</code></pre>\n<p>위의 예제를 통해서, 재사용성과 함수 타입을 매개변수부터 반환값까지 선언했을 때보다 함수 구현부가 분리되어 있어 로직이 보다 분명해진다는 장점이 있다. 따라서 라이브러리는 공통 ㅏㅎㅁ수 시그니처를 타입으로 제공하기도 한다. 예시로 리액트에서 함수의 매개변수에 명시하는 MouseEvent 타입 대신 함수 전체에 적용할 수 있는 MouseEventHandler 타입을 제공한다.</p>\n<h2>시그니처가 일치하는 다른 함수</h2>\n<p>fetch 함수를 예시로 살펴본다.</p>\n<pre><code class=\"language-ts\">async function getQuote() {\n  const response = await fetch(\"/quote?by=Mark+Twain\")\n  const qutoe = await response.json()\n  return qutoe\n}\n</code></pre>\n<p>위의 예시에서 만일 /quote가 존재하지 않는 API라면 response.json()은 JSON 형식이 아니라는 요상한 오류 메시지를 담아 거절된 프로미스를 반환한다. 이럴 경우 우리는 왜 거절되었는지 이유를 명확히 알 수 없다. 따라서 상태도 체크해주는 새로운 함수를 정의해본다.</p>\n<pre><code class=\"language-ts\">async function checkedFetch(input: RequestInfo, init: ReuqestInit) {\n  const response = await fetch(input, init)\n  if (!response.ok) {\n    throw new Error(response.status)\n  }\n  return response\n}\n</code></pre>\n<p>위의 코드는 아래와 같이 간결하게 고쳐질 수 있다. 함수 표현식에 타입을 적용하면 된다. 다른 함수의 시그니처를 참조하려면 typeof fn을 사용하면 된다.</p>\n<pre><code class=\"language-ts\">const checkedFetchasync: typeof fetch = (input, init) => {\n  const response = await fetch(input, init)\n  if (!response.ok) {\n    throw new Error(response.status)\n  }\n  return response\n}\n</code></pre>\n<p>아래와 같이 적용할 경우 <code>throw new Error(response.status)</code> 부분을 <code>return new Error(response.status)</code>로 변경할 경우 에러도 반환해준다. 반환타입이 fetch와 동일해야하기 떄문이다.</p>\n<h1>타입과 인터페이스의 차이점 알기</h1>\n<p>타입스크립트에서 명명된 타입을 정의하는 방법은 두 가지있다. <code>type</code>(타입 별칭)과 <code>interface</code>이다. <strong>대부분의 경우 타입을 사용해도 되고 인터페이스를 사용해도 된다. 하지만 공통점과 차이점을 명확히 이해하고 같은 상황에서는 동일한 방법으로 명명된 타입을 정의해 일관성을 유지해야한다.</strong></p>\n<p><em>타입에 I혹은 T를 붙여 어떤 형태로 사용되었는지 알려주는 패턴은 초기에는 종종 사용되었으나 현재는 지양해야 할 스타일이다.</em></p>\n<h2>공통점</h2>\n<ol>\n<li>명명된 타입은 어떤 타입으로 정의하던 상태에는 차이가 없다.</li>\n<li>인덱스 시그니처는 인터페이스와 타입에서 모두 사용할 수 있다.</li>\n<li>함수 타입도 인터페이스나 타입으로 정의할 수 있다.\n<pre><code class=\"language-ts\">type TFn = (x: number) => string\ninterface IFn {\n  (x: number): string\n}\n</code></pre>\n</li>\n<li>제너릭 사용이 가능하다.</li>\n<li>클래스를 구현할 때 둘 다 사용할 수 있다.</li>\n</ol>\n<h2>차이점</h2>\n<ol>\n<li>유니온 타입은 있지만, 유니온 인터페이스라는 개념은 없다.</li>\n<li>인터페이스는 타입을 확장(extends)할 수 있지만, 유니온은 할 수 없다.</li>\n<li>튜플과 배열 타입도 타입 별칭을 사용하면 간결하게 표현할 수 있다. 인터페이스로도 튜플과 비슷하게 구현할 수 있지만, concat과 같은 메서드를 사용할 수 없다.</li>\n<li>인터페이스에는 타입에는 없는 보강(augment)이 가능하다.\n<pre><code class=\"language-ts\">interface IState {\n  name: string\n  capital: string\n}\ninterface IState {\n  population: number\n}\nconst wyoming: State = {\n  name: \"Wyoming\",\n  capital: \"Cheyenne\",\n  population: 500000,\n}\n//정상이다.\n</code></pre>\n속성을 확장하는 것을 선언 병합이라고 한다. 선언 병합은 주로 타입 선언 파일에서 사용된다. 따라서 타입 선언 파일을 작성할 때는 선언 병합을 지원하기 위해 반드시 인터페이스를 사용해야 하며 표준을 따라야한다.</li>\n</ol>\n<h2>그렇다면 언제 type, interface를 사용하면 좋을까?</h2>\n<ol>\n<li>복잡한 타입이라면 타입 별칭을 사용하면 된다.</li>\n<li>둘다 표현 가능한 간단한 객체 타입이라면 일관성과 보강의 관점에서 생각해야함.\n<ul>\n<li>기존 프로젝트의 룰에 따른다.</li>\n<li>어떤 API에 대한 타입 선언을 작성해야 한다면 인터페이스가 좋다. 추후에 보강될 여지가 있기 떄문이다.</li>\n</ul>\n</li>\n</ol>\n<h1>타입 연산과 제너릭 사용으로 반복 줄이기</h1>\n<p>코드를 중복하면 안된다. 코드를 중복하면 유지보수 비용이 급격하게 늘어난다. 수정을 할 때 수정이 필요한 요소를 일일이 찾아서 빠짐없이 수정해줘야 하기 때문이다. DRY(Don't Repeat Yourself) 원칙이다.</p>\n<h2>타입 반복을 줄이는 방법들</h2>\n<h3>타입에 이름 붙이기</h3>\n<pre><code class=\"language-ts\">function distance(a: { x: number; y: number }, b: { x: number; y: number }) {\n  return a.x + a.y + b.x + b.y\n}\n\ninterface Point2D {\n  x: number\n  y: number\n}\n\nfunction distance(a: Point2D, b: Point2D) {}\n</code></pre>\n<h3>함수가 같은 타입의 시그니처를 가지고 있을 때</h3>\n<p><a href=\"#%ED%95%A8%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D%EC%97%90-%ED%83%80%EC%9E%85-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0\">예시</a></p>\n<h3>인터페이스 확장을 통한 반복 제거</h3>\n<pre><code class=\"language-ts\">interface Person {\n  firstName: string\n  lastName: string\n}\n\ninterface PersonWithDate {\n  firstName: string\n  lastName: string\n  birth: Date\n}\n\ninterface PersonWithDate extends Person {\n  birth: Date\n}\n\n//이미 존재하는 타입을 확장할 경우(일반적이지는 않음.)\ntype PersonWithDate = Person &#x26; { birth: Date }\n</code></pre>\n<h3>한 타입의 부분 집합인 타입</h3>\n<p>부모 타입을 이용해서 부분 집합 타입을 정의하라.</p>\n<pre><code class=\"language-ts\">interface State {\n  userId: string\n  pageTitle: string\n  recentFiles: string[]\n  pageContents: string\n}\n\ninterface TopNavState {\n  userId: State[\"userId\"]\n  pageTitle: State[\"pageTitle\"]\n  recnetFiles: State[\"recentFiles\"]\n}\n</code></pre>\n<p>매핑된 타입을 이용하는 방식</p>\n<pre><code class=\"language-ts\">type TopNavState = {\n  [k in \"userId\" | \"pageTitle\" | \"recentFiles\"]: State[k]\n}\n</code></pre>\n<p>매핑된 타입은 배열의 필드를 루프 도는 것과 같은 방식이다 이 패턴은 표준 라이브러리의 Pick 제너릭 타입과 동일하다.</p>\n<pre><code class=\"language-ts\">type TopNavState = Pick&#x3C;State, \"userId\" | \"pageTitle\" | \"recentFiles\">\n</code></pre>\n<p><strong>생성하고 난 다음에 업데이트가 되는 클래스의 경우, 타입 대부분이 선택적 필드가 된다.</strong></p>\n<pre><code class=\"language-ts\">interface Options {\n  width: number\n  height: number\n  color: string\n  label: string\n}\n\ninterface OptionsUpdate {\n  width?: number\n  height?: number\n  color?: string\n  label?: string\n}\n</code></pre>\n<p>매핑된 타입과 keyof를 사용하여 중복을 제거</p>\n<pre><code class=\"language-ts\">type OptionsUpdate = { [k in keyof Options]?: Options[k] }\n</code></pre>\n<p>매핑된 타입은 순회하며 Options 내 k 값에 해당하는 속성이 있는지 찾는다. 표준 라이브러리의 Partial 제너릭과 동일하다.</p>\n<pre><code class=\"language-ts\">type OptionsUpdate = Partial&#x3C;Options>\n</code></pre>\n<h3>값 형태에 해당하는 타입을 정의하고 싶을 때</h3>\n<pre><code class=\"language-ts\">const INIT_OPTIONS = {\n  width: 640,\n  height: 480,\n  color: \"#00FFD\",\n  label: \"VGA\",\n}\n\ninterface Options {\n  width: number\n  height: number\n  color: string\n  label: string\n}\n\ntype Options = typeof INIT_OPTIONS\n</code></pre>\n<p>여기서 typeof는 자바스크립의 연산자 typeof로 사용된 것으로 보이지만, 실제로는 타입스크립트 단계에서 연산되고 정교하게 타입을 표현한다. 값으로부터 타입을 만들어 낼 때 선언의 순서에 주의해야한다. 타입 정의를 먼저하고 값이 그 타입에 할당 가능하다고 선언하는 것이 좋다.</p>\n<p>함수나 메소드의 반환 값에 명명된 타입을 만들고 싶을 때</p>\n<pre><code class=\"language-ts\">function getUserInfo(userId: string) {\n  //.....\n  return {\n    userId,\n    name,\n    age,\n    height,\n    width,\n  }\n}\n\ntype UserInfo = ReturnType&#x3C;typeof getUserInfo>\n</code></pre>\n<p>ReturnType을 사용할 때 유의해야 할 점은 getUserInfo의 값이 아니라, typeof로 타입을 적용시켰다는 점이다.</p>\n<h3>제너릭 타입에서 매개변수를 제한하고 싶을 때</h3>\n<p>extends를 사용하면 된다. extends를 사용하면 제너릭 매개변수가 특정 타입을 확장한다고 선언할 수 있다.</p>\n<pre><code class=\"language-ts\">interface Name {\n  first: string\n  last: string\n}\n\ntype DancingDuo&#x3C;T extends Name> = [T, T]\n\nconst couple1: DancingDuo&#x3C;Name> = [\n  { first: \"Fred\", last: \"Artster\" },\n  { first: \"Ginager\", last: \"Rogers\" },\n]\n\nconst couple2: DancingDuo&#x3C;{ first: string }> = [\n  //...,\n  //...\n]\n//{first:string}에는 last 속성이 없어서 오류가 발생한다. extends 구문으로 확장한다고 선언했기 때문에 last가 꼭 필요함.\n</code></pre>\n<h1>동적 데이터에 인덱스 시그니처 사용하기</h1>\n<p>자바스크립트 객체는 문자열 키를 타입의 값에 관계없이 매핑한다. 타입스크립트에서는 타입에 인덱스 시그니처를 명시하여 유연하게 매핑을 표현할 수 있다.</p>\n<pre><code class=\"language-ts\">type Obj = { [property: string]: string }\n</code></pre>\n<p>위와 같은 방식이 인덱스 시그니처이다. 다음 3가지 의미를 담는다.</p>\n<ol>\n<li>키의 이름: 키의 위치만 표시하는 용도. 타입 체커에서는 사용되지 않음.</li>\n<li>키의 타입: string | number | symbol 조합이지만, 보통은 string 사용</li>\n<li>값의 타입: 어떤 값이든 될 수 있음.</li>\n</ol>\n<h2>인덱스 시그니처의 단점</h2>\n<ol>\n<li>잘못된 키를 포함해 모든 키를 허용한다. 만약 name이라는 속성이 필요한 객체임에도 불구하고 Name이라는 속성을 기입해도 타입 체크 오류가 발생하지 않는다.</li>\n<li>특정 키가 필요하지 않다. {}도 인덱스 시그니처 타입이다.</li>\n<li>키마다 다른 타입을 가질 수 없다.</li>\n<li>타입스크립트 언어 서비스의 기능이 일부 동작하지 않는다. name:을 입력할 때 키는 무엇이든 가능하기 때문에 자동완성안됨.</li>\n</ol>\n<h2>언제 인덱스 시그니처를 사용하고 사용하지 말아야 하는가?</h2>\n<p>인덱스 시그니처는 부정확하다. 만일 객체의 모든 속성이 string이라서 인덱스 시그니처를 사용한다면 이는 잘못된 것이다. <strong>인덱스 시그니처는 동적 데이터를 표현할 때 사용해야 한다.</strong></p>\n<p>예시로 CSV 파일처럼 헤더 행에 열 이름이 있고, 데이터 행을 열 이름과 값으로 매핑하는 객체로 나타내고 싶은 경우이다.</p>\n<p><em>declare 키워드는 컴파일러에게 해당 변수나 함수가 이미 존재한다고 알리는 역할을 한다.</em></p>\n<p><strong>어떤 타입에 가능한 필드가 제한되어 있는 경우라면 인덱스 시그니처로 모델링하면 안된다.</strong></p>\n<p>만일 객체에 a,b,c,d와 같은 키가 있지만 얼마나 많이 있는지 모른다면 선택적 필드 또는 유니온 타입으로 모델링 해야한다.</p>\n<pre><code class=\"language-ts\">interface Row1 {\n  [column: string]: number\n}\ninterface Row2 {\n  a: number\n  b?: number\n  c?: number\n  d?: number\n}\ntype Row3 =\n  | { a: number }\n  | { a: number; b: number }\n  | { a: number; b: number; c: number }\n  | { a: number; b: number; c: number; d: number }\n</code></pre>\n<p>마지막 Row3의 방식의 경우 정확하지만, 사용하기에는 조금 번거롭다.\n우리는 2가지 옵션이 존재한다.</p>\n<ol>\n<li>\n<p>Record 제너릭 타입 사용</p>\n<ul>\n<li>키 타입에 유연성을 제공하는 제너릭 타입이다.</li>\n</ul>\n<pre><code class=\"language-ts\">type Vec3D = Record&#x3C;'x' | 'y' | 'z', number>\n&#x3C;!-- Vec3D = {\n  x: number\n  y:number\n  z:number\n} -->\n</code></pre>\n</li>\n<li>\n<p>매핑된 타입 사용</p>\n<pre><code class=\"language-ts\">type Vec3D = { [k in \"x\" | \"y\" | \"z\"]: number }\ntype ABC = { [k in \"a\" | \"b\" | \"c\"]: k extends \"b\" ? string : number }\n// ABC = {\n//   a:number\n//   b:string\n//   c: number\n// }\n</code></pre>\n</li>\n</ol>\n<h1>number 인덱스 시그니처보다는 Array, 튜플, ArrayLike 사용하기</h1>\n<p>자바스크립트의 객체는 문자열을 키값으로 사용한다. 만일 문자열이 아닌 것을 키값으로 할당하면 .toString 메소드를 사용하여 문자열로 변환된다.</p>\n<pre><code class=\"language-ts\">x = {}\nx[[1, 2, 3]] = 2\n//x: '1,2,3' = 2\n//[1,2,3]이 toString으로 문자열로 변환됨.\n</code></pre>\n<p>자바스크립트에서 배열은 객체이다. 배열에서 인덱스에 접근하기 위해서 숫자로 된 키를 사용하지만, 내부에서 문자열로 변환되어 사용된다.</p>\n<pre><code class=\"language-ts\">const arr = [1, 2, 3]\narr[0] // 1\narr[\"0\"] //1\n</code></pre>\n<p>타입스크립트는 이러한 혼란을 막기위해 숫자 키를 허용하고, 문자열 키와는 다른 것으로 인식한다.</p>\n<p>인덱스 시그니처에 number를 사용하기 보다는 Array나 튜플, 또는 ArrayLike 타입을 사용하는 것이 좋다.</p>\n<h1>변경 관련된 오류 방지를 위해 readonly 사용하기</h1>\n<p>함수가 매개변수를 수정하지 않는다면, readonly로 설정하는 것이 좋다. 매개변수의 비의도적인 변경을 방지할 수 있다.</p>\n<p>readonly는 얕게 동작한다. 깊게 동작을 원한다면 ts-essentials에 있는 DeepReadonly 제네릭을 사용하면 된다.</p>\n<h1>매핑된 타입을 사용하여 값 동기화하기.</h1>\n<p>매핑된 타입을 사용해서 관련된 값과 타입을 동기화 할 수 있다.</p>\n<p>만일 이전 객체와 현재 객체를 비교하여 다르다면 업데이트를 수행해야 하는 상황인데, 효율성을 위해서 특정 속성의 차이만 비교한다고 해보자. 그렇다면 속성이 추가될 때마다 해당 속성이 특정 속성에 해당하는지 안하는지 코드를 작성해줘야 할 것이다. 매핑된 타입을 사용하면, 타입 시스템을 활용하여 안전하게 유지보수 할 수 있다.</p>\n<pre><code class=\"language-ts\">interface ScatterProps {\n  xs: number[]\n  ys: number[]\n  xRange: [number, number]\n  yRange: [number, number]\n  color: string\n  onClick: (x: number, y: number, index: number) => void\n}\n\nconst REQUIRES_UPDATE: { [k in keyof ScatterProps]: boolean } = {\n  xs: true,\n  ys: true,\n  xRange: true,\n  yRange: true,\n  color: true,\n  onClick: true,\n}\n\nfunction shouldUpdate(oldProps: ScatterProps, newProps: ScatterProps) {\n  let k: keyof ScatterProps\n  for (k in oldProps) {\n    if (oldProps[k] !== newProps[k] &#x26;&#x26; REQUIRES_UPDATE[k]) {\n      return true\n    }\n  }\n  return false\n}\n</code></pre>\n<p>이후에 만일 ScatterProps에 어떤 속성이 추가된다면, REQUIRES_UPDATE 해당 속성이 없다고 타입 시스템에 오류가 발생할 것이다.</p>","id":"4f71d23a-e4d0-5efb-a1b0-e52d6c4f76bd"},"next":{"fields":{"slug":"/programming/이펙티브타입스크립트/3장/"},"excerpt":"타입 추론 타입스크립트는 타입 추론을 적극적으로 수행한다. 타입 구문의 수를 엄청나게 줄여주기에 코드의 전체적인 안정성이 향상된다. 숙련된 타입스크립트 개발자는 비교적 적은 수의 구문을 사용한다. 추론 가능한 타입을 사용해 장황한 코드 방지하기 위의 예시에서 a에 굳이 number라는 타입을 명시해줄 필요가 없다. 타입스크립트에서 자동으로 추론해주기 때문이다. 객체의 경우 객체의 경우에도, 타입 추론이 의도한 타입과 동일하다면 굳이 타입을 명…","frontmatter":{"date":"2022-11-01T00:00:00.000Z","description":"타입 추론","title":"이펙티브 타입스크립트 3장"},"html":"<h1>타입 추론</h1>\n<p>타입스크립트는 타입 추론을 적극적으로 수행한다. 타입 구문의 수를 엄청나게 줄여주기에 코드의 전체적인 안정성이 향상된다. 숙련된 타입스크립트 개발자는 비교적 적은 수의 구문을 사용한다.</p>\n<h1>추론 가능한 타입을 사용해 장황한 코드 방지하기</h1>\n<pre><code class=\"language-ts\">const a: number = 3\n</code></pre>\n<p>위의 예시에서 a에 굳이 number라는 타입을 명시해줄 필요가 없다. 타입스크립트에서 자동으로 추론해주기 때문이다.</p>\n<h2>객체의 경우</h2>\n<p>객체의 경우에도, 타입 추론이 의도한 타입과 동일하다면 굳이 타입을 명시해줄 필요가 없다.</p>\n<pre><code class=\"language-ts\">interface Person {\n  name: string\n  born: {\n    where: string\n    when: string\n  }\n}\nconst person: Person = {\n  name: \"sssdf\",\n  born: {\n    where: \"Seoul\",\n    when: \"2000-11-01\",\n  },\n}\n</code></pre>\n<p>person 객체만 정의하면 Person과 같은 타입이 자동으로 추론된다. 하지만 만일 객체 리터럴을 정의할 때 잉여속성 체크를 하고 싶다면 꼭 타입을 명시해야한다. 잉여속성 체크를 함으로써, 객체가 사용되는 쪽의 코드에서 문제가 발생하는 것이 아니고, 객체가 정의된 곳에서 문제가 발생되어 문제를 쉽게 파악할 수 있다.</p>\n<h2>리팩토링을 쉽게</h2>\n<p>타입이 추론되면 리팩토링도 쉽게 할 수 있다. 어떻게 보면 기존에 정의된 타입을 이용한다는 것으로 받아들이면 된다.</p>\n<pre><code class=\"language-ts\">interface Product {\n  id: number\n  name: string\n  price: number\n}\n\nfunction logProduct(product: Prodcut) {\n  const id: number = product.id\n  const name: string = product.name\n  const price: number = product.price\n}\n</code></pre>\n<p>위의 예시에서 만일 id가 number 타입이 아닌 string 타입으로 변경되면 logProduct의 함수 const id 부분이 타입 에러가 발생할 것이다. 위와 같은 경우에는 비구조화 할당문으로 리팩토링 해주는게 좋다. 모든 지역 변수의 타입 추론이 되도록 하기 때문이다.</p>\n<pre><code class=\"language-ts\">function logProduct(product: Product) {\n  const { id, name, price } = product\n}\n</code></pre>\n<h2>함수</h2>\n<p>타입 정보가 있는 라이브러리에서 콜백 함수의 매개변수 타입은 자동으로 추론된다. express HTTP 서버 라이브러리를 사용하는 request와 response 타입 선언은 필요하지 않는다.</p>\n<p>함수의 반환에 타입을 명시하면 객체 리터럴에 타입을 명시하는 것과 유사하게 사용되는 쪽의 코드에서 문제가 발생한 곳이 아니고, 구현부에서 문제를 발견할 수 있다.</p>\n<pre><code class=\"language-ts\">const cache: { [ticker: string]: number } = {}\nfunction getQuote(ticker: string) {\n  if (ticker in cache) {\n    return cache[ticker]\n    //number\n  }\n  return fetch(\"...\")\n    .then(response => response.json())\n    .then(quote => {\n      cache[ticker] = quote\n      return quote\n    })\n  //promise\n}\n</code></pre>\n<p>위의 getQuote 함수는 if 구문에서는 number 타입을, fetch에서는 Promise를 리턴하기 때문에 프로미스가 사용되는 부분에서 타입 에러를 발생한다. 해당 문제를 해결하기 위해서는 cache[ticker]를 반환하는게 아닌, Promise.resolve(cache[ticker])를 반환해야한다.</p>\n<p>또한 함수의 반환값에 타입을 명시하면, 해당 타입을 보고 직관적으로 함수를 이해할 수 있다.</p>\n<pre><code class=\"language-ts\">type Vector2D = { x: number; y: number }\nfunction add(a: Vector2D, b: Vector2D) {\n  return { x: a.x + b.x, y: a.y + b.y }\n}\n</code></pre>\n<p>위의 add 함수는 <code>{x:number, y:number}</code> 타입으로 추론할 것이다. 하지만 Vector2D가 들어갔는데, 해당 타입이 나온다는게 개발자 입장에서는 혼란스러울 수 있다. 이럴 때 타입을 명시해주면 혼란을 줄일 수 있다.</p>\n<h1>다른 타입에는 다른 변수 사용하기</h1>\n<pre><code class=\"language-ts\">let id = \"123\"\nfetchProduct(id) // string\n\nid = 123\nfetchProductByNumber(id) //number\n</code></pre>\n<p>자바스크립트에서는 위의 패턴이 허용된다. 하지만 타입스크립트에서는 id에 string 타입이 할당되었기 때문에 그 다음에 number 타입을 할당할 수 없어 오류가 발생한다.</p>\n<pre><code class=\"language-ts\">let id: string | number = \"123\"\n</code></pre>\n<p>위와 같이 유니온 타입으로 타입을 좁혀서 정의하면 코드는 동작한다. 하지만 id를 사용할 때마다 number인지 string인지 확인해야 하기 때문에, 간단한 타입에 비해 다루기 어렵다.\n<strong>따라서 위의 경우에는 변수를 분리한다!</strong>\n변수를 분리하면 더 정확한 변수명을 지을 수 있고, const로 변수를 선언하여 코드 안정성을 향상 시킬 수 있다.</p>\n<h1>타입 넓히기</h1>\n<p>상수를 사용해서 변수를 초기화 할 때 타입을 명시하지 않으면 타입 체커는 타입을 스스로 결정해야 한다. 지정된 단일 값으로 할당 가능한 값들의 집합을 유추해야 한다는 의미이다. 이러한 과정을 타입 넓히기(widening)라고 부른다.</p>\n<pre><code class=\"language-ts\">function onlyGetABC(abc: \"a\" | \"b\" | \"c\") {\n  //...\n}\n\nlet A = \"a\"\nonlyGetABC(A)\n//타입체크 에러 발생\n</code></pre>\n<p>위의 경우 변수 A의 경우 \"a\"라고 정의하였지만, 타입 체커는 타입을 string으로 배치하였다. 타입을 넓혀야 하기 때문이다. 그리고 <code>onlyGetABC</code>는 string이 아닌 <code>\"a\"</code>를 매개변수로 받기 때문에 타입 에러가 발생한다.</p>\n<pre><code class=\"language-ts\">const mixed = [\"x\", 1]\n</code></pre>\n<p>위의 경우 나올 수 있는 경우의 수가 매우 많다. 타입 시스템은 작성자의 의도를 추측하지만, 아무리 영리하더라도 사람의 마음까지는 읽을 수 없다. 위의 경우 작성자는 튜플로 추론되기를 바랬으나 <code>(string|number)[]</code>으로 추론된다.</p>\n<h2>넓히기를 제어하는 방법</h2>\n<h3>let 대신 const로 선언하기.</h3>\n<p>let 대신 const로 선언하면 더 좁은 타입이 된다.</p>\n<pre><code class=\"language-ts\">const A = \"a\"\nonlyGetABC(A)\n//정상\n</code></pre>\n<p>위의 예시에서 A는 <code>\"a\"</code>로 추론된다.\n그러나 const는 만능이 아니다. 객체와 배열의 경우에는 여전히 문제가 존재한다.</p>\n<p>객체의 경우 타입스크립트의 넓히기 알고리즘은 각 요소를 let으로 할당된 것으로 다룬다. 그리고 다른 속성을 추가하지 못한다.</p>\n<h3>명시적 타입 구문을 제공하기</h3>\n<pre><code class=\"language-ts\">const v: {x:1|2|3} {\n  x:1\n}\n</code></pre>\n<h3>타입 체커에 추가적인 문맥을 제공하는 것</h3>\n<p>이후 아이템에서 다룬다고함.</p>\n<h3>const 단언문 사용</h3>\n<p>const로 변수를 선언하는 것과 다른 의미이다.\n값 뒤에 as const를 작성하면 타입스크립트는 최대한 좁은 타입으로 추론한다. 배열을 튜플 타입으로 추론할 때에도 as const를 사용할수 있다.</p>\n<h1>타입 좁히기</h1>\n<p>타입 넓히기의 반대 개념이다. 대표적인 예시는 null 체크이다.</p>\n<pre><code class=\"language-ts\">const el = document.getElementById(\"foo\")\nif (el) {\n  el.innerHTML = \"hello\"\n} else {\n  alert(\"no element\")\n}\n</code></pre>\n<p>위의 예시에서는 분기 처리를 통해 el의 타입이 HTMLElement임을 확인하였다.</p>\n<h2>타입 좁히기 종류</h2>\n<ol>\n<li>\n<p>instanceof를 사용</p>\n</li>\n<li>\n<p>내장 함수(Array.isArray 등)</p>\n</li>\n<li>\n<p>조건문</p>\n<ul>\n<li>\n<p>조건문을 통해서 타입을 좁힐 때는 유의해주어야 한다.</p>\n<pre><code class=\"language-ts\">function foo(x?: number | string | null) {\n  if (!x) {\n  }\n}\n</code></pre>\n<p>위의 예시의 경우 0, '' 모두 falsy이기 때문에 타입이 전혀 좁혀지지 않았다.</p>\n<pre><code class=\"language-ts\">const el = document.getElementById(\"foo\")\nif (typeof el === \"object\") {\n}\n</code></pre>\n<p>위의 예시도 문제는 object도 null이기 떄문에 타입이 좁혀지지 않았다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>명시적 태그를 붙이는 방법</p>\n<ul>\n<li>객체 내에 type 속성을 넣어주고 값을 넣어주는 패턴 등이 존재한다.</li>\n<li>태그된 유니온, 구별된 유니온이라고 불린다.</li>\n</ul>\n</li>\n<li>\n<p>커스텀 함수 도입</p>\n<pre><code class=\"language-ts\">function isInputElement(el: HTMLElement): el is HTMLInputElement {\n  return \"value\" in el\n}\n\nfunction getElementContent(el: HTMLElement) {\n  if (isInputElement(el)) {\n    return el.value\n  }\n  return el.textContent\n}\n</code></pre>\n<ul>\n<li>위와 같은 패턴을 사용자 정의 타입 가드라고 한다.</li>\n</ul>\n<pre><code class=\"language-ts\">const member = [\"a\", \"b\", \"c\", \"d\"]\nconst people = [\"a\", \"e\"]\n\nconst onlyMember = people.map(who => member.find(v => v === who))\n//(string | undefined)[]\n\nconst filteredOnlyMember = people\n  .map(who => member.find(v => v === who))\n  .filter(who => who !== undefined)\n//(string | undefined)[]\n</code></pre>\n<p>위의 경우 filteredOnlyMember 변수도 (string | undefined)[]이다. 이럴 때 타입 가드를 사용하면 타입을 좁힐 수 있다.</p>\n<pre><code class=\"language-ts\">function isDefined&#x3C;T>(x: T | undefined): x is T {\n  return x !== undefined\n}\n\nconst filteredOnlyMember = people\n  .map(who => member.find(v => v === who))\n  .filter(isDefined)\n//string[]\n</code></pre>\n</li>\n</ol>\n<h1>한꺼번에 객체 생성하기</h1>\n<p>자바스크립트의 값은 변경되지만 일반적으로 타입스크립트의 타입은 변경되지 않는다. 객체를 생성할 때는 속성을 하나씩 추가하는 것보다는 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리하다.</p>\n<pre><code class=\"language-ts\">const pt = {}\npt.x = 3\npt.y = 5\n//타입 체크 오류 발생.. {} 형식에 x가 존재하지 않습니다.\n</code></pre>\n<p>아래와 같은 패턴으로 정의하면 오류가 발생하지 않는다.</p>\n<pre><code class=\"language-ts\">const pt = { x: 3, y: 5 }\n</code></pre>\n<p>객체를 반드시 제각각 나눠서 만들어야 한다면 타입 단언문을 사용해야한다.</p>\n<pre><code class=\"language-ts\">interface Point {\n  x: number\n  y: number\n}\nconst pt = {} as Point\npt.x = 3\npt.y = 5\n</code></pre>\n<h2>전개 연산자</h2>\n<p>객체를 합칠 때는 전개 연산자를 사용한다.</p>\n<pre><code class=\"language-ts\">const pt = { x: 3, y: 4 }\nconst id = { name: \"pythagoras\" }\nconst namedPoint = {}\nObject.assign(namedPoint, pt, id)\nnamedPoint.name\n//타입 에러 발생.. name 속성이 없다.\n\nconst namedPoint = { ...pt, ...id }\nnamedPoint.name\n</code></pre>\n<h3>조건부 속성</h3>\n<pre><code class=\"language-ts\">declare let hasMiddle: boolean\nconst firstLast = { first: \"harry\", last: \"potter\" }\nconst president = { ...firstLast, ...(hasMiddle ? { middle: \"S\" } : {}) }\n</code></pre>\n<p>위의 예시에는 middle이 선택적 속성을 가지는 것으로 추론된다.</p>\n<p>만일 전개 연산자로 여러 속성을 추가하면 어떻게 될까? 이때는 유니온 속성으로 추론된다. 속성이 함께 정의되기 때문에 유니온을 사용하는게 값의 집합을 더 정확히 표현할 수 있기 때문이다.</p>\n<p>유니온 방식이 아닌, 선택적 필드로 만들고 싶다면 헬퍼 함수를 사용해야한다.</p>\n<pre><code class=\"language-ts\">function addOptional&#x3C;T extends object, U extends object>(\n  a: T,\n  b: U | null\n): T &#x26; Partial&#x3C;U> {\n  return { ...a, ...b }\n}\n</code></pre>\n<p><strong>객체나 배열을 변환해서 새롤운 객체나 배열을 생성하고 싶다면 루프 대신 내장된 함수형 기법 또는 로대시 같은 유틸리티 라이브러리를 만드는게 한꺼번에 객체 생성하기 관점에서 옳다.</strong></p>\n<h1>일관성 있는 별칭 사용하기</h1>\n<pre><code class=\"language-ts\">const person = {\n  age: 20,\n  name: \"jinwook\",\n  location: { City: \"Seoul\", State: \"gdd\" },\n}\nconst loc = person.location\n</code></pre>\n<p>위의 loc 변수가 별칭이다. 별칭의 속성값을 변경하면 원본 객체의 속성값도 변경한다. 따라서 별칭을 남발하면 제어 흐름을 파악하기 어렵다.</p>\n<p>만일 location의 분기를 여러번 나눠야되는 로직이 있다면 우리는 location 별칭을 사용해서 코드를 짧게 유지할 것이다.</p>\n<pre><code class=\"language-ts\">function saveLocation1(person) {\n  if (person.location) {\n  }\n  //...\n}\n\nfunction saveLocation2(person) {\n  const personLocation = person.location\n  if (person.location) {\n    fn(personLocation)\n    //error 발생.. personLocation은 null일 수 있음.\n    //...\n  }\n}\n\nfunction saveLocation3(person) {\n  const { location } = person\n  if (location) {\n    //...\n  }\n}\n</code></pre>\n<p>saveLocation2의 경우 객체의 속성을 별칭으로 정의했다. 하지만 아래 분기에서는 <code>person.location</code>을 확인하였고 <code>personLocation</code>은 확인하지 않았다. <code>person.location</code>은 <code>null</code>이 사라져 타입이 좁혀졌으나 <code>personLocation</code>은 그대로이다. 별칭을 사용할 것이면 일관성있게 <code>saveLocation3</code>처럼 사용해야한다. 또한 비구조화 할당을 사용해서 일관된 이름을 사용하면 더더욱 좋다.</p>\n<h2>별칭으로 인한 혼동</h2>\n<pre><code class=\"language-ts\">const { bbox } = polygon\nif (!bbox) {\n  caculatePolygonBbox(polygon)\n}\n</code></pre>\n<p>위의 예시에서 bbox와 polygon.bbox는 이제 다른 값을 참조한다..! bbox의 경우 비구조화 할당으로 인해 새로운 변수에 넣었기 때문이다.</p>\n<pre><code class=\"language-ts\">function fn(p: Polygon) {}\n\npolygon.bbox //BoundingBox | undefined\n\nif (polygon.bbox) {\n  fn(polygon)\n  polygon.bbox //BoundingBox\n}\n</code></pre>\n<p>위의 예시에서 fn은 polygon의 bbox 속성을 제거할 수도 있다. 하지만 타입은 그대로 유지된다. 타입스크립트에서 함수가 타입 정제를 무효화하지 않는다고 가정하기 때문이다. 따라서 위의 경우에는 비구조화 할당을 사용해서 새로운 지역변수를 정의하면 타입은 정확히 유지되지만 원본값은 변함이 없는 장점을 누릴 수 있다.</p>\n<h1>비동기 코드에는 콜백 대신 async 함수 사용하기</h1>\n<p>콜백보다는 프로미스, async 함수를 사용하는 것이 코드도 간결하며 타입을 추론하기 쉽다.\n선택의 여지가 있다면 프로미스 보다는 async를 사용하는게 좋다.</p>\n<ol>\n<li>코드가 더 간결하고 직관적이다.</li>\n<li>항상 프로미스를 반환한다.</li>\n</ol>\n<p>async 함수에서 프로미스를 반환하면 또 다른 프로미스로 래핑되지 않는다. Promise&#x3C;<T>>가 아닌 Promise<T>를 반환한다.</p>\n<h1>타입 추론에 문맥이 어떻게 사용되는지 이해하기</h1>\n<pre><code class=\"language-ts\">type Lanuage = \"JavaScript\" | \"TypeScript\"\nfunction setLanuage(lanuage: Lanuage) {\n  //...\n}\n\nsetLanuage(\"JavaScript\") //1\nlet js = \"JavaScript\"\nsetLanuage(js) //2\n</code></pre>\n<p>위의 예시에서 첫 번째로 호출한 함수의 경우 에러가 발생하지 않지만, 두 번째로 호출한 함수의 경우 에러가 발생한다. 이 문제를 해결할 수 있는 방법은 2가지이다.</p>\n<ol>\n<li>타입 선언\n<pre><code class=\"language-ts\">let js: Lanuage = \"JavaScript\"\n</code></pre>\n</li>\n<li>js를 상수로 만드는 것이다.\n<pre><code class=\"language-ts\">const js = \"JavaScript\"\n</code></pre>\n</li>\n</ol>\n<h2>튜플 사용 시 주의 점</h2>\n<pre><code class=\"language-ts\">function panTo(where: [number, number]) {}\n\npanTo([10, 10])\nconst loc = [10, 10]\npanTo(loc)\n</code></pre>\n<p>위의 예시의 경우 loc를 상수로 선언했음에도 불구하고 타입 에러가 발생한다. 그 이유는 loc를 <code>number[]</code>로 추론했기 때문이다. 이 경우도 위와 유사하다. 타입 선언을 하거나 상수로 정의해준다.</p>\n<pre><code class=\"language-ts\">const loc = [10, 10] as const\n</code></pre>\n<p>기존에 const는 참조값이 바뀌지 않는 것이였는데, as const로 정의하면 내부까지 상수라는 사실을 타입스크립트에게 알려준다.</p>\n<p>하지만 위의 코드는 또 문제가 있다. loc의 경우 readonly 상태를 가지게 되는데, panTo가 매개변수의 내용이 불변을 보장하지 못하는 것이다. panTo의 매개변수에 readonly 키워드를 적용해줌으로써 해당 문제를 해결할 수 있다.</p>\n<p>as const를 사용할 때 유의해야 하는 점은 타입 정의에 실수가 있다면 타입이 정의되는 곳이 아닌, 호출되는 곳에서 발생한다는 것을 유의해야한다.</p>\n<h1>함수형 기법과 라이브러리로 타입 흐름 유지하기</h1>\n<p>자바스크립트에서는 서드파티 라이브러리의 도입을 신중해야한다. 타입을 알 수 없기 때문에 서드파티 라이브러리를 사용해서 코드를 줄이는데 시간이 오래들기 때문이다. 반면에 타입스크립트는 타입이 명시되어있어 서드파티 라이브러리 도입에 큰 문제가 없다. 서드파티 라이브러리를 활용해서 생산성을 높이는 편이 낫다.</p>","id":"28051e14-adc7-5f08-908e-62ff60528369"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}