{"componentChunkName":"component---src-templates-post-template-tsx","path":"/tech/node.js/","result":{"pageContext":{"node":{"fields":{"slug":"/tech/node.js/"},"excerpt":"Node.js란 Node.js는 Chrome의 V8 엔진으로 빌드된 자바스크립트 런타임이다. 기존에 자바스크립트는 브라우저에서만 구동 가능한 언어였다. 구글이 매우 빠른 자바스크립트 엔진인 V8을 출시하자 이를 바탕으로 브라우저 외 환경에서 자바스크립트 런타임을 구축하기 시작했다. 이벤트 기반 이벤트 기반이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미한다. 예시로 클릭이나 네트워크 요청 등이 있을 수 있다. 논 블로킹 논 …","frontmatter":{"date":"2022-10-19T00:00:00.000Z","description":"Node.js, Express, MongoDB란?","title":"Node.js, Express, MongoDB"},"html":"<h1>Node.js란</h1>\n<p>Node.js는 Chrome의 V8 엔진으로 빌드된 자바스크립트 런타임이다. 기존에 자바스크립트는 브라우저에서만 구동 가능한 언어였다. 구글이 매우 빠른 자바스크립트 엔진인 V8을 출시하자 이를 바탕으로 브라우저 외 환경에서 자바스크립트 런타임을 구축하기 시작했다.</p>\n<h2>이벤트 기반</h2>\n<p>이벤트 기반이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미한다. 예시로 클릭이나 네트워크 요청 등이 있을 수 있다.</p>\n<h2>논 블로킹</h2>\n<p>논 블로킹이란 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행함을 뜻한다. 반대로 블로킹이란 이전 작업이 끝나야만 다음 작업을 수행하는 것을 의미한다. 논 블로킹 방식은 모든 작업이 동시에 처리될 수 있다는 전제하에 블로킹 방식보다 훨씬 빠르다. (ex. 시간이 오래 걸리는 블로킹 코드를 setTimeout으로 묶어 백그라운드에서 처리하도록 함.)</p>\n<h2>싱글 스레드</h2>\n<p>엄밀히 말하자면 싱글 스레드로 동작하지 않는다. 노드를 실행하면 프로세스를 하나 생성하고, 해당 프로세스에서 스레드들을 생성하는데 내부적으로 스레드를 여러개 생성한다. 그중에서 우리가 제어할 수 있는 스레드는 하나이기에 싱글 스레드라고 여겨진다. Node.js는 싱글 스레드 논블로킹 방식으로 움직이기 때문에 매우 효율적으로 일처리가 가능하고 멀티 스레드에 비해서 프로그래밍이 비교적 쉽다는 장점이 있다. (워커 스레드라는 기능을 사용하면 멀티 스레드 구현이 가능하다. 스레드풀의 경우는 자동으로 멀티스레드를 사용한다. 암호화, 파일 입출력 등 작업에서 사용된다.)</p>\n<h2>그렇다면 언제 Node.js를 사용하면 좋을까?</h2>\n<p>노드는 싱글 스레드, 논블로킹 모델로 사용하므로 해당 모델의 장단점과 크게 다르지 않다.\n서버는 기본적으로 I/O를 많이 수행하는데 노드는 많은 양의 I/O 작업을 논블로킹 모델로 효율적으로 처리할 수 있다. 하지만 CPU 부하가 큰 작업에는 적합하지 않다. 스레드 하나가 혼자서 감당하기 어렵기 때문이다. 정리를 하자면, 개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는 데 적합하다. 네트워크, 데이터베이스, 디스크 작업 같은 I/O에 특화되어 있기 때문이다. 예시로 실시간 채팅 어플리케이션, 주식 차트, JSON 데이터를 제공하는 API 서버가 노드를 많이 사용한다.</p>\n<p>싱글 스레드 방식의 프로그래밍은 러닝 커브가 멀티 스레드 방식보다 상대적으로 낮다. 하지만 싱글 스레드의 경우 하나뿐인 스레드가 오류가 발생하면 멈추기 때문에 잘 관리하도록 해야한다.</p>\n<h1>Express란</h1>\n<p>Express는 웹 서버 프레임워크이다. 웹 서버를 구성하기 위해서 많은 편의 기능들이 내장되어 있다.\n대표적으로 미들웨어와 라우팅이라는 장점이 있다.</p>\n<p>Express의 핵심은 미들웨어라고 해도 과언이 아니다. 뒤에 나오는 라우터도 미들웨어의 일종이다. 미들웨어를 통해 요청과 응답에 다양한 기능을 추가할 수 있다. 로그인 여부 체크 등..</p>\n<p>라우팅의 경우 http 모듈을 사용해서 처리하려면, 굉장히 많은 분기가 필요하지만 Express 라우팅 기능을 사용하면 손쉽게 가능하다.</p>\n<h1>MongoDB란?</h1>\n<p>MongoDB는 NoSQL 데이터베이스로 자바스크립트 문법을 사용한다는 특징이 있다. MongoDB를 사용하면 자바스크립트만으로 웹 애플리케이션을 구축할 수 있다.</p>\n<h2>NoSQL, SQL 특징</h2>\n<p>NoSQL에는 고정된 테이블이 없다. SQL의 경우 테이블을 만들 때, 칼럼과 자료형, 옵션 등을 정의하지만 몽고디비는 컬렉션을 만들면 끝이다. 어떠한 데이터든 들어갈 수 있다.</p>\n<p>MongoDB는 MySQL과 달리 JOIN 기능이 없다. 흉내를 낼수는 있지만, 하나의 쿼리로 여러 테이블을 합치는 작업이 항상 가능하지는 않다.</p>\n<p>몽고디비의 가장 큰 장점은 확장성과 가용성이다. 데이터의 일관성을 보장해주는 기능이 약한 대신, 데이터를 빠르게 넣을 수 있고 여러 서버에 데이터를 쉽게 분산시킬 수 있다.</p>\n<p>어플리케이션에 꼭 한가지 데이터베이스만 써야되는 것은 아니다. 상황에 맞게 올바른 데이터베이스를 선택하면 된다. 데이터의 일관성이 필요한 항공 예약의 경우는 MySQL로, 채팅 혹은 빅데이터와 같은 일관성이 필요없고 데이터 양이 많은 경우는 MongoDB 도입을 고려해볼 수 있다.</p>\n<h2>Mongoose란?</h2>\n<p>ODM(Object Document Mapping)이라고 불린다. 몽고디비 자체가 이미 자바스크립트인데 굳이 자바스크립트 객체와 매핑시키는 이유는 몽고디비에 없어서 불편한 기능들을 몽구스가 보완해주기 때문이다.\n(참고. MySQL은 ORM은 시퀄라이즈가 있다.)</p>\n<p><em>ODM이란 프로그래밍 언어 Object와 Document를 매핑시켜 호환성을 만들어내고 간편한 CRUD를 가능케한다.</em></p>\n<p>스키마라는 기능을 사용할 수 있다. NoSQL은 테이블이 없어서 자유롭게 데이터를 넣을 수 있지만, 때로는 자유로움이 불편함을 초래한다. 잘못된 자료형을 넣을 수 있고 다른 도큐멘트에는 없는 필드의 데이터를 넣을 수도 있다. 몽구스는 몽고디비에 데이터를 넣기 전에 노드 서버단에서 데이터를 한번 필터링 하는 역할을 한다.</p>\n<p>MySQL에 있는 JOIN 기능을 populate로 어느정도 보완한다. 관계가 있는 데이터를 쉽게 가져올 수 있다. 쿼리 한번에 데이터를 합쳐서 가져오는 것은 아니지만, 이 작업을 우리가 직접 하지 않아도 되므로 편리하다.</p>\n<h1>참고</h1>\n<p><a href=\"http://www.yes24.com/Product/Goods/91860680\">Node.js 교과서 개정 2판</a></p>","id":"c8a81d5e-a70b-5c15-b698-7a380d614956"},"previous":{"fields":{"slug":"/cs/운영체제/프로세스&쓰레드/"},"excerpt":"프로세스 프로세스는 실행중인 프로그램으로, 실행 파일이 memory에 적재되어 CPU를 할당받아 실행되는 것을 process라고 한다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받고 이것들을 총칭하여 프로세스라고 한다. 프로세스 메모리 구조 code 영역 - 실행한 프로그램의 코드가 저장되는 메모리 영역 data 영역 - 프로그램의 전역 변수가 저장되는 영역 heap 영역 - 동적으로 할당되는 메모리 영역 stack 영역 - 함수 호…","frontmatter":{"date":"2022-10-18T00:00:00.000Z","description":"프로세스와 쓰레드의 개념과 차이점","title":"프로세스와 쓰레드"},"html":"<h1>프로세스</h1>\n<p><strong>프로세스는 실행중인 프로그램으로,</strong> 실행 파일이 memory에 적재되어 CPU를 할당받아 실행되는 것을 process라고 한다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받고 이것들을 총칭하여 프로세스라고 한다.</p>\n<h2>프로세스 메모리 구조</h2>\n<ol>\n<li>code 영역 - 실행한 프로그램의 코드가 저장되는 메모리 영역</li>\n<li>data 영역 - 프로그램의 전역 변수가 저장되는 영역</li>\n<li>heap 영역 - 동적으로 할당되는 메모리 영역</li>\n<li>stack 영역 - 함수 호출 시 생성되는 지역변수, 매개변수가 저장되는 영역</li>\n</ol>\n<h2>프로세스 제어 블록(Process Control Block, PCB)</h2>\n<p>PCB는 특정 프로세스의 중요한 정보를 저장하고 있는 운영체제의 자료구조이다. 운영체제는 프로세스 관리를 위해 프로세스 생성과 동시에 고유한 PCB를 생성한다. 프로세스 전환이 발생하면 진행하던 작업을 종료하고 CPU를 반환해야 하는데 이 때 작업의 진행상황을 전부 PCB에 저장해놓는다. 이를 Context Switch라고 한다. 다시 CPU를 할당받으면 PCB 내역을 바탕으로 다시 작업을 수행한다.</p>\n<h3>PCB 구성</h3>\n<ul>\n<li>프로세스 식별자: process id</li>\n<li>프로세스 상태: new, ready, running 등</li>\n<li>프로그램 카운터: 프로세스가 다음에 실행할 주소</li>\n<li>CPU 스케쥴링 정보: 프로세스의 우선순위</li>\n<li>메모리 관리 정보: 페이지 테이블 또는 세그먼트 테이블과 같은 정보를 포함</li>\n</ul>\n<h2>멀티 프로세스</h2>\n<p>멀티 프로세스란 2개 이상의 프로세스가 동시에 실행되는 것을 의미한다. 동시에 실행하는 방법은 2가지이다. 1개의 CPU Core를 사용하여 여러개의 프로세스를 빠르게 전환하며 처리하는 방식, 여러개의 CPU Core를 사용하여 각각의 process를 처리하는 방식이다.</p>\n<h2>멀티 프로세스간 데이터 통신 방법</h2>\n<p>멀티 프로세스에서 프로세스끼리 원칙적으로는 데이터를 공유할 수 없다. 프로세스는 독립적인 주소 공간을 갖기 때문이다. 하지만 경우에 따라 운영체제는 프로세스 간 통신(IPC)를 제공한다. IPC 방식에는 공유 메모리 방식과 메시지 전달 방식이 있다.</p>\n<h3>공유 메모리 방식</h3>\n<p>process들이 주소 공간 일부를 공유한다. 공유한 메모리에 읽기/쓰기를 통해서 통신을 수행한다. 커널의 관여 없이 데이터를 통신할 수 있기 때문에 속도가 빠르다는 장점이 있지만, 동시에 같은 메모리 위치에 접근하게 되면 일관성 문제가 발생할 수 있다.</p>\n<h3>메시지 전달 방식</h3>\n<p>커널을 통해서 데이터를 전달해준다. 커널이 개입하기에 속도가 느리다는 단점이 있지만, 일관성 문제가 발생하지 않기 때문에 적은 데이터를 공유할 때 유리하다.</p>\n<p><em>커널이란 운영체제 중에서 항상 메모리에 올라가 있는 운영체제의 핵심 부분으로 컴퓨터 자원들을 관리하는 역할을 수행한다. 컴퓨터 자원으로는 CPU,메모리,파일,네트워크 등이 있다.</em></p>\n<h2>CPU의 처리 방식</h2>\n<p>CPU는 PC Register라는 다음에 실행될 명령어가 저장된 주솟값을 참조하여 연산을 수행한다. 프로세스가 전환될 때, 다른 프로세스의 PC Register가 등록된다.</p>\n<h2>Context Switch</h2>\n<p>한 프로세스에서 다른 프로세스로 CPU 제어권을 넘겨주는 것을 말한다. 이전의 프로세스 상태를 PCB에 저장하여 보관하고 새로운 프로세스의 PCB를 읽어서 보관된 상태를 복구한다.</p>\n<h1>쓰레드</h1>\n<p>쓰레드는 프로세스의 실행의 단위라고 할 수 있다. 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다. (스택을 제외한 나머지 메모리 영역을 공유)</p>\n<h2>stack을 스레드마다 독립적으로 할당하는 이유</h2>\n<p><strong>thread는 프로세스 내에서 독립적으로 기능을 실행한다. 즉 독립적으로 함수를 호출함을 의미한다.</strong> 독립적으로 동작하기 위해서는 thread의 stack memory 영역이 독립적이여야 한다.</p>\n<h2>PC Register를 스레드마다 독립적으로 할당하는 이유</h2>\n<p>한 프로세스 내에서도 thread끼리 context switch가 일어나기 때문에.</p>\n<h2>멀티 쓰레드</h2>\n<p>하나의 process 내에서도 여러 작업이 있다. 이런 작업들을 병렬적으로 처리하기 위해서 multi thread를 사용한다.</p>\n<h2>멀티 쓰레드의 장점</h2>\n<p>프로세스를 이용하여 동시에 처리하던 일을 쓰레드로 구현할 경우 메모리 공간과 시스템 자원 소모가 줄어든다. 쓰레드간의 통신이 필요한 경우 별도의 자원을 사용하지 않고 메모리 영역을 공유하기 때문이다. 즉 프로세스 간의 통신 방법에 비해 쓰레드 간의 통신 방법이 훨씬 간단하다. 쓰레드의 context switch는 프로세스의 context switch와 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.</p>\n<h2>멀티 쓰레드의 문제점</h2>\n<p>멀티 프로세스는 프로세스간 공유하는 자원이 없기 때문에 동일한 자원에 동시에 접근하는 일이 없었지만 멀티 쓰레드는 이 부분을 신경써줘야한다. 어떤 쓰레드가 다른 쓰레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다. 따라서 멀티 쓰레드 환경에서는 동기화 작업이 필요하다.</p>\n<p>또한 멀티 쓰레드는 적은 메모리 공간과 Context Switch가 빠르다는 장점이 있지만 오류로 인해 하나의 쓰레드가 죽으면 전체 쓰레드가 죽을 수 있다.</p>\n<h3>동기화 문제 해결 방안</h3>\n<p>mutex, semaphore 기법을 사용하여 해결할 수 있다.</p>\n<p>mutex란 1개의 스레드만이 공유 자원에 접근할 수 있도록 하여 경쟁 상황을 방지하는 기법이다. 하나의 쓰레드가 공유 자원에 접근하여 lock을 걸면, 다른 쓰레드는 lock이 풀릴 때 까지 해당 자원에 접근할 수 없다.</p>\n<p>semaphore란 S개의 thread만이 공유 자원에 접근할 수 있도록 하여 경쟁 상황을 방지하는 기법이다. 하나의 쓰레드가 자원에 접근할 떄마다 세마포 값을 감소시키고, 자원을 방출할 때는 세마포 값을 증가시킨다. 이 때 세마포의 값이 0이 되면 모든 자원이 사용 중임을 의미하고 0보다 커질 때까지 자원 사용을 block한다.</p>\n<h1>교착상태(데드락)</h1>\n<p>두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태로, 2개 이상의 thead가 각기 자원을 점유하고 있고, 서로의 자원을 기다릴 때 무한 대기가 발생한다.</p>\n<h2>데드락이 발생할 조건 4가지</h2>\n<ol>\n<li>\n<p>상호 배제</p>\n</li>\n<li>\n<p>점유 대기</p>\n</li>\n<li>\n<p>비선점</p>\n</li>\n<li>\n<p>순환 대기</p>\n</li>\n</ol>","id":"96f083a2-5aa5-5b8a-9364-c6733018eeb4"},"next":{"fields":{"slug":"/programming/이펙티브타입스크립트/3장/"},"excerpt":"타입 추론 타입스크립트는 타입 추론을 적극적으로 수행한다. 타입 구문의 수를 엄청나게 줄여주기에 코드의 전체적인 안정성이 향상된다. 숙련된 타입스크립트 개발자는 비교적 적은 수의 구문을 사용한다. 추론 가능한 타입을 사용해 장황한 코드 방지하기 위의 예시에서 a에 굳이 number라는 타입을 명시해줄 필요가 없다. 타입스크립트에서 자동으로 추론해주기 때문이다. 객체의 경우 객체의 경우에도, 타입 추론이 의도한 타입과 동일하다면 굳이 타입을 명…","frontmatter":{"date":"2022-11-01T00:00:00.000Z","description":"타입 추론","title":"이펙티브 타입스크립트 3장"},"html":"<h1>타입 추론</h1>\n<p>타입스크립트는 타입 추론을 적극적으로 수행한다. 타입 구문의 수를 엄청나게 줄여주기에 코드의 전체적인 안정성이 향상된다. 숙련된 타입스크립트 개발자는 비교적 적은 수의 구문을 사용한다.</p>\n<h1>추론 가능한 타입을 사용해 장황한 코드 방지하기</h1>\n<pre><code class=\"language-ts\">const a: number = 3\n</code></pre>\n<p>위의 예시에서 a에 굳이 number라는 타입을 명시해줄 필요가 없다. 타입스크립트에서 자동으로 추론해주기 때문이다.</p>\n<h2>객체의 경우</h2>\n<p>객체의 경우에도, 타입 추론이 의도한 타입과 동일하다면 굳이 타입을 명시해줄 필요가 없다.</p>\n<pre><code class=\"language-ts\">interface Person {\n  name: string\n  born: {\n    where: string\n    when: string\n  }\n}\nconst person: Person = {\n  name: \"sssdf\",\n  born: {\n    where: \"Seoul\",\n    when: \"2000-11-01\",\n  },\n}\n</code></pre>\n<p>person 객체만 정의하면 Person과 같은 타입이 자동으로 추론된다. 하지만 만일 객체 리터럴을 정의할 때 잉여속성 체크를 하고 싶다면 꼭 타입을 명시해야한다. 잉여속성 체크를 함으로써, 객체가 사용되는 쪽의 코드에서 문제가 발생하는 것이 아니고, 객체가 정의된 곳에서 문제가 발생되어 문제를 쉽게 파악할 수 있다.</p>\n<h2>리팩토링을 쉽게</h2>\n<p>타입이 추론되면 리팩토링도 쉽게 할 수 있다. 어떻게 보면 기존에 정의된 타입을 이용한다는 것으로 받아들이면 된다.</p>\n<pre><code class=\"language-ts\">interface Product {\n  id: number\n  name: string\n  price: number\n}\n\nfunction logProduct(product: Prodcut) {\n  const id: number = product.id\n  const name: string = product.name\n  const price: number = product.price\n}\n</code></pre>\n<p>위의 예시에서 만일 id가 number 타입이 아닌 string 타입으로 변경되면 logProduct의 함수 const id 부분이 타입 에러가 발생할 것이다. 위와 같은 경우에는 비구조화 할당문으로 리팩토링 해주는게 좋다. 모든 지역 변수의 타입 추론이 되도록 하기 때문이다.</p>\n<pre><code class=\"language-ts\">function logProduct(product: Product) {\n  const { id, name, price } = product\n}\n</code></pre>\n<h2>함수</h2>\n<p>타입 정보가 있는 라이브러리에서 콜백 함수의 매개변수 타입은 자동으로 추론된다. express HTTP 서버 라이브러리를 사용하는 request와 response 타입 선언은 필요하지 않는다.</p>\n<p>함수의 반환에 타입을 명시하면 객체 리터럴에 타입을 명시하는 것과 유사하게 사용되는 쪽의 코드에서 문제가 발생한 곳이 아니고, 구현부에서 문제를 발견할 수 있다.</p>\n<pre><code class=\"language-ts\">const cache: { [ticker: string]: number } = {}\nfunction getQuote(ticker: string) {\n  if (ticker in cache) {\n    return cache[ticker]\n    //number\n  }\n  return fetch(\"...\")\n    .then(response => response.json())\n    .then(quote => {\n      cache[ticker] = quote\n      return quote\n    })\n  //promise\n}\n</code></pre>\n<p>위의 getQuote 함수는 if 구문에서는 number 타입을, fetch에서는 Promise를 리턴하기 때문에 프로미스가 사용되는 부분에서 타입 에러를 발생한다. 해당 문제를 해결하기 위해서는 cache[ticker]를 반환하는게 아닌, Promise.resolve(cache[ticker])를 반환해야한다.</p>\n<p>또한 함수의 반환값에 타입을 명시하면, 해당 타입을 보고 직관적으로 함수를 이해할 수 있다.</p>\n<pre><code class=\"language-ts\">type Vector2D = { x: number; y: number }\nfunction add(a: Vector2D, b: Vector2D) {\n  return { x: a.x + b.x, y: a.y + b.y }\n}\n</code></pre>\n<p>위의 add 함수는 <code>{x:number, y:number}</code> 타입으로 추론할 것이다. 하지만 Vector2D가 들어갔는데, 해당 타입이 나온다는게 개발자 입장에서는 혼란스러울 수 있다. 이럴 때 타입을 명시해주면 혼란을 줄일 수 있다.</p>\n<h1>다른 타입에는 다른 변수 사용하기</h1>\n<pre><code class=\"language-ts\">let id = \"123\"\nfetchProduct(id) // string\n\nid = 123\nfetchProductByNumber(id) //number\n</code></pre>\n<p>자바스크립트에서는 위의 패턴이 허용된다. 하지만 타입스크립트에서는 id에 string 타입이 할당되었기 때문에 그 다음에 number 타입을 할당할 수 없어 오류가 발생한다.</p>\n<pre><code class=\"language-ts\">let id: string | number = \"123\"\n</code></pre>\n<p>위와 같이 유니온 타입으로 타입을 좁혀서 정의하면 코드는 동작한다. 하지만 id를 사용할 때마다 number인지 string인지 확인해야 하기 때문에, 간단한 타입에 비해 다루기 어렵다.\n<strong>따라서 위의 경우에는 변수를 분리한다!</strong>\n변수를 분리하면 더 정확한 변수명을 지을 수 있고, const로 변수를 선언하여 코드 안정성을 향상 시킬 수 있다.</p>\n<h1>타입 넓히기</h1>\n<p>상수를 사용해서 변수를 초기화 할 때 타입을 명시하지 않으면 타입 체커는 타입을 스스로 결정해야 한다. 지정된 단일 값으로 할당 가능한 값들의 집합을 유추해야 한다는 의미이다. 이러한 과정을 타입 넓히기(widening)라고 부른다.</p>\n<pre><code class=\"language-ts\">function onlyGetABC(abc: \"a\" | \"b\" | \"c\") {\n  //...\n}\n\nlet A = \"a\"\nonlyGetABC(A)\n//타입체크 에러 발생\n</code></pre>\n<p>위의 경우 변수 A의 경우 \"a\"라고 정의하였지만, 타입 체커는 타입을 string으로 배치하였다. 타입을 넓혀야 하기 때문이다. 그리고 <code>onlyGetABC</code>는 string이 아닌 <code>\"a\"</code>를 매개변수로 받기 때문에 타입 에러가 발생한다.</p>\n<pre><code class=\"language-ts\">const mixed = [\"x\", 1]\n</code></pre>\n<p>위의 경우 나올 수 있는 경우의 수가 매우 많다. 타입 시스템은 작성자의 의도를 추측하지만, 아무리 영리하더라도 사람의 마음까지는 읽을 수 없다. 위의 경우 작성자는 튜플로 추론되기를 바랬으나 <code>(string|number)[]</code>으로 추론된다.</p>\n<h2>넓히기를 제어하는 방법</h2>\n<h3>let 대신 const로 선언하기.</h3>\n<p>let 대신 const로 선언하면 더 좁은 타입이 된다.</p>\n<pre><code class=\"language-ts\">const A = \"a\"\nonlyGetABC(A)\n//정상\n</code></pre>\n<p>위의 예시에서 A는 <code>\"a\"</code>로 추론된다.\n그러나 const는 만능이 아니다. 객체와 배열의 경우에는 여전히 문제가 존재한다.</p>\n<p>객체의 경우 타입스크립트의 넓히기 알고리즘은 각 요소를 let으로 할당된 것으로 다룬다. 그리고 다른 속성을 추가하지 못한다.</p>\n<h3>명시적 타입 구문을 제공하기</h3>\n<pre><code class=\"language-ts\">const v: {x:1|2|3} {\n  x:1\n}\n</code></pre>\n<h3>타입 체커에 추가적인 문맥을 제공하는 것</h3>\n<p>이후 아이템에서 다룬다고함.</p>\n<h3>const 단언문 사용</h3>\n<p>const로 변수를 선언하는 것과 다른 의미이다.\n값 뒤에 as const를 작성하면 타입스크립트는 최대한 좁은 타입으로 추론한다. 배열을 튜플 타입으로 추론할 때에도 as const를 사용할수 있다.</p>\n<h1>타입 좁히기</h1>\n<p>타입 넓히기의 반대 개념이다. 대표적인 예시는 null 체크이다.</p>\n<pre><code class=\"language-ts\">const el = document.getElementById(\"foo\")\nif (el) {\n  el.innerHTML = \"hello\"\n} else {\n  alert(\"no element\")\n}\n</code></pre>\n<p>위의 예시에서는 분기 처리를 통해 el의 타입이 HTMLElement임을 확인하였다.</p>\n<h2>타입 좁히기 종류</h2>\n<ol>\n<li>\n<p>instanceof를 사용</p>\n</li>\n<li>\n<p>내장 함수(Array.isArray 등)</p>\n</li>\n<li>\n<p>조건문</p>\n<ul>\n<li>\n<p>조건문을 통해서 타입을 좁힐 때는 유의해주어야 한다.</p>\n<pre><code class=\"language-ts\">function foo(x?: number | string | null) {\n  if (!x) {\n  }\n}\n</code></pre>\n<p>위의 예시의 경우 0, '' 모두 falsy이기 때문에 타입이 전혀 좁혀지지 않았다.</p>\n<pre><code class=\"language-ts\">const el = document.getElementById(\"foo\")\nif (typeof el === \"object\") {\n}\n</code></pre>\n<p>위의 예시도 문제는 object도 null이기 떄문에 타입이 좁혀지지 않았다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>명시적 태그를 붙이는 방법</p>\n<ul>\n<li>객체 내에 type 속성을 넣어주고 값을 넣어주는 패턴 등이 존재한다.</li>\n<li>태그된 유니온, 구별된 유니온이라고 불린다.</li>\n</ul>\n</li>\n<li>\n<p>커스텀 함수 도입</p>\n<pre><code class=\"language-ts\">function isInputElement(el: HTMLElement): el is HTMLInputElement {\n  return \"value\" in el\n}\n\nfunction getElementContent(el: HTMLElement) {\n  if (isInputElement(el)) {\n    return el.value\n  }\n  return el.textContent\n}\n</code></pre>\n<ul>\n<li>위와 같은 패턴을 사용자 정의 타입 가드라고 한다.</li>\n</ul>\n<pre><code class=\"language-ts\">const member = [\"a\", \"b\", \"c\", \"d\"]\nconst people = [\"a\", \"e\"]\n\nconst onlyMember = people.map(who => member.find(v => v === who))\n//(string | undefined)[]\n\nconst filteredOnlyMember = people\n  .map(who => member.find(v => v === who))\n  .filter(who => who !== undefined)\n//(string | undefined)[]\n</code></pre>\n<p>위의 경우 filteredOnlyMember 변수도 (string | undefined)[]이다. 이럴 때 타입 가드를 사용하면 타입을 좁힐 수 있다.</p>\n<pre><code class=\"language-ts\">function isDefined&#x3C;T>(x: T | undefined): x is T {\n  return x !== undefined\n}\n\nconst filteredOnlyMember = people\n  .map(who => member.find(v => v === who))\n  .filter(isDefined)\n//string[]\n</code></pre>\n</li>\n</ol>\n<h1>한꺼번에 객체 생성하기</h1>\n<p>자바스크립트의 값은 변경되지만 일반적으로 타입스크립트의 타입은 변경되지 않는다. 객체를 생성할 때는 속성을 하나씩 추가하는 것보다는 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리하다.</p>\n<pre><code class=\"language-ts\">const pt = {}\npt.x = 3\npt.y = 5\n//타입 체크 오류 발생.. {} 형식에 x가 존재하지 않습니다.\n</code></pre>\n<p>아래와 같은 패턴으로 정의하면 오류가 발생하지 않는다.</p>\n<pre><code class=\"language-ts\">const pt = { x: 3, y: 5 }\n</code></pre>\n<p>객체를 반드시 제각각 나눠서 만들어야 한다면 타입 단언문을 사용해야한다.</p>\n<pre><code class=\"language-ts\">interface Point {\n  x: number\n  y: number\n}\nconst pt = {} as Point\npt.x = 3\npt.y = 5\n</code></pre>\n<h2>전개 연산자</h2>\n<p>객체를 합칠 때는 전개 연산자를 사용한다.</p>\n<pre><code class=\"language-ts\">const pt = { x: 3, y: 4 }\nconst id = { name: \"pythagoras\" }\nconst namedPoint = {}\nObject.assign(namedPoint, pt, id)\nnamedPoint.name\n//타입 에러 발생.. name 속성이 없다.\n\nconst namedPoint = { ...pt, ...id }\nnamedPoint.name\n</code></pre>\n<h3>조건부 속성</h3>\n<pre><code class=\"language-ts\">declare let hasMiddle: boolean\nconst firstLast = { first: \"harry\", last: \"potter\" }\nconst president = { ...firstLast, ...(hasMiddle ? { middle: \"S\" } : {}) }\n</code></pre>\n<p>위의 예시에는 middle이 선택적 속성을 가지는 것으로 추론된다.</p>\n<p>만일 전개 연산자로 여러 속성을 추가하면 어떻게 될까? 이때는 유니온 속성으로 추론된다. 속성이 함께 정의되기 때문에 유니온을 사용하는게 값의 집합을 더 정확히 표현할 수 있기 때문이다.</p>\n<p>유니온 방식이 아닌, 선택적 필드로 만들고 싶다면 헬퍼 함수를 사용해야한다.</p>\n<pre><code class=\"language-ts\">function addOptional&#x3C;T extends object, U extends object>(\n  a: T,\n  b: U | null\n): T &#x26; Partial&#x3C;U> {\n  return { ...a, ...b }\n}\n</code></pre>\n<p><strong>객체나 배열을 변환해서 새롤운 객체나 배열을 생성하고 싶다면 루프 대신 내장된 함수형 기법 또는 로대시 같은 유틸리티 라이브러리를 만드는게 한꺼번에 객체 생성하기 관점에서 옳다.</strong></p>\n<h1>일관성 있는 별칭 사용하기</h1>\n<pre><code class=\"language-ts\">const person = {\n  age: 20,\n  name: \"jinwook\",\n  location: { City: \"Seoul\", State: \"gdd\" },\n}\nconst loc = person.location\n</code></pre>\n<p>위의 loc 변수가 별칭이다. 별칭의 속성값을 변경하면 원본 객체의 속성값도 변경한다. 따라서 별칭을 남발하면 제어 흐름을 파악하기 어렵다.</p>\n<p>만일 location의 분기를 여러번 나눠야되는 로직이 있다면 우리는 location 별칭을 사용해서 코드를 짧게 유지할 것이다.</p>\n<pre><code class=\"language-ts\">function saveLocation1(person) {\n  if (person.location) {\n  }\n  //...\n}\n\nfunction saveLocation2(person) {\n  const personLocation = person.location\n  if (person.location) {\n    fn(personLocation)\n    //error 발생.. personLocation은 null일 수 있음.\n    //...\n  }\n}\n\nfunction saveLocation3(person) {\n  const { location } = person\n  if (location) {\n    //...\n  }\n}\n</code></pre>\n<p>saveLocation2의 경우 객체의 속성을 별칭으로 정의했다. 하지만 아래 분기에서는 <code>person.location</code>을 확인하였고 <code>personLocation</code>은 확인하지 않았다. <code>person.location</code>은 <code>null</code>이 사라져 타입이 좁혀졌으나 <code>personLocation</code>은 그대로이다. 별칭을 사용할 것이면 일관성있게 <code>saveLocation3</code>처럼 사용해야한다. 또한 비구조화 할당을 사용해서 일관된 이름을 사용하면 더더욱 좋다.</p>\n<h2>별칭으로 인한 혼동</h2>\n<pre><code class=\"language-ts\">const { bbox } = polygon\nif (!bbox) {\n  caculatePolygonBbox(polygon)\n}\n</code></pre>\n<p>위의 예시에서 bbox와 polygon.bbox는 이제 다른 값을 참조한다..! bbox의 경우 비구조화 할당으로 인해 새로운 변수에 넣었기 때문이다.</p>\n<pre><code class=\"language-ts\">function fn(p: Polygon) {}\n\npolygon.bbox //BoundingBox | undefined\n\nif (polygon.bbox) {\n  fn(polygon)\n  polygon.bbox //BoundingBox\n}\n</code></pre>\n<p>위의 예시에서 fn은 polygon의 bbox 속성을 제거할 수도 있다. 하지만 타입은 그대로 유지된다. 타입스크립트에서 함수가 타입 정제를 무효화하지 않는다고 가정하기 때문이다. 따라서 위의 경우에는 비구조화 할당을 사용해서 새로운 지역변수를 정의하면 타입은 정확히 유지되지만 원본값은 변함이 없는 장점을 누릴 수 있다.</p>\n<h1>비동기 코드에는 콜백 대신 async 함수 사용하기</h1>\n<p>콜백보다는 프로미스, async 함수를 사용하는 것이 코드도 간결하며 타입을 추론하기 쉽다.\n선택의 여지가 있다면 프로미스 보다는 async를 사용하는게 좋다.</p>\n<ol>\n<li>코드가 더 간결하고 직관적이다.</li>\n<li>항상 프로미스를 반환한다.</li>\n</ol>\n<p>async 함수에서 프로미스를 반환하면 또 다른 프로미스로 래핑되지 않는다. Promise&#x3C;<T>>가 아닌 Promise<T>를 반환한다.</p>\n<h1>타입 추론에 문맥이 어떻게 사용되는지 이해하기</h1>\n<pre><code class=\"language-ts\">type Lanuage = \"JavaScript\" | \"TypeScript\"\nfunction setLanuage(lanuage: Lanuage) {\n  //...\n}\n\nsetLanuage(\"JavaScript\") //1\nlet js = \"JavaScript\"\nsetLanuage(js) //2\n</code></pre>\n<p>위의 예시에서 첫 번째로 호출한 함수의 경우 에러가 발생하지 않지만, 두 번째로 호출한 함수의 경우 에러가 발생한다. 이 문제를 해결할 수 있는 방법은 2가지이다.</p>\n<ol>\n<li>타입 선언\n<pre><code class=\"language-ts\">let js: Lanuage = \"JavaScript\"\n</code></pre>\n</li>\n<li>js를 상수로 만드는 것이다.\n<pre><code class=\"language-ts\">const js = \"JavaScript\"\n</code></pre>\n</li>\n</ol>\n<h2>튜플 사용 시 주의 점</h2>\n<pre><code class=\"language-ts\">function panTo(where: [number, number]) {}\n\npanTo([10, 10])\nconst loc = [10, 10]\npanTo(loc)\n</code></pre>\n<p>위의 예시의 경우 loc를 상수로 선언했음에도 불구하고 타입 에러가 발생한다. 그 이유는 loc를 <code>number[]</code>로 추론했기 때문이다. 이 경우도 위와 유사하다. 타입 선언을 하거나 상수로 정의해준다.</p>\n<pre><code class=\"language-ts\">const loc = [10, 10] as const\n</code></pre>\n<p>기존에 const는 참조값이 바뀌지 않는 것이였는데, as const로 정의하면 내부까지 상수라는 사실을 타입스크립트에게 알려준다.</p>\n<p>하지만 위의 코드는 또 문제가 있다. loc의 경우 readonly 상태를 가지게 되는데, panTo가 매개변수의 내용이 불변을 보장하지 못하는 것이다. panTo의 매개변수에 readonly 키워드를 적용해줌으로써 해당 문제를 해결할 수 있다.</p>\n<p>as const를 사용할 때 유의해야 하는 점은 타입 정의에 실수가 있다면 타입이 정의되는 곳이 아닌, 호출되는 곳에서 발생한다는 것을 유의해야한다.</p>\n<h1>함수형 기법과 라이브러리로 타입 흐름 유지하기</h1>\n<p>자바스크립트에서는 서드파티 라이브러리의 도입을 신중해야한다. 타입을 알 수 없기 때문에 서드파티 라이브러리를 사용해서 코드를 줄이는데 시간이 오래들기 때문이다. 반면에 타입스크립트는 타입이 명시되어있어 서드파티 라이브러리 도입에 큰 문제가 없다. 서드파티 라이브러리를 활용해서 생산성을 높이는 편이 낫다.</p>","id":"28051e14-adc7-5f08-908e-62ff60528369"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}