{"componentChunkName":"component---src-templates-category-template-tsx","path":"/category/알고리즘/","result":{"pageContext":{"name":"알고리즘","categories":["ALL","cs","programming","tech","알고리즘"],"postNodes":[{"fields":{"slug":"/tech/cdn/"},"excerpt":"cdn이란? cdn이란 content delivery network의 약어로 빠른 콘텐츠 전달을 목적으로 고안되었다.\n엔드 유저와 서버 사이의 물리적인 거리를 줄여서 콘텐츠 로딩에 소요되는 시간을 최소화한다. 전세계에 캐시 서버를 분산 배치하여 엔드 유저의 요청에 오리진 서버가 아닌 엔드 유저에 근접한 캐시 서버가 콘텐츠를 전송한다. 거리가 먼 오리진 서버가 아닌, 가까운 캐시 서버에서 콘텐츠를 받아오기 때문에 로딩에 소요되는 시간을 획기적으…","frontmatter":{"date":"2022-12-16T00:00:00.000Z","description":"cdn의 개념과 원리","title":"cdn"},"html":"<h1>cdn이란?</h1>\n<p>cdn이란 content delivery network의 약어로 빠른 콘텐츠 전달을 목적으로 고안되었다.\n엔드 유저와 서버 사이의 물리적인 거리를 줄여서 콘텐츠 로딩에 소요되는 시간을 최소화한다.</p>\n<p>전세계에 캐시 서버를 분산 배치하여 엔드 유저의 요청에 <strong>오리진 서버가 아닌 엔드 유저에 근접한 캐시 서버가 콘텐츠를 전송한다.</strong> 거리가 먼 오리진 서버가 아닌, 가까운 캐시 서버에서 콘텐츠를 받아오기 때문에 로딩에 소요되는 시간을 획기적으로 줄일 수 있는 것이다.</p>\n<p>예시로 캐나다에 있는 유저가 한국에 있는 서비스에 접근하다면, 캐나다에 위치한 캐시 서버에서 캐싱된 콘텐츠를 전송하여 빠르게 콘텐츠를 받아올 수 있다.</p>\n<h1>cdn 적용 유무에 따른 속도 차이</h1>\n<p>속도 차이가 얼마나 나는지 궁금해서 직접 실험을 해봤다.\nAWS EC2 인스턴스를 각각 서울, 미국 버지니아 북부 지역에 생성하였고 서울에 위치하는 S3 버킷의 동영상을 다운로드 받아봤다. CDN은 AWS Cloudfront 서비스를 이용했다.</p>\n<p>서울에 위치하는 EC2에서 실험을 해봤을 때 cdn 적용 유무에 따라 차이가 없었다.\n<img src=\"./seoul.png\" alt=\"서울 리전 s3,cdn\">\ncdn이 적용되었을 때와 적용되지 않았을 때 0.7s로 동일하였다. 위의 예시는 cdn을 적용하였을 때 다운로드 속도이다.</p>\n<p>미국 버지니아 북부 지역에서 실험을 해봤을 때는 cdn 적용 유무에 따라 유의미한 차이가 있었다.</p>\n<ol>\n<li>\n<p>버지니아 리전에서 cdn이 아닌 S3(오리진 서버)로 직접 접속하여 다운 받았을 떄\n<img src=\"./us_s3.png\" alt=\"버지니아 리전 s3\">\n17초가 걸렸다.</p>\n</li>\n<li>\n<p>버지니아 리전에서 cdn을 적용하여 처음 다운로드 받았을 때\n<img src=\"./us_cdn.png\" alt=\"버지니아 리전 cdn 초기\">\n4.4초가 걸렸다.</p>\n</li>\n<li>\n<p>버지니아 리전에서 cdn을 적용하여 두번 째 다운로드 받았을 때(캐싱된 상태)\n<img src=\"./us_cdn_cached.png\" alt=\"버지니아 리전 cdn cached\">\n0.5초가 걸렸다.</p>\n</li>\n</ol>\n<p>우선 서울에서 서울에 위치하는 오리진 서버로부터 다운로드 받았을 때와 미국에서 서울에 위치하는 오리진 서버로부터 다운로드 받았을 때의 차이를 비교해본다.</p>\n<p>17초와 0.7초로 매우 많이 차이가 난다는 것을 알 수 있다. 서버와의 물리적인 거리가 멀어질수록 전송 속도가 느려진다는 것을 파악했다.</p>\n<p>이번에는 미국에서 오리진 서버로부터 다운로드 받았을 떄와 cdn을 적용했을 때 차이를 비교해본다.</p>\n<ol>\n<li>\n<p>1번 케이스 vs 3번 케이스</p>\n<p>왜 cdn을 적용해야 하는지 보여준다. 17초와 0.5초로 속도 차이가 매우 큰 것을 알 수 있다. 전세계를 대상으로 하는 서비스라면 cdn을 적용하는게 훨씬 좋은 사용자 경험을 제공할 것이다.</p>\n</li>\n<li>\n<p>2번 케이스 vs 3번 케이스</p>\n<p>캐시 서버에 콘텐츠가 캐싱이 되어 있지 않을 때와 캐싱이 되어 있을 때 비교이다. 2번 케이스의 경우 캐시 서버에 콘텐츠가 없어서 오리진 서버로부터 콘텐츠를 가져와서 캐싱 후 요청에 응답한다. 이를 cache miss라고 한다. 3번 케이스의 경우 캐싱이 된 상태이므로 오리진 서버로부터 콘텐츠를 요청하지 않고 바로 캐시 서버에서 응답한다. 이를 cache hit라고 한다. cache hit의 경우 오리진 서버를 거치지 않기 때문에 속도가 더 빠르다.</p>\n</li>\n<li>\n<p>1번 케이스 vs 2번 케이스</p>\n<p>1번 케이스와 2번 케이스 모두 오리진 서버로부터 데이터를 요청한다. 하지만 cdn을 이용하는 2번 케이스의 경우 1번 케이스 대비 약 13초나 빠르게 콘텐츠를 다운로드 하였다. 이번 비교를 통해서 캐싱된 콘텐츠를 반환하는 것이 아닌 매번 오리진을 거쳐야 하는 동적인 콘텐츠를 전달할 때도 cdn을 사용하면 좋다는 것을 알 수 있다. 어떻게 이런 일이 가능한 것일까?</p>\n<p>우리가 잘아는 KT와 같은 ISP(Internet Service Provider)들 간의 연결(ISP-ISP)은 경제적인 논리에 의해서 이루어져 있다. 따라서 항상 최적화된 라우팅 경로를 제공하는 것은 아니다.\n하지만 전세계에 깔린 cdn 서버들은 많은 네트워크 통신을 하다보니 많은 데이터가 쌓이게 되었고 최적화된 라우팅 경로를 파악하여 제공할 수 있게 되었다. cdn은 라우팅을 최적화하여 다운로드 시간을 단축시킨다.</p>\n<p>AWS의 Cloudfront의 경우에는 원본과의 지속적인 유지, gzip 압축을 사용함으로써 시간을 추가적으로 단축한다고 한다. 원본과의 지속적인 유지란, connectionless라는 HTTP의 특징과 반하는 개념으로 콘텐츠를 다운로드 받고도 지속적으로 연결을 유지하는 것을 의미한다. IP 기반의 네트워크를 통해서 TCP/IP 연결을 하기 위해서는 3 way handshake 과정을 거쳐야 하는데 이 과정에 필요한 패킷 사이즈는 크지 않아서 사실 큰 오버헤드는 아니다. 하지만 거리가 멀어질수록 round-trip time이 길어짐으로써 큰 오버헤드가 될 수 있다. 원본과의 유지를 지속함으로써 초기 연결에 필요한 시간을 세이브 할 수 있다. 초당 요청 건수가 많을수록 큰 효과를 누릴 수 있다.</p>\n<p>gzip은 전송되는 데이터 크기를 줄여서 트래픽을 줄일 수 있다. 데이터를 더 짧은 시간안에 전송할 뿐만 아니라 데이터 전송 비용도 절감할 수 있다.</p>\n</li>\n</ol>\n<h1>cdn의 속도 이외의 기능</h1>\n<p>cdn을 활용하면 콘텐츠를 빠르게 전달한다는 장점 이외에도 요청을 여러개의 서버로 분산시킬 수 있으므로 대역폭 소비를 줄이며 안정적인 서비스 제공이 가능하다.</p>\n<p>극단적인 예시로는 DDOS 공격에 대한 방어인데, DDOS 공격이란 좀비 pc를 사용하여 특정 서비스에 엄청난 트래픽을 발생시켜서 서비스를 무력화 시키는 것을 말한다.</p>\n<p>CDN이 요청을 분산하여 오리진 서버에 미치는 영향을 줄임으로써 트래픽 급증에 대처할 수 있다. 만일 한국 캐시 서버의 요청이 너무 많다면, 옆에 도쿄로 분산시키고, 도쿄도 많다면 홍콩으로 분산시키고.. 이러한 방식으로 전세계에 배치된 캐시 서버를 활용하여 요청을 분산시킨다. 또한 사용자 위치에 따라 접근을 제어하거나 너무 빠르거나 느린 요청을 차단함으로써 요청을 줄인다고 한다.</p>\n<h1>캐싱 관리</h1>\n<h2>캐싱 만료 주기</h2>\n<p>CDN 서비스를 이용할 때 기본적으로 캐싱의 만료 주기(TTL)를 설정할 수 있다.</p>\n<p>요청을 받았을 때, 캐시 서버에 저장된 콘텐츠가 만료되었다면 캐시 서버는 원본 서버에 데이터가 변경되었는지 유효성을 검증한다. 변경되지 않았다면 HTTP 304(not modified) 응답을 받게되고 캐싱으로 저장된 콘텐츠를 수정하지 않고 TTL만 갱신하여 요청에 응답한다. 이를 Cache Refresh Hit이라고 한다. 만일 변경되었다는 HTTP 200 응답을 받게되면 오리진 서버로부터 콘텐츠를 다운로드받고 해당 콘텐츠로 캐싱을 갱신하여 요청에 응답한다. 이를 Cache Refresh Miss라고 한다.</p>\n<h2>캐싱의 만료 주기가 끝나기 전에 콘텐츠 수정이 일어난다면?</h2>\n<p>캐싱의 만료 주기가 끝나기 전에, 콘텐츠의 수정이 일어나게 된다면 캐시 서버는 변경되기 전의 콘텐츠를 제공할 것이다.</p>\n<p>위와 같은 문제는 2가지 전략으로 해결할 수 있다.</p>\n<ol>\n<li>\n<p>캐시 서버에 캐싱된 콘텐츠를 강제로 삭제한다.</p>\n<p>캐싱된 콘텐츠를 강제로 삭제함으로써 캐시 서버는 오리진 서버에 새롭게 콘텐츠를 요청하여 받아온다. 만일 캐싱된 콘텐츠가 사용령이 많다면 순간적으로 오리진 서버에 부하가 올 수 있으므로 사용에 유의해야 한다. 또한 사용자 단의(브라우저 등) 로컬 캐시된 콘텐츠의 갱신을 보장하지 않는다.</p>\n</li>\n<li>\n<p>콘텐츠를 다른 이름으로 저장한다.</p>\n<p>이 방식은 사용자 단의 콘텐츠의 최신성을 보장해줄 수 있다. AWS에서는 파일을 버전관리 함으로써 이 전략을 수행하도록 권장한다.</p>\n<p>캐싱의 기준은 콘텐츠가 아닌 URL 기반이기 때문에 쿼리스트링이 추가될 수 있다. 동일 콘텐츠임에도 불구하고 쿼리스트링이 달라짐으로써 캐싱이 안될수도 있으니 잘 설정해주어야 한다.</p>\n</li>\n</ol>\n<h1>어떻게 가까운 곳을 찾아서 전달할 수 있을까?</h1>\n<p>CDN은 엔드 유저의 요청에서 가장 가까운 캐시 서버의 캐싱된 콘텐츠를 반환함으로써 빠른 다운로드 속도를 제공한다고 했다. 그렇다면 어떻게 엔드 유저와 가까운 캐시 서버를 알 수 있을까? 이는 라우팅의 원리를 알아야한다.</p>\n<h2>라우팅 테이블</h2>\n<p>라우팅은 네트워크에서 경로를 선택하는 프로세스이다. 쉽게 말하면 라우터에서 라우터로 이동하면서 목적지 주소를 찾는 과정을 말한다. 목적지 주소가 라우터와 동일한 네트워크에 있을 경우 패킷을 직접 전달하는 것으로 마무리된다.</p>\n<p>라우터에서 라우터로 이동할 때 라우팅 테이블이라는 표를 보고 움직이게 된다. 라우팅 테이블에는 최적의 경로로 도달할 수 있는 다음 라우터의 네트워크 주소만 명시되어있다.</p>\n<p>동일한 네트워크에 연결된 컴퓨터 하나하나 모두 명시하는게 아니라 네트워크 주소만 명시하는 이유는 테이블의 크기를 줄이기 위함이다. 테이블 크기를 줄임으로써 검색도 빨라지고 메모리 낭비도 줄일 수 있다.</p>\n<p>라우팅 테이블에는 모든 경로에 대한 네트워크 주소가 들어가있는게 아니고 다음 라우터에 대한 네트워크 주소만 들어가있다. 그 이유는 다음 라우터 네트워크 주소만 들어가 있어도 차례대로 이동하면서 목적지에 도착할 수 있기 때문이다. 굳이 모든 경로에 대한 네트워크 주소를 명시함으로써 메모리 낭비를 할 필요가 없다.</p>\n<h3>그렇다면 라우팅 테이블은 어떻게 구성되는 것일까?</h3>\n<p>라우팅 테이블을 구성하는 방법은 2가지이다.</p>\n<ol>\n<li>\n<p>정적 라우팅 테이블</p>\n<p>직접 사용자가 라우팅 테이블을 입력해준다.\n네트워크에 붙어 있는 마지막 컴퓨터들이 정적 라우팅을 하는 경우가 대부분이다. 혹은 보안적으로 어떤 목적이 있거나.</p>\n</li>\n<li>\n<p>동적 라우팅 테이블</p>\n<p>라우팅 프로토콜에 의해서 동적으로 구성된다.</p>\n<p>유니캐스트 라우팅 프로토콜: 일대일 통신을 말한다. 보내는 사람도 하나, 받는 사람도 하나</p>\n<p>머맅캐스트 라우팅 프로토콜: 보내는 사람은 하나인데 받는 사람 여려명</p>\n</li>\n</ol>\n<h2>라우팅 프로토콜</h2>\n<p>최적화된 라우팅 테이블을 만드는데 라우팅 프로토콜이 사용된다.</p>\n<p>라우팅 프로토콜은 내부 게이트웨이 프로토콜과 외부 게이트웨이 프로토콜로 나누어진다. 나누는 기준은 AS이며 AS(Autonomous System)는 독립적인 네트워크로 라우팅 정보를 주고 받을 수 있는 영역이며 2가지 특징을 가진다.</p>\n<ol>\n<li>AS 내의 라우터들은 서로 동일한 라우팅 프로토콜을 사용한다.</li>\n<li>AS 내의 라우터들은 한 조직에 의해 관리된다.</li>\n</ol>\n<h3>내부 프로토콜</h3>\n<p>내부 프로토콜에는 Distance Vector 알고리즘, Link State 알고리즘이 사용된다.</p>\n<ol>\n<li>\n<p>Distance Vector 알고리즘</p>\n<p>최소 경로를 계산하기 위해서 벨만 포드 알고리즘을 사용한다.\n벨만 포드 알고리즘을 사용하는 이유는 음의 간선이 존재해서가 아니라 본인이 가진 네트워크 정보를 이웃하고만 교환하는 방식이기 떄문이라고 생각한다.</p>\n</li>\n<li>\n<p>Link State 알고리즘</p>\n<p>본인으로부터 모든 목적지까지 가는 최단 경로를 구한다. 다익스트라 알고리즘을 사용한다.\n다익스트라 알고리즘을 사용하는 이유는 이웃 이외에도 모든 노드와 네트워크 정보를 교환하기 때문이다. 모든 정보를 알고있다면 다익스트라 알고리즘이 시간복잡도에서 효율적이다.</p>\n</li>\n</ol>\n<h3>외부 프로토콜</h3>\n<p>외부 프로토콜은 경로 벡터 라우팅이라는 방식에 의해서 수행된다.</p>\n<p>경로 벡터 라우팅에는 목적지 네트워크, 다음 라우터, 경로명이 명시된다. Distance Vector 알고리즘 기반으로 작동하고 looping 되는 경로를 방지하기 위해 모든 path를 명시한다.</p>","id":"adb2021c-4b9f-509c-b3ad-0a32b7ca123f"},{"fields":{"slug":"/programming/이펙티브타입스크립트/6장/"},"excerpt":"devDependencies에 typescript와 @types 추가하기 devDependencies에는 프로젝트를 개발하고 테스트하는 데 사용되지만, 런타임에는 필요 없는 라이브러리가 포함된다. typescript와 @types는 런타임에서 사용되지 않기 때문에 devDependencies에 설치되어야한다. 타입스크립트 프로젝트 의존성 타입스크립트 자체 의존성 팀원들 모두가 항상 동일한 버전을 설치한다는 보장이 없다. 프로젝트를 셋업할 때 …","frontmatter":{"date":"2022-12-09T00:00:00.000Z","description":"타입 선언과 @types","title":"이펙티브 타입스크립트 6장"},"html":"<h1>devDependencies에 typescript와 @types 추가하기</h1>\n<p>devDependencies에는 프로젝트를 개발하고 테스트하는 데 사용되지만, 런타임에는 필요 없는 라이브러리가 포함된다. typescript와 @types는 런타임에서 사용되지 않기 때문에 devDependencies에 설치되어야한다.</p>\n<h2>타입스크립트 프로젝트 의존성</h2>\n<ol>\n<li>\n<p>타입스크립트 자체 의존성</p>\n<ul>\n<li>팀원들 모두가 항상 동일한 버전을 설치한다는 보장이 없다.</li>\n<li>프로젝트를 셋업할 때 별도의 단계가 필요하다.</li>\n</ul>\n<p>devDependencies에 포함되어 있다면 npm install 할 때 항상 정확한 버전의 타입스크립트를 설치할 수 있다.</p>\n</li>\n<li>\n<p>타입 의존성</p>\n<ul>\n<li>사용하려는 라이브러리에 타입 선언이 되어있지 않더라도, DefinitelyType에서 타입 정보를 얻을 수도 있다.</li>\n<li>DefinitelyType에서 얻은 타입 정보 또한 devDependencies에서 관리해야한다.</li>\n</ul>\n</li>\n</ol>\n<h1>타입 선언과 관련된 세 가지 버전 이해하기</h1>\n<p>타입스크립트는 의존성 관리를 더욱 힘들게 한다. 다음 세 가지 사항을 추가로 고려해야 한다.</p>\n<ol>\n<li>타입스크립트 버전</li>\n<li>타입 선언(@types)의 버전</li>\n<li>라이브러리의 버전</li>\n</ol>\n<h2>실제 라이브러리와 타입이 따로 관리됨으로써 발생하는 문제점</h2>\n<ol>\n<li>\n<p>라이브러리는 업데이트 했지만 실수로 타입 선언은 업데이트 하지 않는 경우</p>\n<p>라이브러리와 관련하여 새로운 기능을 사용하려고 할 때마다 오류 발생함. 특히 하위 호환성이 깨진다면 런타임에서 오류가 발생할 수도 있다.</p>\n<p>타입 선언도 버전을 맞춰서 업데이트 해주거나, 보강 기법을 활용하여 타입 정보를 프로젝트에 추가해준다.</p>\n</li>\n<li>\n<p>라이브러리보다 타입 선언의 버전이 최신인 경우</p>\n<p>타입 체커는 최신 API를 기준으로 코드를 검사하지만, 런타임에 실제로 쓰이는 것은 과거 버전이다. 이런 경우에도 라이브러리 버전과 타입 선언의 버전을 일치시켜줌으로써 문제를 해결한다.</p>\n</li>\n<li>\n<p>프로젝트에서 사용하는 타입스크립트 버전보다 라이브러리에서 필요로 하는 타입스크립트 버전이 최신인 경우</p>\n<p>유명 라이브러리는 타입 정보를 더 정확하게 표현하기 위해 타입 시스템이 개선되고 버전이 올라가게 된다.</p>\n<p>해결을 위해서는 프로젝트의 타입스크립트 버전을 올리거나, 라이브러리의 타입 선언 버전을 내리거나, declare module 선언으로 라이브러리의 타입 정보를 없애버리거나 하면 된다.</p>\n</li>\n<li>\n<p>@types 의존성이 중복될 수도 있다.</p>\n</li>\n</ol>\n<h1>공개 API에 등장하는 모든 타입을 익스포트하기</h1>\n<p>공개 API에 등장하는 모든 타입은 익스포트 하는 것이 좋다. 필요한 타입을 사용자들이 접근할 수 있도록 해야한다. 모종의 사유로 어떤 타입을 숨기기 싶어서 익스포트 하지 않았다고 해도, 해당 타입을 사용하는 함수가 익스포트 될 경우 Parameters, ReturnType 제너릭을 사용해서 추출할 수 있기 때문이다.</p>\n<h1>API 주석에 TSDoc 사용하기</h1>\n<p>JSDoc 스타일로 주석을 작성하게 되면 대부분의 편집기는 함수가 호출되는 곳에서 함수에 붙어있는 JSDoc 스타일으 주석을 툴팁으로 표시해준다. 툴팁을 보면서 함수에 대해서 더 쉽게 이해할 수 있다.</p>\n<p>인라인 주석으로 작성하게 될 경우에는 지원하지 않는다.</p>\n<h1>콜백에서 this에 대한 타입 제공하기</h1>\n<p>콜백 함수가 this를 사용한다면 this에 대한 타입을 명시해주어야 하고 바인딩 시켜주어야 한다.</p>\n<p>아래는 this에 대한 타입 명시와 바인딩을 시켜준 예시이다.</p>\n<pre><code class=\"language-ts\">function addKeyListener(\n  el: HTMLElement,\n  fn: (this: HTMLElement, e: KeyboardEvent) => void\n) {\n  el.addEventListener(\"keydown\", e => {\n    fn.call(el, e)\n  })\n}\n</code></pre>\n<p>콜백 함수의 첫 번째 매개 변수에 있는 this는 특별하게 처리된다. this에 대한 타입으로 설정된다.\n그리고 만약 this에 대한 명시적 바인딩이 일어나지 않으면 에러를 도출한다.\n아래의 예시를 살펴보면 알 수 있다.</p>\n<pre><code class=\"language-ts\">function addKeyListener(\n  el: HTMLElement,\n  fn: (this: HTMLElement, e: KeyboardEvent) => void\n) {\n  el.addEventListener(\"keydown\", e => {\n    fn(el, e)\n    //1개의 인수가 필요한데 2개의 인수가 사용되었습니다.\n\n    fn(e)\n    //void 형식의 this 컨텍스트를 HTMLElement 형식 this에 할당할 수 없다.\n  })\n}\n</code></pre>\n<p>this에 대한 타입이 주어지고 명시적으로 바인딩 함으로써 완전한 타입 안전성을 얻을 수 있다.</p>\n<pre><code class=\"language-ts\">addKeyListener(el, function (e) {\n  this.innerHTML //정상\n})\n</code></pre>\n<h1>오버로딩 타입보다는 조건부 타입 사용하기</h1>\n<p>오버로딩은 아이템3에서 학습하였지만 간단하게 기술한다.</p>\n<pre><code class=\"language-ts\">function add(x: number, y: number): number\nfunction add(x: string, y: string): string\n\nadd(3, 3) //1번 호출부\nadd(\"x\", \"y\") //2번 호출부\n</code></pre>\n<p><strong>함수는 오버로딩 될 수 없지만 타입은 오버로딩 될 수 있다.</strong> 오버로딩된 타입중에서 일치하는 타입을 찾게된다. add 함수의 1번 호출부에서 2개의 오버로딩된 타입 중 위에것을 찾아서 매칭시킨다. add 함수의 2번 호출부에서는 2개의 오버로딩된 타입 중 아래것을 찾아서 매칭시킨다.</p>\n<p>타입 오버로딩 없이 처리하기 위해서 유니온 함수를 사용했다고 가정해보자</p>\n<pre><code class=\"language-ts\">function double(x: string | number): string | number\nfunction double(x: any) {\n  return x + x\n}\n</code></pre>\n<p>double 함수를 호출하면 실제로는 number가 들어가면 number가 결과 타입으로 예측되고 string이 들어가면 string이 결과 타입으로 예측된다. 하지만 타입 선언의 경우 x가 string일 때 결과 타입이 number인 경우가 존재한다.</p>\n<p>타입을 정교화하기 위해서 제너릭을 사용해본다.</p>\n<pre><code class=\"language-ts\">function double&#x3C;T extends string | number>(x: T): T\n</code></pre>\n<pre><code class=\"language-ts\">const str = \"str\"\nconst doubledStr = double(str) //타입이 'str', 'strstr'이 되어야함.\n</code></pre>\n<p>타입이 너무 과하게 좁혀져서 정확한 타입을 유추하지 못하는 문제가 발생한다.</p>\n<p>위와 같은 예시의 문제를 해결하기 위해서 우리는 오버로딩을 사용하지만, 오버로딩 보다는 조건부 타입을 사용하면 더 간결하게 코드 작성이 가능하다.</p>\n<pre><code class=\"language-ts\">function double&#x3C;T extends string | number>(\n  x: T\n): T extends string ? string : number\n</code></pre>\n<h1>의존성 분리를 위해 미러 타입 사용하기</h1>\n<p>만일 어떤 모듈의 구현과 무관하게 타입에만 의존한다면 필요한 선언부만 추출하여 작성 중인 라이브러리에 넣는 것을 고려해볼 수 있다. 이를 미러링이라고 한다.</p>\n<p>그 이유는 구현에 필요한 라이브러리는 없고 타입만 있으면 혼란을 줄 수 있기 때문이다.</p>\n<p>하지만 다른 라이브러리의 타입 선언의 대부분을 추출해야 한다면 @types 의존성을 추가하는게 낫다.</p>","id":"cb57a86f-004a-5512-baf1-0b852ba09ac6"},{"fields":{"slug":"/tech/yarnberry/"},"excerpt":"패키지 매니저 공부 배경 위투디 프로젝트에서 사용했던 기술을 바탕으로 2개의 프로젝트를 진행해보려고 한다.\n2개의 프로젝트 모두 웹에서 디자인 할 수 있는 canvas api를 사용하기 때문에 두 프로젝트가 컴포넌트를 공유하여 사용할 수 있도록 제작하려 한다.\n물론 버튼이나, 레이아웃 등의 기타 컴포넌트도 공통적으로 관리하여 개발 생산성을 높일 것이다. 이런 공통적인 기능을 어떻게 유지할까 고민해봤다. 패키지로 만들어서 관리하는 방식. 모노레…","frontmatter":{"date":"2022-12-07T00:00:00.000Z","description":"Yarn Berry는 왜 사용하는걸까?","title":"package manager"},"html":"<h1>패키지 매니저 공부 배경</h1>\n<p>위투디 프로젝트에서 사용했던 기술을 바탕으로 2개의 프로젝트를 진행해보려고 한다.\n2개의 프로젝트 모두 웹에서 디자인 할 수 있는 canvas api를 사용하기 때문에 두 프로젝트가 컴포넌트를 공유하여 사용할 수 있도록 제작하려 한다.\n물론 버튼이나, 레이아웃 등의 기타 컴포넌트도 공통적으로 관리하여 개발 생산성을 높일 것이다.</p>\n<p>이런 공통적인 기능을 어떻게 유지할까 고민해봤다.</p>\n<ol>\n<li>패키지로 만들어서 관리하는 방식.</li>\n<li>모노레포 방식.</li>\n</ol>\n<p>1번인 패키지로 만들어서 관리하는 방식은 공통적인 기능(컴포넌트)이 변경이 되면 패키지를 다시 빌드해줘야 한다. 이렇게 되면 패키지 버전이 달라지게 되고 2개의 프로젝트 모두 패키지를 업데이트 해줘야한다.\n개발을 하면서 공통적인 기능의 수정이 빈번하게 일어날 것 같은데 이 과정이 매우 번거롭다고 생각했다.</p>\n<p>2번인 모노레포 방식을 사용하기로 결심했다!</p>\n<p>빅테크 기업들의 모노레포 도입기를 보니까 yarn berry의 workspaces 기능을 많이 사용하였다.\n나는 npm을 사용했기에 이번 기회에 패키지 매니저에 대해서 공부해야겠다고 생각했다.</p>\n<h1>yarn classic</h1>\n<p>yarn은 기존에 npm이 있었음에도 불구하고 왜 개발되었을까?</p>\n<ul>\n<li>병렬화를 통해서 다운로드 속도를 개선한다.</li>\n<li>lock 파일을 자동으로 생성(npm의 경우 과거에는 자동으로 생성을 지원하지 않았으나 현재는 지원함.)\n<ul>\n<li>package.json에는 버전의 정확한 버전이 아니라, 버전의 범위가 명시되어 있다. 패키지의 버그가 수정되어 버전이 올라갔을 때, 범위로 명시 되었기에 매번 패키지의 릴리즈에 대해서 추적하지 않아도 된다.</li>\n<li>package-lock.json에는 의존성 트리에 대한 정보가 담겨있으며 node_modules의 트리나 package.json이 수정되었을 때 자동으로 생성된다. 의존성 트리에 대한 정보가 있음으로써 npm install 했을 때 동일한 환경을 구성하도록 도와준다.</li>\n</ul>\n</li>\n<li>의존성 트리 알고리즘 변경\n<ul>\n<li>의존성 트리가 덜 변경되도록 함. npm의 경우 다운로드 순서에 따라서 의존성 트리가 변경되는 경우가 있음.</li>\n</ul>\n</li>\n<li>캐시 사용.</li>\n</ul>\n<p>yarn은 현재 2020년 부터 유지보수 단계이다. 1.x 버전은 모두 레거시로 간주한다.\n장기적으로 프로젝트를 진행한다면 yarn berry를 사용하는 편이 좋아보인다.</p>\n<h1>pnpm</h1>\n<p>2017년에 제작되었으며 npm이 보유한 문제점을 해결한 대체품으로 npm만 있으면 사용 가능하다.</p>\n<p>pnpm은 2가지 문제를 해결한다.</p>\n<ol>\n<li>패키지 중복 다운로드 문제</li>\n<li>유령 의존성 문제 해결</li>\n</ol>\n<h2>1. 패키지 중복 다운로드 문제</h2>\n<p>만일 100개의 프로젝트가 동일한 dependency를 사용하고 있다고 가정하면, 모든 프로젝트에 해당 dependency를 다운로드 해주어야 한다.\npnpm 개발자들은 이러한 행위가 불필요하다고 생각했다.</p>\n<p>pnpm을 사용하면 의존성이 content-addressable에 저장이 된다. 모든 파일은 디스크 상에서 단일 위치에 저장되고, 패키지가 설치될 때 그 파일들은 단일 위치에서 하드 링크되고 추가적인 디스크 공간을 소비하지 않는다.\n중복된 패키지 설치를 줄이기 때문에 많은 디스크 공간을 세이브 할 수 있고 새롭게 패키지를 구성할 때 필요한 다운로드 수를 줄여 빠른 다운로드가 가능하다.</p>\n<p>pnpm은 프로젝트 수가 많아질수록 그 위력이 강력해지는 것 같다.</p>\n<h2>2. 유령 의존성 문제 해결</h2>\n<p>npm과 yarn classic의 경우 의존성을 위해 다운로드 되는 패키지의 중복 저장을 막기위해 평탄화 작업을 한다.\n평탄화 작업이란 중복되는 패키지를 위로 끌어올리는 작업을 의미한다.</p>\n<p>만일 A가 B라는 패키지에 의존을 하고있고 C라는 패키지가 A라는 패키지에 의존하고 있을 때, 평탄화 작업이 일어나지 않는다면 B 패키지의 경우 중복 저장된다.\n평탄화 작업을 통해서 중복 저장은 피했지만, 유령 의존성이라는 문제가 생기게 된다. package.json에 명시되어 있지 않은 B라는 패키지에 바로 접근할 수 있게 되는 것이다.</p>\n<p>pnpm은 symlink를 사용하여 프로젝트의 직접적인 의존성 만을 모듈 디렉토리의 루트로 추가하여 이러한 문제를 해결한다.</p>\n<p>프로젝트의 의존성 정보를 symlink로 정확하게 dependencies의 중첩된 구조를 생성한다.\nsymlink를 이용한 방식이 가능한 이유는 단일 출처에 저장되어, 끌어올리는 평탄화 작업이 필요없기 때문이다.</p>\n<p>A 패키지의 의존성을 가지는 B 패키지를 설치한다고 가정해보자.</p>\n<p>node_modules 폴더 아래 .pnpm이라는 폴더가 있다. 해당 폴더에는 A 패키지와 B 패키지가 담기게 되고, B 패키지에는 필요한 A 패키지에 대한 심볼릭 링크가 된다.\n그 다음으로는 직접 의존성이 처리된다. B 패키지는 node_modules에 심볼릭 링크된다. node_modules는 B라는 패키지 정보만 보유하고 있기 때문에 유령 의존성 문제가 발생하지 않는다.</p>\n<h1>yarn berry</h1>\n<p>yarn berry는 yarn classic의 업그레이드 버전이다.</p>\n<p>yarn berry는 node_modules를 아에 없애버리고자 하고 있다.\nnode_modules를 왜 없애버릴려고 했을까?</p>\n<h2>비효율적인 의존성 검색</h2>\n<p>node_modules는 복잡한 폴더 구조이다. 그리고 npm은 파일을 찾기위해 node의 파일 시스템을 사용한다.\n필요한 파일을 찾기위해 상위 폴더 순회를 반복한다. 하지만 yarn berry의 경우 의존성을 관리하기위해 <code>.pnp.cjs</code>라는 파일을 사용하는데 이는 중첩된 폴더 구조가 아닌 단일 파일로 디스크 I/O없이 빠르게 의존성 검색이 가능하다.</p>\n<h2>무거운 node_modules</h2>\n<p>기존에는 간단한 프로젝트를 하려고 해도 수백 메가바이트에 달하는 node_modules를 설치해야했다.\n하지만 yarn은 의존성을 <code>.yarn/cache</code> 폴더 아래 zip 파일로 관리하여 디스크 공간을 많이 세이브 할 수 있고, 의존성 패키지 다운로드 속도를 대폭 줄일 수 있다.\n또한 zip 파일로 관리가 되기에 의존성을 구성하는 파일의 수가 많지 않으므로 변경 사항을 감지하거나 의존성을 삭제하는 작업이 매우 빠르다.</p>\n<p>의존성 패키지의 용량이 작아지면서 Zero-Install이라는 개념이 생겼다.\nZero-Install이란 프로젝트를 클론했을 때, npm install과 같은 명령어를 사용하여 필요한 패키지를 다운로드 할 필요가 없다는 의미이다.</p>\n<p>어떻게 가능한 것일까?</p>\n<p>프로젝트를 처음 구성했을 때 가장 먼저 하는 일은 git 저장소를 생성하고 <code>.gitignore</code>에 <code>/node_modules</code>를 추가하는 것이였다.\n그 이유는 node_modules가 무겁고 환경에 따라서 동작이 달라질 수 있기 때문이다.</p>\n<p>하지만 yarn berry의 경우 zip 파일로 용량이 상대적으로 적고, .pnp.cjs 파일을 이용하여 의존성이 관리되기 때문에 외부 환경에 영향을 받지 않는다.\n따라서 의존성 파일을 git을 사용하여 버전관리를 해도 좋다. 의존성 파일을 코드 저장소에 포함시킴으로써 우리는 프로젝트를 클론하기만 하면 패키지 install없이 시작할 수 있다.</p>\n<h1>어떤 패키지 매니저를 사용할 것인가?</h1>\n<p>나는 yarn berry를 사용하여 프로젝트를 진행하기로 결정하였다.</p>\n<p>그 이유는 3가지이다.</p>\n<ol>\n<li>엄격한 의존성 관리가 가능하다.</li>\n<li>내가 진행하는 프로젝트의 수는 그렇게 많지 않다. pnpm을 사용하여 패키지 중복 다운로드 문제를 해결함으로써 크게 디스크 공간이 세이브 되지 않는다. (현재 디스크 공간도 여유롭다.)</li>\n<li>Zero-Install이 가능하며 의존성 파일의 크기가 작아짐으로써 CI 시간을 절약할 수 있다.</li>\n</ol>","id":"09245a9f-0302-56b2-b221-d0eb5db7bf7a"},{"fields":{"slug":"/programming/쓰로들링,디바운싱/"},"excerpt":"쓰로들링과 디바운싱 개념이 가끔 서로 헷갈릴 떄가 있어서 글을 통해서 정리하도록 한다.\n두 기법 모두 불필요한 함수 호출 횟수를 줄여주기 위해 고안되었다. 쓰로들링 함수가 호출된 후, 정해진 시간 내에 동일한 함수를 호출할 경우 실행하지 않도록 하는 것이다. 위투디 프로젝트에 적용해본 부분은 디자인 에디터의 창 크기가 resize 될 때마다 동적으로 캔버스 크기와 이미지 크기들을 변경시키는데 사용이 되었다. 디바운싱이 아닌 쓰로들링으로 적용한…","frontmatter":{"date":"2022-12-05T00:00:00.000Z","description":"쓰로들링, 디바운싱 개념과 활용","title":"쓰로들링과 디바운싱"},"html":"<p>쓰로들링과 디바운싱 개념이 가끔 서로 헷갈릴 떄가 있어서 글을 통해서 정리하도록 한다.\n두 기법 모두 불필요한 함수 호출 횟수를 줄여주기 위해 고안되었다.</p>\n<h1>쓰로들링</h1>\n<p>함수가 호출된 후, 정해진 시간 내에 동일한 함수를 호출할 경우 실행하지 않도록 하는 것이다.</p>\n<p>위투디 프로젝트에 적용해본 부분은 디자인 에디터의 창 크기가 resize 될 때마다 동적으로 캔버스 크기와 이미지 크기들을 변경시키는데 사용이 되었다.</p>\n<p>디바운싱이 아닌 쓰로들링으로 적용한 이유는, 브라우저의 창 크기가 작아지면서 캔버스 크기도 작아지는 모습을 보여주어야 하기 때문이다. 만일 디바운싱을 적용했다면 창 크기가 작아짐에도 불구하고 캔버스 크기는 계속 동일하다가 마지막에야 사이즈가 맞춰졌을 것이다.</p>\n<p>정리하자면 연속적인 이벤트가 발생하는데 이벤트가 발생하는 모습을 드문드문 보여줘야 할 때 사용한다고 할 수 있다. 예를 들어 스크롤 이벤트가 있다.</p>\n<h3>자바스크립트 예시</h3>\n<pre><code class=\"language-js\">function throttle(cb, time = 3000) {\n  let timer\n  return function (...args) {\n    if (!timer) {\n      timer = setTimeout(() => {\n        cb.apply(this, args)\n        timer = null\n      }, time)\n    }\n  }\n}\n</code></pre>\n<h3>React 예시</h3>\n<pre><code class=\"language-tsx\">const [timer, setTimer] = useState&#x3C;NodeJS.Timeout>()\nconst handleSomethingUsingThrottling = time => {\n  if (!timer) {\n    const newTimer = setTimeout(() => {\n      //doSomething\n      setTimer(null)\n    }, time)\n    setTimer(newTimer)\n  }\n}\n</code></pre>\n<h1>디바운싱</h1>\n<p>디바운싱의 경우 연속적인 함수 호출 중에서 가장 마지막 혹은 처음의 함수를 호출하는 것이다.</p>\n<p>디바운싱이 주로 적용되는 부분은 검색 부분이다. 타이핑을 하는 동안은 검색에 대한 결과를 굳이 보여줄 큰 필요는 없으며 검색의 통신 비용이 꽤 크다고 생각하기 때문이다. 물론 쓰로들링으로 적용해도 관계없다.</p>\n<h3>자바스크립트 에시</h3>\n<pre><code class=\"language-js\">function debounce(cb, time = 3000) {\n  let timer\n\n  return function (...args) {\n    clearTimeout(timer)\n\n    timer = setTimeout(() => {\n      cb.apply(this, args)\n    }, time)\n  }\n}\n\n//사용 에시\nconst debounceFunc = debounce(value => {\n  console.log(value)\n})\n\nfor (let i = 0; i &#x3C; 10; i++) {\n  debounceFunc(i)\n}\n//9가 출력된다.\n</code></pre>\n<h3>리액트 예시</h3>\n<pre><code class=\"language-tsx\">const [timer, setTimer] = useState&#x3C;NodeJS.Timeout>()\nconst handleSomethingUsingDebouncing = time => {\n  clearTimeout(timer)\n  const newTimer = setTimeout(() => {\n    //doSomething...\n  }, time)\n  setTimer(newTimer)\n}\n</code></pre>","id":"53860c9a-c00f-5ec9-8dd6-4d2099991fef"},{"fields":{"slug":"/programming/이펙티브타입스크립트/5장/"},"excerpt":"처음에 타입스크립트를 사용했을 때 잘몰라서 any 키워드를 가끔 사용하곤 했다.\nany는 타입 시스템을 뭉개버리기 때문에 최소한으로 사용을 해야한다. any 키워드로 정의된 변수는 프로젝트 내에서 전염병처럼 퍼져나갈 수 있다...\nany를 잘 다루는 방법에 대해서 알아보도록 하자. any 타입은 가능한 좁은 범위에서만 사용하기 any를 사용해서 타입 시스템의 오류를 피하고자 아래와 같은 두가지 방식으로 처리하였다. 어떤 것이 더 좋은 해결책일…","frontmatter":{"date":"2022-12-02T00:00:00.000Z","description":"any 다루기","title":"이펙티브 타입스크립트 5장"},"html":"<p>처음에 타입스크립트를 사용했을 때 잘몰라서 any 키워드를 가끔 사용하곤 했다.\nany는 타입 시스템을 뭉개버리기 때문에 최소한으로 사용을 해야한다. any 키워드로 정의된 변수는 프로젝트 내에서 전염병처럼 퍼져나갈 수 있다...\nany를 잘 다루는 방법에 대해서 알아보도록 하자.</p>\n<h1>any 타입은 가능한 좁은 범위에서만 사용하기</h1>\n<p>any를 사용해서 타입 시스템의 오류를 피하고자 아래와 같은 두가지 방식으로 처리하였다. 어떤 것이 더 좋은 해결책일까?</p>\n<pre><code class=\"language-ts\">function f1() {\n  const x: any = expressionReturingFoo()\n  expectAoo(x) //error\n}\n\nfunction f2() {\n  const x = expressionReturingFoo()\n  expectAoo(x as any) //error\n}\n</code></pre>\n<p>f2 함수가 더 나은 선택이다. 그 이유는 any의 범위를 좁혔기 때문이다. f1의 로직이 길어질 경우 x는 f1 함수의 스코프 내에서 모두 any로 정의된다. 하지만 f2의 경우에는 expectAoo 함수에 매개변수만 any로써 정의되기 때문에 추가적으로 발생할 수 있는 오류를 줄여준다.</p>\n<h2>객체에서 any가 필요할 경우</h2>\n<p>객체의 속성에서 any가 필요할 경우 객체 전체를 any로 설정하는 것은 바람직하지 않다. 객체의 속성값만 any로 설정해주는 것이 좋다.</p>\n<pre><code class=\"language-ts\">const configGood = {\n  a: 1,\n  b: 2,\n  c: {\n    key: value as any,\n  },\n}\n\nconst configBad = {\n  a: 1,\n  b: 2,\n  c: {\n    key: value,\n  },\n} as any\n</code></pre>\n<h1>any를 구체적으로 변형해서 사용하기.</h1>\n<p>any를 사용하되 any를 모델링 할 수 있다면 모델링 하는 편이 좋다.</p>\n<pre><code class=\"language-ts\">function getLengthBad(arr: any) {\n  return array.length\n}\n\nfunction getLengthGood(arr: any[]) {\n  return array.length\n}\n</code></pre>\n<p>getLengthGood의 경우 함수의 매개변수가 배열이라는 형태를 알 수 있기 때문에 getLengthGood의 결과값이 number라는 타입을 가지게 되고, 매개변수도 배열인지 확인하게 된다.</p>\n<h2>객체에서</h2>\n<p>객체이고 값을 알 수 없다면 <code>{[key:string] :any}</code> 처럼 선언하면 된다.\nobject 타입도 가능하지만, 객체의 키를 열거 가능하지만 속성에 접근은 할 수 없다는 점에서 차이가 있다.</p>\n<h2>함수에서</h2>\n<pre><code class=\"language-ts\">type Fn0 = () => any\ntype Fn1 = (args: any[]) => any\n</code></pre>\n<p>Fn1의 경우 매개변수가 배열이라는 것을 알 수 있다는 장점이 있다.</p>\n<h1>함수 안으로 타입 단언문 감추기</h1>\n<p><strong>불가피하게 타입 선먼문을 사용해야 한다면, 정확한 정의를 가지는 함수 안으로 숨겨야한다.</strong></p>\n<p>함수의 모든 부분을 안전한 타입으로 구현하는 것이 이상적이다만, 불필요한 시간이 들 수 있다. 함수 내부에는 타입 단언을 사용하고 배출값의 타입 정의를 정확히 명시하는 정도로 하면 효율적이다.</p>\n<p>함수 캐싱 예시를 통해서 알아보도록 하겠다.</p>\n<pre><code class=\"language-ts\">function shallowEqual(a: any, b: any) {\n  return a === b\n}\n\nfunction cacheLast&#x3C;T extends Function>(fn: T): T {\n  let lastArg: any[] | null = null\n  let lastResult: any\n\n  return function (arg: any) {\n    if (!lastArg || !shallowEqual(lastArg, arg)) {\n      lastResult = fn(arg)\n      lastArg = arg\n    }\n    return lastResult\n  } as unknown as T\n}\n</code></pre>\n<h1>any의 진화</h1>\n<p>타입스크립트에서 변수의 타입은 변수를 선언할 때 결정된다. 정제(null, undefined)될 수는 있으나 새로운 값이 추가되도록 확장할 수는 없다. 하지만 any는 예외적인 케이스가 존재한다.</p>\n<pre><code class=\"language-ts\">function makeArr(num: number) {\n  const arr = []\n  for (let i = 0; i &#x3C; num; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n</code></pre>\n<p>위의 예시에서 arr이 선언된 부분에서는 any[] 이지만, 리턴할 때 arr는 number[]로 정의된다.\narr에 number 속성의 인자를 넣는 순간 number[]로 진화한다.</p>\n<p>만약에 number가 아닌 다른 속성을 넣어보면 어떨까?</p>\n<pre><code class=\"language-ts\">function makeArr(num: number) {\n  const arr = []\n  for (let i = 0; i &#x3C; num; i++) {\n    arr.push(i % 2 === 0 ? i : `${i}`)\n  }\n  return arr\n}\n</code></pre>\n<p>arr은 (num | string)[]가 된다.</p>\n<p>any 타입의 진화는 noImplictAny가 false로 설정되었고, 변수의 타입이 암시적 any일 경우에만 일어난다. 명시적으로 타입을 선언해주면 타입은 유지가 된다. 암시적 any는 함수 호출을 거쳐도 진화하지 않는다.</p>\n<p>암시적 any를 진화시키는 것보다 명시적으로 타입을 선언해주는 것이 좋다. 위의 예제의 경우 map 메소드를 사용한다면 문제를 해결할 수 있다.</p>\n<h1>모르는 타입에는 any 대신 unknown 사용하기</h1>\n<p>함수의 반환타입으로 any를 사용하는 것은 좋지 않다. 대신에 호출한 부분에서 반환값을 원하는 타입으로 설정하도록 하는 것이 더 이상적이다. unknown 타입을 반환함으로써 사용부에서 타입을 강제로 설정하도록 할 수 있다.</p>\n<p>any의 위험한 이유는 아래 두가지 특징을 가지기 때문이다.</p>\n<ol>\n<li>어떠한 타입이던 any에 할당 가능하다.</li>\n<li>any 타입은 어떠한 타입으로도 할당 가능하다.</li>\n</ol>\n<p>타입스크립트에서는 집합이라는 개념이 사용되는데, A라는 집합이 B의 부분 집합이면서 동시에 B의 상위 집합이 될 수 없기 때문에 any는 타입 시스템과 상충된다.\nB라는 큰 원에 A가 들어가고, A의 원에 B가 들어가는 모양이다. 말이 안된다.</p>\n<p>unknown은 타입 시스템에 부합한다. any의 첫 번째 특징은 만족하지만, 두 번째 특징은 만족하지 않는다.</p>\n<p>B라는 큰 원이 unknown이고, A라는 작은 원이 어떠한 타입이다.</p>\n<pre><code class=\"language-ts\">let unknownType: unknown\nlet unknownType2: unknown\nlet numberType = 3\n\nunknownType = numberType\nnumberType = unknownType\n//에러가 발생한다.\nunknownType2 = unknownType\n</code></pre>\n<p>numberType에 unkownType을 할당하려고 하면 에러가 발생한다. 그 이유는 더 작은 집합에 큰 집합을 넣으려고 했기 때문이다. 하지만 unknownType에 numberType을 할당할 수는 있다. unknownType이 더 큰 집합이기 때문이다.</p>\n<p>unkown 타입인 채로 값을 사용할 경우 오류가 발생하기 때문에 적절한 타입으로 변환해야 한다.\n적절한 타입으로 변환하는 방법은 아래와 같다.</p>\n<ol>\n<li>타입 단언</li>\n<li>체크를 통해서 원하는 타입으로 변환(예시.instanceof를 사용하여 체크하는)</li>\n<li>사용자 정의 타입가드</li>\n</ol>\n<h1>제너릭 vs unknown</h1>\n<p>제너릭을 사용한 스타일은 unknown 타입을 사용했을 때와 기능적으로는 동일하다.\n책에는 unknown 타입을 사용하는 것이 더 좋다고 하는데 이유는 안나와있다.\nunknown을 뱉는게 더 명시적으로 <strong>알 수 없음</strong>을 알려주어서 그런것인가? 라고 생각해본다.</p>\n<h1>타입 단언의 단언</h1>\n<p>어떠한 타입을 보유한 변수의 타입을 변경해줄 때 타입의 단언의 단언 형태가 많이 사용된다.</p>\n<p>express에서 req.query의 기본적인 타입이 존재되어 있고, 제너릭을 통해서 좁혀야 하지만 타입의 단언의 단언을 활용한 예시를 살펴보자.</p>\n<pre><code class=\"language-ts\">interface QueryParams {\n  code:string\n}\nconst queryAny = req.query as any QueryParams\nconst queryUnknown = req.query as unknown as QueryParams\n</code></pre>\n<p>위의 queryAny와 queryUnkown의 기능은 동일하지만, 리팩토링을 하면서 두 개의 단언문을 분리하는 순간 문제가 발생한다. unknown의 경우 분리하는 순간 에러를 발생시키지만, any는 아니다. 전염병처럼 퍼져나간다..!</p>\n<h1>몽키 패치보다는 안전한 타입을 사용하기</h1>\n<blockquote>\n<p>몽키 패치란 런타임에서 코드의 동작을 업데이트하는 기술을 의미한다.</p>\n</blockquote>\n<p>javascript는 언어가 매우 유연하다. window나 DOM에 접근하여 속성을 추가하거나 변경할 수 있다. 하지만 해당 데이터는 전역 변수가 되기 때문에 어떤 side effect를 발생시킬지 모른다.</p>\n<p>타입스크립트를 사용하면 문제가 더 심각해진다. 런타임에서 추가된 속성에 대해서 알 수 없기 때문이다.</p>\n<p>최선의 해결책은 당연하게 window 또는 DOM으로부터 데이터를 분리하는 것이다. 만일 불가능 할 경우 2가지 차선책이 있다.</p>\n<ol>\n<li>\n<p>interface 보강 기능 사용</p>\n<pre><code class=\"language-ts\">interface Window {\n  monkey?: string\n}\n</code></pre>\n<p>타입이 안전하며 몽키패치가 어떤 부분에 적용되었는지 정확하게 알 수 있다.\n하지만 모듈의 관점에서 제대로 동작하려면 global 선언을 추가해줘야 한다.</p>\n</li>\n<li>\n<p>더 구체적인 타입 단언문을 사용하는 것이다. (any가 아니라!)</p>\n<pre><code class=\"language-ts\">interface MonkeyWindow extends Window {\n  monkey: string\n}\n\nconst monkeyWindow = window as MonkeyWindow\nmonkeyWindow.monkey = \"moonkey\"\n</code></pre>\n<p>모듈 문제 없이 타입을 확장할 수 있다.</p>\n</li>\n</ol>\n<h1>타입 커버리지 추적하여 타입 안정성 유지하기</h1>\n<p>noImplictAny를 사용하더라도 아래 2가지의 경우 막을 수 없다.</p>\n<ol>\n<li>명시적 any</li>\n<li>서드파티 타입 선언</li>\n</ol>\n<p>npm의 type-cover-any 패키지를 이용하여 any의 개수를 추적할 수 있다.\n--detail flag를 붙이면 any 타입이 있는 곳을 모두 출력해준다.</p>\n<p>any 타입 커버리지를 꾸준하게 추적하여 불필요한 any 사용을 줄여야한다.\n(서드파티의 타입 오류가 잡혔을 경우, any로 선언한 변수가 더이상 사용되지 않을 경우)</p>","id":"414b468b-24be-5589-bdcd-6836f05d98b8"},{"fields":{"slug":"/programming/이펙티브타입스크립트/4장/"},"excerpt":"유효한 상태만 표현하는 타입을 지향하기 유효한 상태만 표현한다는 것의 의미가 무엇일까. 유효하지 않은 상태가 있음으로써 버그가 생기는 것이라고 할 수 있을 것 같다.\n예시를 통해서 이해해보도록 하자. api를 호출하고 비동기적으로 데이터를 받아옴으로써 페이지의 상태를 다음과 같이 표현할 수 있다. 위와 같은 상태 설계는 유효하지 않은 상태가 존재함으로 버그가 생길 수 있다.\n유효하지 않은 상태는 isLoading이 true이고, error 값…","frontmatter":{"date":"2022-12-01T00:00:00.000Z","description":"타입 설계","title":"이펙티브 타입스크립트 4장"},"html":"<h1>유효한 상태만 표현하는 타입을 지향하기</h1>\n<p>유효한 상태만 표현한다는 것의 의미가 무엇일까. 유효하지 않은 상태가 있음으로써 버그가 생기는 것이라고 할 수 있을 것 같다.\n예시를 통해서 이해해보도록 하자.</p>\n<p>api를 호출하고 비동기적으로 데이터를 받아옴으로써 페이지의 상태를 다음과 같이 표현할 수 있다.</p>\n<pre><code class=\"language-ts\">interface State {\n  data?: string\n  isLoading: boolean\n  error?: string\n}\n</code></pre>\n<p>위와 같은 상태 설계는 유효하지 않은 상태가 존재함으로 버그가 생길 수 있다.\n유효하지 않은 상태는 isLoading이 true이고, error 값이 존재한다면 로딩중인지, 에러인지 파악할 수 없다.</p>\n<p>위의 설계 오류를 아래와 같이 수정할 수 있다.</p>\n<pre><code class=\"language-ts\">interface RequestPending {\n  state: \"pending\"\n}\n\ninterface RequestError {\n  state: \"error\"\n  error: string\n}\n\ninterface RequestSuccess {\n  state: \"success\"\n  data: string\n}\n\ntype RequestState = Requestpending | RequestError | RequestSuccess\n</code></pre>\n<p>RequestState를 위와 같이 정의할 경우, state에 따라서 error 속성과 data 속성의 여부가 변경되기 때문에 유효하지 않은 상태를 가지지 않는다.</p>\n<pre><code class=\"language-ts\">interface RequestState {\n  state: \"pending\" | \"error\" | \"success\"\n  error?: string\n  data?: string\n}\n</code></pre>\n<p>위와 같이 정의할 경우, 유효하지 않은 error와 data가 생길 수 있기 때문에 옳지 않다.</p>\n<p>유효하지 않은 상태가 존재하지 않도록 타입을 정의하고, 어떠한 속성의 값에 따라 상태가 변하는 경우 유니온 속성을 이용하여 깔끔하게 분기처리를 해야한다.</p>\n<h1>사용할 때는 너그럽게, 생성할 때는 엄격하게</h1>\n<blockquote>\n<p>포스텔의 법칙: 당신의 작업은 엄격하게 하고, 다른 사람의 작업은 너그럽게 받아들여야 한다.</p>\n</blockquote>\n<p>함수도 마찬가지이다. 매개변수의 타입의 범위는 넓어도 되지만, 결과를 반환할 때는 타입의 범위가 더 구체적이여야 한다.</p>\n<p>결과를 반환하는 값의 타입의 범위가 좁아야 되는 이유는 타입의 범위가 좁아야 함수를 호출부에서 사용이 편리하기 때문이다.</p>\n<pre><code class=\"language-ts\">interface Argument {\n  a: { x: number; y: number } | { x: number; y: number; z: number }\n}\n\ninterface Return {\n  ans:\n    | { a: number; b: number }\n    | { a: number; c: number }\n    | { a: number; d: number }\n}\n\ndeclare function returnVariousType(arg: Argument): Return\n\nfunction someFunc() {\n  const { c } = returnVariousType({ x: 3, y: 3 })\n}\n</code></pre>\n<p>위의 예제에서 someFunc의 c의 경우 undefined가 될 수 있다. 따라서 분기 처리를 통해 c가 존재한다는 있는 것을 확인해주거나, 리턴값에 속성 타입을 명시하여 분기 처리를 해주어야한다.\n정리하자면, 함수를 호출하는 부분에서 사용이 매우 불편하다..!\n다만 매개변수의 타입은 보다 넓게 설정해주어 함수를 호출할 때 편리함을 증가시켜줄 수 있다.</p>\n<h1>문서에 타입 정보 쓰지 않기.</h1>\n<p>주석으로 타입 정보를 선언해주면, 코드를 수정할 때마다 주석도 수정해주어야 한다. 실무에서 동기화가 안될 떄가 많다. 하지만 타입 시스템은 자동으로 동기화된다.</p>\n<p>또한 타입스크립트는 간결하고, 구체적이며, 읽기 편하게 설계되어 있어 굳이 주석이 필요하지 않다.</p>\n<p>변수명을 지을 때도 타입의 단위를 가지고 있다면 굳이 변수명에 넣지 않아도 좋다. 하지만 단위가 무엇인지 확실하지 않다면 변수명에 표현해줘도 좋다. 전자의 예시로는 ageNum, 후자의 예시로는 temperatureC 등이 있다.</p>\n<h1>타입 주변에 null을 배치하기.</h1>\n<p>한 값의 null이 다른 값의 null에 영향을 미치도록 설계하면 안된다.\n그 이유는 한 값이 null일 때, 아닐 때. 다른 값이 null일 때, 아닐 때 4가지 경우가 생성되기 때문이다. 여러가지 경우의 수가 생긴다. 사용부에서 많은 경우의 수에 대한 분기 처리가 필요하게 되고 가독성 있게 표현하기 힘들어 코드가 복잡하고 읽기 힘들게 된다.</p>\n<p>두 값을 하나의 객체로 정의하고 null 혹은 값을 가지는 상태로 정의한다면 위와 같은 오류를 피할 수 있다.</p>\n<h2>함수의 관점</h2>\n<pre><code class=\"language-ts\">function extent(nums: number[]) {\n  let min, max\n  for (let num of nums) {\n    if (!min) {\n      min = num\n      max = num\n    } else {\n      min = Math.min(min, num)\n      max = Math.max(max, num)\n    }\n  }\n}\n</code></pre>\n<p>strickCheckNull을 키고 다음 함수를 호출한다면, max값에 대해서 오류가 발생할 것이다. 초기 null인 max값에 대해서 값의 대입은 이루어졌지만, 타입 시스템의 검증은 수행되지 않았다. if문에서 min에 대한 체크만 이루어졌기 때문에 max 값은 undefined 혹은 number의 타입을 가지게 된다. number의 타입을 기대하고 함수를 사용했다면 곤란한 상황에 처하게 된다.\n또한 js의 특성상 min이 0일 경우, if(!min)의 분기 처리의 로직을 실행하기 때문에 원하는 최솟값과 최댓값이 나오지 않을 수 있다.</p>\n<p>이 때 max에 대한 분기도 넣어줄 수 있지만, 이는 함수의 구현을 복잡하게 할 뿐만 아니라 추가적인 요청사항이 들어올 경우 에러가 발생할 확률을 높인다.</p>\n<p>min과 max를 하나의 객체로 관리하고, 값의 대입이 이루어졌다면 null이 아니도록 처리해주면 위와 같은 문제를 피할 수 있다.</p>\n<pre><code class=\"language-ts\">function extent(nums: number[]) {\n  const results: { min: number; max: number } | null = null\n\n  for (let num of nums) {\n    if (!results) {\n      results = [num, num]\n    } else {\n      results.max = Math.max(results.max, num)\n      results.min = Math.min(results.min, num)\n    }\n  }\n}\n</code></pre>\n<p>위의 경우 min과 max값이 둘다 null로 묶여 있어서 null 체크를 한번만 해주면 min,max값을 사용할 수 있다.</p>\n<pre><code class=\"language-ts\">function extent(nums: number[]) {\n  return { min: Math.min(...nums), max: Math.max(...nums) }\n}\n</code></pre>\n<pre><code class=\"language-ts\">function extent(nums: number[]) {\n  let min = nums[0]\n  let max = nums[0]\n  //... 이하는 아래와 같다.\n}\n</code></pre>\n<p>위의 2개 함수는 사실 null check가 필요없는 content 함수이다. 2번째 함수의 경우 함수의 초기값을 인자의 첫 번째 요소로 초기화 시켜주어 다른 타입을 가질 가능성을 막아버렸다.</p>\n<h2>클래스의 관점</h2>\n<p>클래스의 경우 초기값(null)을 가지고 메소드에 따라서 값이 변화한다고 한다면, 다른 메소드에서 null 체크가 매번 일어나야 하고, 경우의 수가 생기기 때문에 코드가 복잡해진다.\n클래스의 경우 값을 정확히 가질 때 인스턴스를 정의할 수 있도록 함으로써 null 분기에 필요한 로직을 걷어낼 수 있다. 데이터가 부분적으로 준비한 경우를 다루어야 한다면 null과 관련된 부분을 다룰 수 밖에 없긴하다.</p>\n<h1>유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기</h1>\n<p>유니온 타입의 속성을 가지는 인터페이스를 작성 중이라면, 인터페이스의 유니온 타입을 사용하는 게 더 알맞지는 않을지 검토해봐야 한다.</p>\n<p>그 이유는 유니온 타입에 따른 조합이 생겨 다양한 경우의 수가 생기기 때문이다.</p>\n<p>벡터를 그리는 프로그램을 작성중이고, 특정한 기하학적 타입을 가지는 계층의 인터페이스를 정의한다고 가정해보도록 하자.</p>\n<pre><code class=\"language-ts\">interface Layer {\n  layout: FillLayout | LineLayout | PointLayout\n  paint: FillPaint | LinePaint | PointPaint\n}\n</code></pre>\n<p>위의 경우 layout은 LineLayout을 가지고, paint의 경우 PointPaint를 가지는 상태는 말이 안될 것이다. 위의 같은 경우 인터페이스의 유니온을 사용하여 처리해야한다. 태그된 유니온 방식은 타입스크립트의 타입 체커 시스템과 매우 잘맞기 때문에 해당 방식으로 표현할 수 있다면 사용하는 편이 좋다.</p>\n<pre><code class=\"language-ts\">interface FillLayer {\n  type: \"fill\"\n  layout: FillLayout\n  paint: FillPaint\n}\n\ninterface LineLayer {\n  type: \"line\"\n  layout: LineLayout\n  paint: LinePaint\n}\n\ninterface PointLayer {\n  type: \"point\"\n  layout: PointLayout\n  paint: PointPaint\n}\n\ntype Layer = FillLayer | LineLayer | PointLayer\n</code></pre>\n<p>어떠한 2개의 속성이 있고 둘다 같이 존재하거나, 같이 존재하지 않는 상태라고 가정한다면 이전 아이템에서 배운 타입 주변에 null 배치하기 방식을 이용하면 좋다. 2개의 속성을 하나(객체)로 묶는 것이다.</p>\n<pre><code class=\"language-ts\">interface Person {\n  name: string\n  placeOfBirth?: string\n  dateOfBirth?: Date\n}\n\ninterface Person {\n  name: string\n  birth?: {\n    place: string\n    date: Date\n  }\n}\n</code></pre>\n<h1>string 타입보다 더 구체적인 타입 사용하기</h1>\n<p>string 타입보다 구체적인 타입을 사용해야 하는 이유는 string 타입이 너무 크기 때문이다. 한 글자를 가지던 1만 글자를 가진 문장이던 같은 string 타입이다.</p>\n<p>구체적으로 살펴봤을 때 string 타입보다 구체적인 타입을 사용해야 하는 이유는 3가지이다.</p>\n<ol>\n<li>\n<p>타입을 명시적으로 정의함으로써, 다른 곳으로 값이 전달되어도 타입 정보가 유지된다.</p>\n<ul>\n<li>예시로 다른 함수의 인수의 타입으로 사용될 수 있다. 어떤 배열 내 객체의 속성의 특정한 값을 만족하는 요소를 추출하는 함수를 작성한다고 하였을 떄, 해당 함수의 인자로 타입을 이용하면 좋다. (타입이 변경되었을 떄도 유지보수가 편리하다.)</li>\n</ul>\n</li>\n<li>\n<p>타입을 명시적으로 정의하고 해당 타입의 의미를 설명하는 주석을 붙여넣을 수 있다.</p>\n</li>\n<li>\n<p>keyof 연산자로 더욱 세밀하게 객체의 속성 체크가 가능하다. (이 부분이 여기에 왜 있는지는 잘 모르겠다.)</p>\n<pre><code class=\"language-ts\">interface Albums {\n  recordType: \"studio\" | \"live\"\n  name: string\n  releaseDate: Date\n  follower: number\n}\n\nconst albums: Albums[] = [\n  {\n    recordType: \"studio\",\n    name: \"a\",\n    releaseDate: new Date(\"2022-10-11\"),\n    follower: 200,\n  },\n  {\n    recordType: \"live\",\n    name: \"b\",\n    releaseDate: new Date(\"2022-10-12\"),\n    follower: 300,\n  },\n  {\n    recordType: \"studio\",\n    name: \"c\",\n    releaseDate: new Date(\"2022-10-13\"),\n    follower: 400,\n  },\n]\n\nfunction pluck(arr, key) {\n  return arr.map(v => v[key])\n}\nconst dates1 = pluck(albums, \"releaseDate\")\n//dates1은 any[] 타입을 가진다. 또한 pluck 함수의 두 번째 인수도 첫 번쨰 인수가 보유한 속성값이 언어 서비스에 드러나지 않는다.\n\nfunction pluck2&#x3C;T>(arr: T[], key: keyof T) {\n  return arr.map(v => v[key])\n}\n\nconst dates2 = pluck2(albums, \"releaseDate\")\n//dates2 타입은 (string | Date | number)[]이다. 두 번쨰 인수의 경우 첫 번쨰 인수가 보유한 속성값이 언어 서비스에 드러난다.\n//albums의 속성이 가질 수 있는 모든 타입을 가진다. 원활한 사용을 위해서는 타입을 더 좁혀야한다.\n\nfunction pluck3&#x3C;T, K extends keyof T>(arr: T[], key: K) {\n  return arr.map(v => v[key])\n}\n//keyof T의 범위를 더욱 좁혀야 한다. keyof T의 부분 집합으로 두 번째 매개변수를 도입한다.\n\nconst dates3 = pluck3(albums, \"releaseDate\")\n//dates3의 타입은 Date[]이다. 언어 서비스를 이용하며 명확하게 좁혀진 타입의 결과를 얻어낼 수 있다.\n</code></pre>\n</li>\n</ol>\n<h1>부정확한 타입보다는 미완성 타입을 사용하기</h1>\n<p>타입의 선언의 정밀도를 높이는 일에는 주의를 기울여야 한다. 실수가 발생할 수 있고 잘못된 타입은 있는 것 보다 못하기 때문이다.</p>\n<pre><code class=\"language-ts\">interface Geometry {\n  coordinate: number[] | number[][] | number[][][]\n}\n</code></pre>\n<p>위와 같은 코드에서 coordinate가 위도, 경도로 이루어져있다고 생각하고 타입이 너무 크다고 판단하여 [number, number] 타입으로 변형하였다. 기존에 고도라는 개념이 있어 number[]라고 표현이 되어있던 것이고, 모든 코드에 오류가 발생하게 된다.</p>\n<p>타입을 정교하게 만들어서 부정확함을 바로잡는 방법 대신 테스트를 추가하여 놓친 부분이 없는지 확인하는 방식을 사용해도 좋다. 타입을 정제할 때, 볼쾌한 골짜기 은유를 생각해보면 도움이 될 수 있다.</p>\n<h1>데이터가 아닌 API와 명세를 보고 타입 만들기</h1>\n<p>API 명세서를 읽어보지 않고 데이터만을 받아서 타입을 작성했을 때 예상치않은 오류가 발생할 수 있다.\nAPI 명세서를 참고해서 타입을 만들거나, 공식 타입 선언을 다운로드 받아서 사용하면 좋다.</p>\n<h1>해당 분야의 용어로 타입 이름 짓기</h1>\n<p>해당 분야의 용어는 몇십년에 지나면서 다듬어져 왔다. 가독성을 더 높여준다.</p>\n<p>또한 이미 체계적으로 분류가 잡혀져 있는 경우가 있다. 기후라는 타입을 정의하기 위해서는 미리 정의된 쾨펜 기후 분류 등을 사용하면 편리하고 유지보수에 용이하다.\n유지보수에 용이한 이유는 코드를 작성한 사람에게 조언을 구할 필요가 없기 때문이다.</p>\n<p>동일한 의미를 나타날 때는 꼭 같은 단어를 사용해야한다.</p>\n<h1>공식 명칭에는 상표 붙이기</h1>\n<p>구조적 타이핑의 특성 때문에 가끔 코드가 이상한 결과를 낼 수 있다.</p>\n<pre><code class=\"language-ts\">interface Vector2D {\n  x: number\n  y: number\n}\n\nfunction calculateNorm(p: Vector2D) {\n  return Math.sqrt(p.x * p.x + p.y * p.y)\n}\n\nconst vector3D = { x: 1, y: 2, z: 5 }\ncalculateNorm(vector3D)\n</code></pre>\n<p>위의 코드는 구조적 타이핑 관점에서 오류가 발생하지 않는다. 하지만 수학적으로 따지면 2차원 벡터를 사용하는 것이 이치에 맞다.\n3차원 벡터를 허용하지 않게 하려면 공식 명칭을 사용하면 된다.\n값의 관점에서 vector2D라고 정의해주는 것이다. 타입스크립트에서 흉내내기 위해서는 상표를 붙이면 된다.</p>\n<pre><code class=\"language-ts\">interface Vector2D {\n  _brand: \"2d\"\n  x: number\n  y: number\n}\n\ncalculateNorm({ x: 1, y: 2, _brand: \"2d\" }) //1\ncalculateNorm({ x: 1, y: 2, z: 5, _brand: \"2d\" }) //2\n</code></pre>\n<p>2번째 함수 호출부에서 처럼 악의적으로 공식 명칭을 흉내내는 것을 방지하지는 못한다. 다만 프로그래머에게 실수를 알려주기에는 충분하다.</p>\n<p>상표 기법은 타입 시스템에서 동작하지만 런타임에 상표를 검사하는 것과 동일한 효과를 얻을 수 있다. 타입 시스템으로 런타임 오버헤드가 없고 속성이 없는 string 또는 number와 같은 내장 타입도 상표화 할 수 있다.</p>\n<p>절대 경로를 이용하여 파일 시스템에 접근하는 함수를 통해서 가정해보자.\n런타임에는 절대 경로로 시작하는지 체크하기가 쉽지만, 타입 시스템에서는 판단하기 어렵기 때문에 상표 기법을 사용한다.</p>\n<pre><code class=\"language-ts\">type AbsolutePath = string &#x26; { _brand: \"abs\" }\nfunction listAbsolutePath(path: AbsolutePath) {}\nfunction isAbsolutePath(path: string): path is AbsolutePath {\n  return path.startsWith(\"/\")\n}\n</code></pre>\n<p>AbsolutePath 타입의 경우 string이면서 _brand 속성을 가지는 객체라는게 애초에 말이 안된다. 온전히 타입 시스템의 영역이다.</p>\n<p>만일 절대경로인지, 상대경로인지 확실하지 않다면 타입 가드를 사용해서 오류를 방지할 수 있다.</p>\n<pre><code class=\"language-ts\">function someFunc(path: string) {\n  if (isAbsolutePath(path)) {\n    listAbsolutePath(path)\n  }\n}\n</code></pre>\n<p>로직 분기 대신 타입 단언문을 사용해도 되지만, 타입 단언문은 사용을 지양해야한다.</p>\n<p>추가적인 예시로는 오름차순으로 정렬된 배열인지 체크하는 타입이다.</p>\n<pre><code class=\"language-ts\">type SortedList&#x3C;T> = T[] &#x26; { _brand: \"sorted\" }\nfunction isSorted&#x3C;T>(arr: T[]): arr is SortedList&#x3C;T> {\n  for (let i = 1; i &#x3C; arr.length; i++) {\n    if (arr[i - 1] > arr[i]) return false\n  }\n  return false\n}\n\nfunction binarySearch&#x3C;T>(arr: SortedList&#x3C;T>, target: number): number {\n  //....\n}\n</code></pre>","id":"93f20b56-f5b3-56b5-baf6-201ed50da5de"},{"fields":{"slug":"/알고리즘/부대복귀/"},"excerpt":"문제 링크 해결 전략 위 문제는 한 노드에서 다른 노드의 최단거리 찾기 문제이다. 즉 다익스트라 알고리즘을 사용하면 문제를 해결할 수 있다. 다익스트라 알고리즘은 그리디 알고리즘의 일종인데 방문한 노드에서 최단거리를 가지는 노드를 찾는 알고리즘에서 시간 복잡도 차이가 발생한다.\n노드의 방문 여부를 통해 최단거리를 찾는 알고리즘의 경우 모든 노드를 순회해야하므로 O(n^2)의 시간 복잡도를 가진다.\n하지만 문제의 경우 n이 100,000으로 O…","frontmatter":{"date":"2022-11-22T00:00:00.000Z","description":"다익스트라 알고리즘","title":"부대복귀"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/132266\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>위 문제는 한 노드에서 다른 노드의 최단거리 찾기 문제이다. 즉 다익스트라 알고리즘을 사용하면 문제를 해결할 수 있다.</p>\n<p>다익스트라 알고리즘은 그리디 알고리즘의 일종인데 방문한 노드에서 최단거리를 가지는 노드를 찾는 알고리즘에서 시간 복잡도 차이가 발생한다.\n노드의 방문 여부를 통해 최단거리를 찾는 알고리즘의 경우 모든 노드를 순회해야하므로 O(n^2)의 시간 복잡도를 가진다.\n하지만 문제의 경우 n이 100,000으로 O(n^2)으로 해결할 수 없다.</p>\n<p>이 때 힙을 사용하면 O(NlogN)의 시간 복잡도로 최단거리를 가지는 노드를 찾을 수 있다. 따라서 우선순위 큐를 활용해서 다익스트라 알고리즘을 사용하면 문제의 정답을 구할 수 있다.</p>\n<p>이 문제의 경우 특이한 점이 하나 있다. 보통 노드간의 거리가 다른데 이 문제는 모든 노드 사이의 거리가 1이다. 따라서 사실 우선순위큐를 사용하지 않고 일반 큐를 사용해도 좋다. 그 이유는 모든 노드 사이의 거리가 1이므로 큐를 통해서 순차적으로 배출되는 노드가 최단거리를 가지는 노드임이 보장되기 때문이다. (+1씩 거리가 더해져서 큐에 들어가기 때문.)</p>\n<h1>정답 코드</h1>\n<h2>우선순위 큐를 사용한 방식</h2>\n<pre><code class=\"language-js\">class PriorityQueue {\n  constructor() {\n    this.queue = []\n  }\n\n  swap(aIndex, bIndex) {\n    const temp = this.queue[aIndex]\n    this.queue[aIndex] = this.queue[bIndex]\n    this.queue[bIndex] = temp\n  }\n\n  enqueue(priority, value) {\n    const node = { priority, value }\n    this.queue.push(node)\n\n    let currentIndex = this.queue.length - 1\n    let parentIndex = Math.floor((currentIndex - 1) / 2)\n\n    while (\n      parentIndex >= 0 &#x26;&#x26;\n      this.queue[parentIndex].priority &#x3C; this.queue[currentIndex].priority\n    ) {\n      this.swap(parentIndex, currentIndex)\n      currentIndex = parentIndex\n      parentIndex = Math.floor((currentIndex - 1) / 2)\n    }\n  }\n\n  dequeue() {\n    if (this.queue.length === 0) return undefined\n    if (this.queue.length === 1) return this.queue.pop()\n\n    const root = this.queue[0]\n    const end = this.queue.pop()\n    this.queue[0] = end\n\n    let currentIndex = 0\n    let leftIndex = 1\n    let rightIndex = 2\n\n    while (\n      (this.queue[leftIndex] &#x26;&#x26;\n        this.queue[currentIndex].priority &#x3C; this.queue[leftIndex].priority) ||\n      (this.queue[rightIndex] &#x26;&#x26;\n        this.queue[currentIndex].priority &#x3C; this.queue[rightIndex].priority)\n    ) {\n      if (\n        !this.queue[rightIndex] ||\n        this.queue[leftIndex].priority > this.queue[rightIndex].priority\n      ) {\n        this.swap(currentIndex, leftIndex)\n        currentIndex = leftIndex\n      } else {\n        this.swap(currentIndex, rightIndex)\n        currentIndex = rightIndex\n      }\n      leftIndex = currentIndex * 2 + 1\n      rightIndex = currentIndex * 2 + 2\n    }\n    return root\n  }\n\n  size() {\n    return this.queue.length\n  }\n}\n\nfunction solution(n, roads, sources, destination) {\n  const distance = Array(n + 1).fill(1000001)\n  const visited = Array(n + 1).fill(false)\n\n  const graph = Array(n + 1)\n    .fill()\n    .map(_ => [])\n\n  roads.forEach(([start, end]) => {\n    graph[start].push(end)\n    graph[end].push(start)\n  })\n\n  const priorityQueue = new PriorityQueue()\n\n  distance[destination] = 0\n  priorityQueue.enqueue(0, destination)\n\n  while (priorityQueue.size() > 0) {\n    const { priority: dist, value: node } = priorityQueue.dequeue()\n    if (d[node] > -dist) continue\n\n    graph[node].forEach(end => {\n      distance[end] = Math.min(distance[end], distance[node] + 1)\n      if (distance[end] === distance[node] + 1) {\n        priorityQueue.enqueue(-distance[end], end)\n      }\n    })\n  }\n  return sources.map(v => {\n    return distance[v] === 1000001 ? -1 : distance[v]\n  })\n}\n</code></pre>\n<h2>일반 큐를 사용한 방식</h2>\n<pre><code class=\"language-js\">class Queue {\n  constructor() {\n    this.front = 0\n    this.rear = 0\n    this.queue = []\n  }\n\n  enqueue(data) {\n    this.queue[this.rear++] = data\n  }\n\n  dequeue() {\n    const value = this.queue[this.front]\n    delete this.queue[this.front]\n    this.front++\n    return value\n  }\n\n  size() {\n    return this.rear - this.front\n  }\n}\n\nfunction solution(n, roads, sources, destination) {\n  const graph = Array(n + 1)\n    .fill()\n    .map(_ => [])\n\n  roads.forEach(([start, end]) => {\n    graph[start].push(end)\n    graph[end].push(start)\n  })\n\n  const distance = Array(n + 1).fill(Infinity)\n  const queue = new Queue()\n  queue.enqueue(destination)\n\n  distance[destination] = 0\n\n  while (queue.size() > 0) {\n    const node = queue.dequeue()\n    graph[node].forEach(end => {\n      distance[end] = Math.min(distance[end], distance[node] + 1)\n      if (distance[end] === distance[node] + 1) {\n        queue.enqueue(end)\n      }\n    })\n  }\n\n  return sources.map(v => {\n    return distance[v] === Infinity ? -1 : distance[v]\n  })\n}\n</code></pre>","id":"d744896b-c420-5e9c-8733-53f9a9bcc773"},{"fields":{"slug":"/programming/이펙티브타입스크립트/3장/"},"excerpt":"타입 추론 타입스크립트는 타입 추론을 적극적으로 수행한다. 타입 구문의 수를 엄청나게 줄여주기에 코드의 전체적인 안정성이 향상된다. 숙련된 타입스크립트 개발자는 비교적 적은 수의 구문을 사용한다. 추론 가능한 타입을 사용해 장황한 코드 방지하기 위의 예시에서 a에 굳이 number라는 타입을 명시해줄 필요가 없다. 타입스크립트에서 자동으로 추론해주기 때문이다. 객체의 경우 객체의 경우에도, 타입 추론이 의도한 타입과 동일하다면 굳이 타입을 명…","frontmatter":{"date":"2022-11-01T00:00:00.000Z","description":"타입 추론","title":"이펙티브 타입스크립트 3장"},"html":"<h1>타입 추론</h1>\n<p>타입스크립트는 타입 추론을 적극적으로 수행한다. 타입 구문의 수를 엄청나게 줄여주기에 코드의 전체적인 안정성이 향상된다. 숙련된 타입스크립트 개발자는 비교적 적은 수의 구문을 사용한다.</p>\n<h1>추론 가능한 타입을 사용해 장황한 코드 방지하기</h1>\n<pre><code class=\"language-ts\">const a: number = 3\n</code></pre>\n<p>위의 예시에서 a에 굳이 number라는 타입을 명시해줄 필요가 없다. 타입스크립트에서 자동으로 추론해주기 때문이다.</p>\n<h2>객체의 경우</h2>\n<p>객체의 경우에도, 타입 추론이 의도한 타입과 동일하다면 굳이 타입을 명시해줄 필요가 없다.</p>\n<pre><code class=\"language-ts\">interface Person {\n  name: string\n  born: {\n    where: string\n    when: string\n  }\n}\nconst person: Person = {\n  name: \"sssdf\",\n  born: {\n    where: \"Seoul\",\n    when: \"2000-11-01\",\n  },\n}\n</code></pre>\n<p>person 객체만 정의하면 Person과 같은 타입이 자동으로 추론된다. 하지만 만일 객체 리터럴을 정의할 때 잉여속성 체크를 하고 싶다면 꼭 타입을 명시해야한다. 잉여속성 체크를 함으로써, 객체가 사용되는 쪽의 코드에서 문제가 발생하는 것이 아니고, 객체가 정의된 곳에서 문제가 발생되어 문제를 쉽게 파악할 수 있다.</p>\n<h2>리팩토링을 쉽게</h2>\n<p>타입이 추론되면 리팩토링도 쉽게 할 수 있다. 어떻게 보면 기존에 정의된 타입을 이용한다는 것으로 받아들이면 된다.</p>\n<pre><code class=\"language-ts\">interface Product {\n  id: number\n  name: string\n  price: number\n}\n\nfunction logProduct(product: Prodcut) {\n  const id: number = product.id\n  const name: string = product.name\n  const price: number = product.price\n}\n</code></pre>\n<p>위의 예시에서 만일 id가 number 타입이 아닌 string 타입으로 변경되면 logProduct의 함수 const id 부분이 타입 에러가 발생할 것이다. 위와 같은 경우에는 비구조화 할당문으로 리팩토링 해주는게 좋다. 모든 지역 변수의 타입 추론이 되도록 하기 때문이다.</p>\n<pre><code class=\"language-ts\">function logProduct(product: Product) {\n  const { id, name, price } = product\n}\n</code></pre>\n<h2>함수</h2>\n<p>타입 정보가 있는 라이브러리에서 콜백 함수의 매개변수 타입은 자동으로 추론된다. express HTTP 서버 라이브러리를 사용하는 request와 response 타입 선언은 필요하지 않는다.</p>\n<p>함수의 반환에 타입을 명시하면 객체 리터럴에 타입을 명시하는 것과 유사하게 사용되는 쪽의 코드에서 문제가 발생한 곳이 아니고, 구현부에서 문제를 발견할 수 있다.</p>\n<pre><code class=\"language-ts\">const cache: { [ticker: string]: number } = {}\nfunction getQuote(ticker: string) {\n  if (ticker in cache) {\n    return cache[ticker]\n    //number\n  }\n  return fetch(\"...\")\n    .then(response => response.json())\n    .then(quote => {\n      cache[ticker] = quote\n      return quote\n    })\n  //promise\n}\n</code></pre>\n<p>위의 getQuote 함수는 if 구문에서는 number 타입을, fetch에서는 Promise를 리턴하기 때문에 프로미스가 사용되는 부분에서 타입 에러를 발생한다. 해당 문제를 해결하기 위해서는 cache[ticker]를 반환하는게 아닌, Promise.resolve(cache[ticker])를 반환해야한다.</p>\n<p>또한 함수의 반환값에 타입을 명시하면, 해당 타입을 보고 직관적으로 함수를 이해할 수 있다.</p>\n<pre><code class=\"language-ts\">type Vector2D = { x: number; y: number }\nfunction add(a: Vector2D, b: Vector2D) {\n  return { x: a.x + b.x, y: a.y + b.y }\n}\n</code></pre>\n<p>위의 add 함수는 <code>{x:number, y:number}</code> 타입으로 추론할 것이다. 하지만 Vector2D가 들어갔는데, 해당 타입이 나온다는게 개발자 입장에서는 혼란스러울 수 있다. 이럴 때 타입을 명시해주면 혼란을 줄일 수 있다.</p>\n<h1>다른 타입에는 다른 변수 사용하기</h1>\n<pre><code class=\"language-ts\">let id = \"123\"\nfetchProduct(id) // string\n\nid = 123\nfetchProductByNumber(id) //number\n</code></pre>\n<p>자바스크립트에서는 위의 패턴이 허용된다. 하지만 타입스크립트에서는 id에 string 타입이 할당되었기 때문에 그 다음에 number 타입을 할당할 수 없어 오류가 발생한다.</p>\n<pre><code class=\"language-ts\">let id: string | number = \"123\"\n</code></pre>\n<p>위와 같이 유니온 타입으로 타입을 좁혀서 정의하면 코드는 동작한다. 하지만 id를 사용할 때마다 number인지 string인지 확인해야 하기 때문에, 간단한 타입에 비해 다루기 어렵다.\n<strong>따라서 위의 경우에는 변수를 분리한다!</strong>\n변수를 분리하면 더 정확한 변수명을 지을 수 있고, const로 변수를 선언하여 코드 안정성을 향상 시킬 수 있다.</p>\n<h1>타입 넓히기</h1>\n<p>상수를 사용해서 변수를 초기화 할 때 타입을 명시하지 않으면 타입 체커는 타입을 스스로 결정해야 한다. 지정된 단일 값으로 할당 가능한 값들의 집합을 유추해야 한다는 의미이다. 이러한 과정을 타입 넓히기(widening)라고 부른다.</p>\n<pre><code class=\"language-ts\">function onlyGetABC(abc: \"a\" | \"b\" | \"c\") {\n  //...\n}\n\nlet A = \"a\"\nonlyGetABC(A)\n//타입체크 에러 발생\n</code></pre>\n<p>위의 경우 변수 A의 경우 \"a\"라고 정의하였지만, 타입 체커는 타입을 string으로 배치하였다. 타입을 넓혀야 하기 때문이다. 그리고 <code>onlyGetABC</code>는 string이 아닌 <code>\"a\"</code>를 매개변수로 받기 때문에 타입 에러가 발생한다.</p>\n<pre><code class=\"language-ts\">const mixed = [\"x\", 1]\n</code></pre>\n<p>위의 경우 나올 수 있는 경우의 수가 매우 많다. 타입 시스템은 작성자의 의도를 추측하지만, 아무리 영리하더라도 사람의 마음까지는 읽을 수 없다. 위의 경우 작성자는 튜플로 추론되기를 바랬으나 <code>(string|number)[]</code>으로 추론된다.</p>\n<h2>넓히기를 제어하는 방법</h2>\n<h3>let 대신 const로 선언하기.</h3>\n<p>let 대신 const로 선언하면 더 좁은 타입이 된다.</p>\n<pre><code class=\"language-ts\">const A = \"a\"\nonlyGetABC(A)\n//정상\n</code></pre>\n<p>위의 예시에서 A는 <code>\"a\"</code>로 추론된다.\n그러나 const는 만능이 아니다. 객체와 배열의 경우에는 여전히 문제가 존재한다.</p>\n<p>객체의 경우 타입스크립트의 넓히기 알고리즘은 각 요소를 let으로 할당된 것으로 다룬다. 그리고 다른 속성을 추가하지 못한다.</p>\n<h3>명시적 타입 구문을 제공하기</h3>\n<pre><code class=\"language-ts\">const v: {x:1|2|3} {\n  x:1\n}\n</code></pre>\n<h3>타입 체커에 추가적인 문맥을 제공하는 것</h3>\n<p>이후 아이템에서 다룬다고함.</p>\n<h3>const 단언문 사용</h3>\n<p>const로 변수를 선언하는 것과 다른 의미이다.\n값 뒤에 as const를 작성하면 타입스크립트는 최대한 좁은 타입으로 추론한다. 배열을 튜플 타입으로 추론할 때에도 as const를 사용할수 있다.</p>\n<h1>타입 좁히기</h1>\n<p>타입 넓히기의 반대 개념이다. 대표적인 예시는 null 체크이다.</p>\n<pre><code class=\"language-ts\">const el = document.getElementById(\"foo\")\nif (el) {\n  el.innerHTML = \"hello\"\n} else {\n  alert(\"no element\")\n}\n</code></pre>\n<p>위의 예시에서는 분기 처리를 통해 el의 타입이 HTMLElement임을 확인하였다.</p>\n<h2>타입 좁히기 종류</h2>\n<ol>\n<li>\n<p>instanceof를 사용</p>\n</li>\n<li>\n<p>내장 함수(Array.isArray 등)</p>\n</li>\n<li>\n<p>조건문</p>\n<ul>\n<li>\n<p>조건문을 통해서 타입을 좁힐 때는 유의해주어야 한다.</p>\n<pre><code class=\"language-ts\">function foo(x?: number | string | null) {\n  if (!x) {\n  }\n}\n</code></pre>\n<p>위의 예시의 경우 0, '' 모두 falsy이기 때문에 타입이 전혀 좁혀지지 않았다.</p>\n<pre><code class=\"language-ts\">const el = document.getElementById(\"foo\")\nif (typeof el === \"object\") {\n}\n</code></pre>\n<p>위의 예시도 문제는 object도 null이기 떄문에 타입이 좁혀지지 않았다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>명시적 태그를 붙이는 방법</p>\n<ul>\n<li>객체 내에 type 속성을 넣어주고 값을 넣어주는 패턴 등이 존재한다.</li>\n<li>태그된 유니온, 구별된 유니온이라고 불린다.</li>\n</ul>\n</li>\n<li>\n<p>커스텀 함수 도입</p>\n<pre><code class=\"language-ts\">function isInputElement(el: HTMLElement): el is HTMLInputElement {\n  return \"value\" in el\n}\n\nfunction getElementContent(el: HTMLElement) {\n  if (isInputElement(el)) {\n    return el.value\n  }\n  return el.textContent\n}\n</code></pre>\n<ul>\n<li>위와 같은 패턴을 사용자 정의 타입 가드라고 한다.</li>\n</ul>\n<pre><code class=\"language-ts\">const member = [\"a\", \"b\", \"c\", \"d\"]\nconst people = [\"a\", \"e\"]\n\nconst onlyMember = people.map(who => member.find(v => v === who))\n//(string | undefined)[]\n\nconst filteredOnlyMember = people\n  .map(who => member.find(v => v === who))\n  .filter(who => who !== undefined)\n//(string | undefined)[]\n</code></pre>\n<p>위의 경우 filteredOnlyMember 변수도 (string | undefined)[]이다. 이럴 때 타입 가드를 사용하면 타입을 좁힐 수 있다.</p>\n<pre><code class=\"language-ts\">function isDefined&#x3C;T>(x: T | undefined): x is T {\n  return x !== undefined\n}\n\nconst filteredOnlyMember = people\n  .map(who => member.find(v => v === who))\n  .filter(isDefined)\n//string[]\n</code></pre>\n</li>\n</ol>\n<h1>한꺼번에 객체 생성하기</h1>\n<p>자바스크립트의 값은 변경되지만 일반적으로 타입스크립트의 타입은 변경되지 않는다. 객체를 생성할 때는 속성을 하나씩 추가하는 것보다는 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리하다.</p>\n<pre><code class=\"language-ts\">const pt = {}\npt.x = 3\npt.y = 5\n//타입 체크 오류 발생.. {} 형식에 x가 존재하지 않습니다.\n</code></pre>\n<p>아래와 같은 패턴으로 정의하면 오류가 발생하지 않는다.</p>\n<pre><code class=\"language-ts\">const pt = { x: 3, y: 5 }\n</code></pre>\n<p>객체를 반드시 제각각 나눠서 만들어야 한다면 타입 단언문을 사용해야한다.</p>\n<pre><code class=\"language-ts\">interface Point {\n  x: number\n  y: number\n}\nconst pt = {} as Point\npt.x = 3\npt.y = 5\n</code></pre>\n<h2>전개 연산자</h2>\n<p>객체를 합칠 때는 전개 연산자를 사용한다.</p>\n<pre><code class=\"language-ts\">const pt = { x: 3, y: 4 }\nconst id = { name: \"pythagoras\" }\nconst namedPoint = {}\nObject.assign(namedPoint, pt, id)\nnamedPoint.name\n//타입 에러 발생.. name 속성이 없다.\n\nconst namedPoint = { ...pt, ...id }\nnamedPoint.name\n</code></pre>\n<h3>조건부 속성</h3>\n<pre><code class=\"language-ts\">declare let hasMiddle: boolean\nconst firstLast = { first: \"harry\", last: \"potter\" }\nconst president = { ...firstLast, ...(hasMiddle ? { middle: \"S\" } : {}) }\n</code></pre>\n<p>위의 예시에는 middle이 선택적 속성을 가지는 것으로 추론된다.</p>\n<p>만일 전개 연산자로 여러 속성을 추가하면 어떻게 될까? 이때는 유니온 속성으로 추론된다. 속성이 함께 정의되기 때문에 유니온을 사용하는게 값의 집합을 더 정확히 표현할 수 있기 때문이다.</p>\n<p>유니온 방식이 아닌, 선택적 필드로 만들고 싶다면 헬퍼 함수를 사용해야한다.</p>\n<pre><code class=\"language-ts\">function addOptional&#x3C;T extends object, U extends object>(\n  a: T,\n  b: U | null\n): T &#x26; Partial&#x3C;U> {\n  return { ...a, ...b }\n}\n</code></pre>\n<p><strong>객체나 배열을 변환해서 새롤운 객체나 배열을 생성하고 싶다면 루프 대신 내장된 함수형 기법 또는 로대시 같은 유틸리티 라이브러리를 만드는게 한꺼번에 객체 생성하기 관점에서 옳다.</strong></p>\n<h1>일관성 있는 별칭 사용하기</h1>\n<pre><code class=\"language-ts\">const person = {\n  age: 20,\n  name: \"jinwook\",\n  location: { City: \"Seoul\", State: \"gdd\" },\n}\nconst loc = person.location\n</code></pre>\n<p>위의 loc 변수가 별칭이다. 별칭의 속성값을 변경하면 원본 객체의 속성값도 변경한다. 따라서 별칭을 남발하면 제어 흐름을 파악하기 어렵다.</p>\n<p>만일 location의 분기를 여러번 나눠야되는 로직이 있다면 우리는 location 별칭을 사용해서 코드를 짧게 유지할 것이다.</p>\n<pre><code class=\"language-ts\">function saveLocation1(person) {\n  if (person.location) {\n  }\n  //...\n}\n\nfunction saveLocation2(person) {\n  const personLocation = person.location\n  if (person.location) {\n    fn(personLocation)\n    //error 발생.. personLocation은 null일 수 있음.\n    //...\n  }\n}\n\nfunction saveLocation3(person) {\n  const { location } = person\n  if (location) {\n    //...\n  }\n}\n</code></pre>\n<p>saveLocation2의 경우 객체의 속성을 별칭으로 정의했다. 하지만 아래 분기에서는 <code>person.location</code>을 확인하였고 <code>personLocation</code>은 확인하지 않았다. <code>person.location</code>은 <code>null</code>이 사라져 타입이 좁혀졌으나 <code>personLocation</code>은 그대로이다. 별칭을 사용할 것이면 일관성있게 <code>saveLocation3</code>처럼 사용해야한다. 또한 비구조화 할당을 사용해서 일관된 이름을 사용하면 더더욱 좋다.</p>\n<h2>별칭으로 인한 혼동</h2>\n<pre><code class=\"language-ts\">const { bbox } = polygon\nif (!bbox) {\n  caculatePolygonBbox(polygon)\n}\n</code></pre>\n<p>위의 예시에서 bbox와 polygon.bbox는 이제 다른 값을 참조한다..! bbox의 경우 비구조화 할당으로 인해 새로운 변수에 넣었기 때문이다.</p>\n<pre><code class=\"language-ts\">function fn(p: Polygon) {}\n\npolygon.bbox //BoundingBox | undefined\n\nif (polygon.bbox) {\n  fn(polygon)\n  polygon.bbox //BoundingBox\n}\n</code></pre>\n<p>위의 예시에서 fn은 polygon의 bbox 속성을 제거할 수도 있다. 하지만 타입은 그대로 유지된다. 타입스크립트에서 함수가 타입 정제를 무효화하지 않는다고 가정하기 때문이다. 따라서 위의 경우에는 비구조화 할당을 사용해서 새로운 지역변수를 정의하면 타입은 정확히 유지되지만 원본값은 변함이 없는 장점을 누릴 수 있다.</p>\n<h1>비동기 코드에는 콜백 대신 async 함수 사용하기</h1>\n<p>콜백보다는 프로미스, async 함수를 사용하는 것이 코드도 간결하며 타입을 추론하기 쉽다.\n선택의 여지가 있다면 프로미스 보다는 async를 사용하는게 좋다.</p>\n<ol>\n<li>코드가 더 간결하고 직관적이다.</li>\n<li>항상 프로미스를 반환한다.</li>\n</ol>\n<p>async 함수에서 프로미스를 반환하면 또 다른 프로미스로 래핑되지 않는다. Promise&#x3C;<T>>가 아닌 Promise<T>를 반환한다.</p>\n<h1>타입 추론에 문맥이 어떻게 사용되는지 이해하기</h1>\n<pre><code class=\"language-ts\">type Lanuage = \"JavaScript\" | \"TypeScript\"\nfunction setLanuage(lanuage: Lanuage) {\n  //...\n}\n\nsetLanuage(\"JavaScript\") //1\nlet js = \"JavaScript\"\nsetLanuage(js) //2\n</code></pre>\n<p>위의 예시에서 첫 번째로 호출한 함수의 경우 에러가 발생하지 않지만, 두 번째로 호출한 함수의 경우 에러가 발생한다. 이 문제를 해결할 수 있는 방법은 2가지이다.</p>\n<ol>\n<li>타입 선언\n<pre><code class=\"language-ts\">let js: Lanuage = \"JavaScript\"\n</code></pre>\n</li>\n<li>js를 상수로 만드는 것이다.\n<pre><code class=\"language-ts\">const js = \"JavaScript\"\n</code></pre>\n</li>\n</ol>\n<h2>튜플 사용 시 주의 점</h2>\n<pre><code class=\"language-ts\">function panTo(where: [number, number]) {}\n\npanTo([10, 10])\nconst loc = [10, 10]\npanTo(loc)\n</code></pre>\n<p>위의 예시의 경우 loc를 상수로 선언했음에도 불구하고 타입 에러가 발생한다. 그 이유는 loc를 <code>number[]</code>로 추론했기 때문이다. 이 경우도 위와 유사하다. 타입 선언을 하거나 상수로 정의해준다.</p>\n<pre><code class=\"language-ts\">const loc = [10, 10] as const\n</code></pre>\n<p>기존에 const는 참조값이 바뀌지 않는 것이였는데, as const로 정의하면 내부까지 상수라는 사실을 타입스크립트에게 알려준다.</p>\n<p>하지만 위의 코드는 또 문제가 있다. loc의 경우 readonly 상태를 가지게 되는데, panTo가 매개변수의 내용이 불변을 보장하지 못하는 것이다. panTo의 매개변수에 readonly 키워드를 적용해줌으로써 해당 문제를 해결할 수 있다.</p>\n<p>as const를 사용할 때 유의해야 하는 점은 타입 정의에 실수가 있다면 타입이 정의되는 곳이 아닌, 호출되는 곳에서 발생한다는 것을 유의해야한다.</p>\n<h1>함수형 기법과 라이브러리로 타입 흐름 유지하기</h1>\n<p>자바스크립트에서는 서드파티 라이브러리의 도입을 신중해야한다. 타입을 알 수 없기 때문에 서드파티 라이브러리를 사용해서 코드를 줄이는데 시간이 오래들기 때문이다. 반면에 타입스크립트는 타입이 명시되어있어 서드파티 라이브러리 도입에 큰 문제가 없다. 서드파티 라이브러리를 활용해서 생산성을 높이는 편이 낫다.</p>","id":"28051e14-adc7-5f08-908e-62ff60528369"},{"fields":{"slug":"/tech/node.js/"},"excerpt":"Node.js란 Node.js는 Chrome의 V8 엔진으로 빌드된 자바스크립트 런타임이다. 기존에 자바스크립트는 브라우저에서만 구동 가능한 언어였다. 구글이 매우 빠른 자바스크립트 엔진인 V8을 출시하자 이를 바탕으로 브라우저 외 환경에서 자바스크립트 런타임을 구축하기 시작했다. 이벤트 기반 이벤트 기반이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미한다. 예시로 클릭이나 네트워크 요청 등이 있을 수 있다. 논 블로킹 논 …","frontmatter":{"date":"2022-10-19T00:00:00.000Z","description":"Node.js, Express, MongoDB란?","title":"Node.js, Express, MongoDB"},"html":"<h1>Node.js란</h1>\n<p>Node.js는 Chrome의 V8 엔진으로 빌드된 자바스크립트 런타임이다. 기존에 자바스크립트는 브라우저에서만 구동 가능한 언어였다. 구글이 매우 빠른 자바스크립트 엔진인 V8을 출시하자 이를 바탕으로 브라우저 외 환경에서 자바스크립트 런타임을 구축하기 시작했다.</p>\n<h2>이벤트 기반</h2>\n<p>이벤트 기반이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미한다. 예시로 클릭이나 네트워크 요청 등이 있을 수 있다.</p>\n<h2>논 블로킹</h2>\n<p>논 블로킹이란 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행함을 뜻한다. 반대로 블로킹이란 이전 작업이 끝나야만 다음 작업을 수행하는 것을 의미한다. 논 블로킹 방식은 모든 작업이 동시에 처리될 수 있다는 전제하에 블로킹 방식보다 훨씬 빠르다. (ex. 시간이 오래 걸리는 블로킹 코드를 setTimeout으로 묶어 백그라운드에서 처리하도록 함.)</p>\n<h2>싱글 스레드</h2>\n<p>엄밀히 말하자면 싱글 스레드로 동작하지 않는다. 노드를 실행하면 프로세스를 하나 생성하고, 해당 프로세스에서 스레드들을 생성하는데 내부적으로 스레드를 여러개 생성한다. 그중에서 우리가 제어할 수 있는 스레드는 하나이기에 싱글 스레드라고 여겨진다. Node.js는 싱글 스레드 논블로킹 방식으로 움직이기 때문에 매우 효율적으로 일처리가 가능하고 멀티 스레드에 비해서 프로그래밍이 비교적 쉽다는 장점이 있다. (워커 스레드라는 기능을 사용하면 멀티 스레드 구현이 가능하다. 스레드풀의 경우는 자동으로 멀티스레드를 사용한다. 암호화, 파일 입출력 등 작업에서 사용된다.)</p>\n<h2>그렇다면 언제 Node.js를 사용하면 좋을까?</h2>\n<p>노드는 싱글 스레드, 논블로킹 모델로 사용하므로 해당 모델의 장단점과 크게 다르지 않다.\n서버는 기본적으로 I/O를 많이 수행하는데 노드는 많은 양의 I/O 작업을 논블로킹 모델로 효율적으로 처리할 수 있다. 하지만 CPU 부하가 큰 작업에는 적합하지 않다. 스레드 하나가 혼자서 감당하기 어렵기 때문이다. 정리를 하자면, 개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는 데 적합하다. 네트워크, 데이터베이스, 디스크 작업 같은 I/O에 특화되어 있기 때문이다. 예시로 실시간 채팅 어플리케이션, 주식 차트, JSON 데이터를 제공하는 API 서버가 노드를 많이 사용한다.</p>\n<p>싱글 스레드 방식의 프로그래밍은 러닝 커브가 멀티 스레드 방식보다 상대적으로 낮다. 하지만 싱글 스레드의 경우 하나뿐인 스레드가 오류가 발생하면 멈추기 때문에 잘 관리하도록 해야한다.</p>\n<h1>Express란</h1>\n<p>Express는 웹 서버 프레임워크이다. 웹 서버를 구성하기 위해서 많은 편의 기능들이 내장되어 있다.\n대표적으로 미들웨어와 라우팅이라는 장점이 있다.</p>\n<p>Express의 핵심은 미들웨어라고 해도 과언이 아니다. 뒤에 나오는 라우터도 미들웨어의 일종이다. 미들웨어를 통해 요청과 응답에 다양한 기능을 추가할 수 있다. 로그인 여부 체크 등..</p>\n<p>라우팅의 경우 http 모듈을 사용해서 처리하려면, 굉장히 많은 분기가 필요하지만 Express 라우팅 기능을 사용하면 손쉽게 가능하다.</p>\n<h1>MongoDB란?</h1>\n<p>MongoDB는 NoSQL 데이터베이스로 자바스크립트 문법을 사용한다는 특징이 있다. MongoDB를 사용하면 자바스크립트만으로 웹 애플리케이션을 구축할 수 있다.</p>\n<h2>NoSQL, SQL 특징</h2>\n<p>NoSQL에는 고정된 테이블이 없다. SQL의 경우 테이블을 만들 때, 칼럼과 자료형, 옵션 등을 정의하지만 몽고디비는 컬렉션을 만들면 끝이다. 어떠한 데이터든 들어갈 수 있다.</p>\n<p>MongoDB는 MySQL과 달리 JOIN 기능이 없다. 흉내를 낼수는 있지만, 하나의 쿼리로 여러 테이블을 합치는 작업이 항상 가능하지는 않다.</p>\n<p>몽고디비의 가장 큰 장점은 확장성과 가용성이다. 데이터의 일관성을 보장해주는 기능이 약한 대신, 데이터를 빠르게 넣을 수 있고 여러 서버에 데이터를 쉽게 분산시킬 수 있다.</p>\n<p>어플리케이션에 꼭 한가지 데이터베이스만 써야되는 것은 아니다. 상황에 맞게 올바른 데이터베이스를 선택하면 된다. 데이터의 일관성이 필요한 항공 예약의 경우는 MySQL로, 채팅 혹은 빅데이터와 같은 일관성이 필요없고 데이터 양이 많은 경우는 MongoDB 도입을 고려해볼 수 있다.</p>\n<h2>Mongoose란?</h2>\n<p>ODM(Object Document Mapping)이라고 불린다. 몽고디비 자체가 이미 자바스크립트인데 굳이 자바스크립트 객체와 매핑시키는 이유는 몽고디비에 없어서 불편한 기능들을 몽구스가 보완해주기 때문이다.\n(참고. MySQL은 ORM은 시퀄라이즈가 있다.)</p>\n<p><em>ODM이란 프로그래밍 언어 Object와 Document를 매핑시켜 호환성을 만들어내고 간편한 CRUD를 가능케한다.</em></p>\n<p>스키마라는 기능을 사용할 수 있다. NoSQL은 테이블이 없어서 자유롭게 데이터를 넣을 수 있지만, 때로는 자유로움이 불편함을 초래한다. 잘못된 자료형을 넣을 수 있고 다른 도큐멘트에는 없는 필드의 데이터를 넣을 수도 있다. 몽구스는 몽고디비에 데이터를 넣기 전에 노드 서버단에서 데이터를 한번 필터링 하는 역할을 한다.</p>\n<p>MySQL에 있는 JOIN 기능을 populate로 어느정도 보완한다. 관계가 있는 데이터를 쉽게 가져올 수 있다. 쿼리 한번에 데이터를 합쳐서 가져오는 것은 아니지만, 이 작업을 우리가 직접 하지 않아도 되므로 편리하다.</p>\n<h1>참고</h1>\n<p><a href=\"http://www.yes24.com/Product/Goods/91860680\">Node.js 교과서 개정 2판</a></p>","id":"c8a81d5e-a70b-5c15-b698-7a380d614956"},{"fields":{"slug":"/cs/운영체제/프로세스&쓰레드/"},"excerpt":"프로세스 프로세스는 실행중인 프로그램으로, 실행 파일이 memory에 적재되어 CPU를 할당받아 실행되는 것을 process라고 한다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받고 이것들을 총칭하여 프로세스라고 한다. 프로세스 메모리 구조 code 영역 - 실행한 프로그램의 코드가 저장되는 메모리 영역 data 영역 - 프로그램의 전역 변수가 저장되는 영역 heap 영역 - 동적으로 할당되는 메모리 영역 stack 영역 - 함수 호…","frontmatter":{"date":"2022-10-18T00:00:00.000Z","description":"프로세스와 쓰레드의 개념과 차이점","title":"프로세스와 쓰레드"},"html":"<h1>프로세스</h1>\n<p><strong>프로세스는 실행중인 프로그램으로,</strong> 실행 파일이 memory에 적재되어 CPU를 할당받아 실행되는 것을 process라고 한다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받고 이것들을 총칭하여 프로세스라고 한다.</p>\n<h2>프로세스 메모리 구조</h2>\n<ol>\n<li>code 영역 - 실행한 프로그램의 코드가 저장되는 메모리 영역</li>\n<li>data 영역 - 프로그램의 전역 변수가 저장되는 영역</li>\n<li>heap 영역 - 동적으로 할당되는 메모리 영역</li>\n<li>stack 영역 - 함수 호출 시 생성되는 지역변수, 매개변수가 저장되는 영역</li>\n</ol>\n<h2>프로세스 제어 블록(Process Control Block, PCB)</h2>\n<p>PCB는 특정 프로세스의 중요한 정보를 저장하고 있는 운영체제의 자료구조이다. 운영체제는 프로세스 관리를 위해 프로세스 생성과 동시에 고유한 PCB를 생성한다. 프로세스 전환이 발생하면 진행하던 작업을 종료하고 CPU를 반환해야 하는데 이 때 작업의 진행상황을 전부 PCB에 저장해놓는다. 이를 Context Switch라고 한다. 다시 CPU를 할당받으면 PCB 내역을 바탕으로 다시 작업을 수행한다.</p>\n<h3>PCB 구성</h3>\n<ul>\n<li>프로세스 식별자: process id</li>\n<li>프로세스 상태: new, ready, running 등</li>\n<li>프로그램 카운터: 프로세스가 다음에 실행할 주소</li>\n<li>CPU 스케쥴링 정보: 프로세스의 우선순위</li>\n<li>메모리 관리 정보: 페이지 테이블 또는 세그먼트 테이블과 같은 정보를 포함</li>\n</ul>\n<h2>멀티 프로세스</h2>\n<p>멀티 프로세스란 2개 이상의 프로세스가 동시에 실행되는 것을 의미한다. 동시에 실행하는 방법은 2가지이다. 1개의 CPU Core를 사용하여 여러개의 프로세스를 빠르게 전환하며 처리하는 방식, 여러개의 CPU Core를 사용하여 각각의 process를 처리하는 방식이다.</p>\n<h2>멀티 프로세스간 데이터 통신 방법</h2>\n<p>멀티 프로세스에서 프로세스끼리 원칙적으로는 데이터를 공유할 수 없다. 프로세스는 독립적인 주소 공간을 갖기 때문이다. 하지만 경우에 따라 운영체제는 프로세스 간 통신(IPC)를 제공한다. IPC 방식에는 공유 메모리 방식과 메시지 전달 방식이 있다.</p>\n<h3>공유 메모리 방식</h3>\n<p>process들이 주소 공간 일부를 공유한다. 공유한 메모리에 읽기/쓰기를 통해서 통신을 수행한다. 커널의 관여 없이 데이터를 통신할 수 있기 때문에 속도가 빠르다는 장점이 있지만, 동시에 같은 메모리 위치에 접근하게 되면 일관성 문제가 발생할 수 있다.</p>\n<h3>메시지 전달 방식</h3>\n<p>커널을 통해서 데이터를 전달해준다. 커널이 개입하기에 속도가 느리다는 단점이 있지만, 일관성 문제가 발생하지 않기 때문에 적은 데이터를 공유할 때 유리하다.</p>\n<p><em>커널이란 운영체제 중에서 항상 메모리에 올라가 있는 운영체제의 핵심 부분으로 컴퓨터 자원들을 관리하는 역할을 수행한다. 컴퓨터 자원으로는 CPU,메모리,파일,네트워크 등이 있다.</em></p>\n<h2>CPU의 처리 방식</h2>\n<p>CPU는 PC Register라는 다음에 실행될 명령어가 저장된 주솟값을 참조하여 연산을 수행한다. 프로세스가 전환될 때, 다른 프로세스의 PC Register가 등록된다.</p>\n<h2>Context Switch</h2>\n<p>한 프로세스에서 다른 프로세스로 CPU 제어권을 넘겨주는 것을 말한다. 이전의 프로세스 상태를 PCB에 저장하여 보관하고 새로운 프로세스의 PCB를 읽어서 보관된 상태를 복구한다.</p>\n<h1>쓰레드</h1>\n<p>쓰레드는 프로세스의 실행의 단위라고 할 수 있다. 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다. (스택을 제외한 나머지 메모리 영역을 공유)</p>\n<h2>stack을 스레드마다 독립적으로 할당하는 이유</h2>\n<p><strong>thread는 프로세스 내에서 독립적으로 기능을 실행한다. 즉 독립적으로 함수를 호출함을 의미한다.</strong> 독립적으로 동작하기 위해서는 thread의 stack memory 영역이 독립적이여야 한다.</p>\n<h2>PC Register를 스레드마다 독립적으로 할당하는 이유</h2>\n<p>한 프로세스 내에서도 thread끼리 context switch가 일어나기 때문에.</p>\n<h2>멀티 쓰레드</h2>\n<p>하나의 process 내에서도 여러 작업이 있다. 이런 작업들을 병렬적으로 처리하기 위해서 multi thread를 사용한다.</p>\n<h2>멀티 쓰레드의 장점</h2>\n<p>프로세스를 이용하여 동시에 처리하던 일을 쓰레드로 구현할 경우 메모리 공간과 시스템 자원 소모가 줄어든다. 쓰레드간의 통신이 필요한 경우 별도의 자원을 사용하지 않고 메모리 영역을 공유하기 때문이다. 즉 프로세스 간의 통신 방법에 비해 쓰레드 간의 통신 방법이 훨씬 간단하다. 쓰레드의 context switch는 프로세스의 context switch와 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.</p>\n<h2>멀티 쓰레드의 문제점</h2>\n<p>멀티 프로세스는 프로세스간 공유하는 자원이 없기 때문에 동일한 자원에 동시에 접근하는 일이 없었지만 멀티 쓰레드는 이 부분을 신경써줘야한다. 어떤 쓰레드가 다른 쓰레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다. 따라서 멀티 쓰레드 환경에서는 동기화 작업이 필요하다.</p>\n<p>또한 멀티 쓰레드는 적은 메모리 공간과 Context Switch가 빠르다는 장점이 있지만 오류로 인해 하나의 쓰레드가 죽으면 전체 쓰레드가 죽을 수 있다.</p>\n<h3>동기화 문제 해결 방안</h3>\n<p>mutex, semaphore 기법을 사용하여 해결할 수 있다.</p>\n<p>mutex란 1개의 스레드만이 공유 자원에 접근할 수 있도록 하여 경쟁 상황을 방지하는 기법이다. 하나의 쓰레드가 공유 자원에 접근하여 lock을 걸면, 다른 쓰레드는 lock이 풀릴 때 까지 해당 자원에 접근할 수 없다.</p>\n<p>semaphore란 S개의 thread만이 공유 자원에 접근할 수 있도록 하여 경쟁 상황을 방지하는 기법이다. 하나의 쓰레드가 자원에 접근할 떄마다 세마포 값을 감소시키고, 자원을 방출할 때는 세마포 값을 증가시킨다. 이 때 세마포의 값이 0이 되면 모든 자원이 사용 중임을 의미하고 0보다 커질 때까지 자원 사용을 block한다.</p>\n<h1>교착상태(데드락)</h1>\n<p>두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태로, 2개 이상의 thead가 각기 자원을 점유하고 있고, 서로의 자원을 기다릴 때 무한 대기가 발생한다.</p>\n<h2>데드락이 발생할 조건 4가지</h2>\n<ol>\n<li>\n<p>상호 배제</p>\n</li>\n<li>\n<p>점유 대기</p>\n</li>\n<li>\n<p>비선점</p>\n</li>\n<li>\n<p>순환 대기</p>\n</li>\n</ol>","id":"96f083a2-5aa5-5b8a-9364-c6733018eeb4"},{"fields":{"slug":"/programming/이펙티브타입스크립트/2장/"},"excerpt":"편집기를 사용하여 타입 시스템 탐색하기 많은 개발자들이 vscode를 이용하는데 typescript를 제작한 ms에서 만든 것이다. 따라서 vscode를 사용하면 typescript의 언어 서비스를 잘 활용할 수 있다. 편집기를 통해서 어떻게 타입 시스템이 동작하는지, 타입스크립트가 어떻게 타입을 추론하는지 개념을 잡을 수 있다. Go to Definition 기능을 통해서 타입 선언 파일로 이동할 수 있고, 타입 선언 파일을 보면서 어떻게 …","frontmatter":{"date":"2022-10-18T00:00:00.000Z","description":"타입스크립트의 타입 시스템","title":"이펙티브 타입스크립트 2장"},"html":"<h1>편집기를 사용하여 타입 시스템 탐색하기</h1>\n<p>많은 개발자들이 vscode를 이용하는데 typescript를 제작한 ms에서 만든 것이다. 따라서 vscode를 사용하면 typescript의 언어 서비스를 잘 활용할 수 있다.</p>\n<p>편집기를 통해서 어떻게 타입 시스템이 동작하는지, 타입스크립트가 어떻게 타입을 추론하는지 개념을 잡을 수 있다.</p>\n<pre><code class=\"language-ts\">const num = 3\n//num은 number로 자동으로 추론한다.\n</code></pre>\n<p>Go to Definition 기능을 통해서 타입 선언 파일로 이동할 수 있고, 타입 선언 파일을 보면서 어떻게 모델링 되었는지 파악할 수 있다.</p>\n<h1>타입이 값들의 집합이라고 생각하기</h1>\n<p>타입이 값들의 집합이라고 생각하라는 의미는 무엇일까. 1,2,3이라는 값들은 number라는 타입에 해당된다. 즉 1,2,3이라는 숫자 값들의 집합은 number 타입에 해당된다는 것이다. 1000도 숫자 값의 집합의 요소이기 때문에 number 타입에 해당된다.</p>\n<h2>타입의 종류</h2>\n<ol>\n<li>never 타입\n<ul>\n<li>공집합으로, never에는 아무런 값도 할당할 수 없다.</li>\n</ul>\n</li>\n<li>유닛 타입 혹은 리터럴 타입\n<ul>\n<li>한 가지 값만 포함하는 타입이다.</li>\n</ul>\n<pre><code class=\"language-ts\">type A = \"a\"\ntype B = \"b\"\n</code></pre>\n</li>\n<li>유니온 타입 - 값 집합들의 합집합을 말한다.\n<pre><code class=\"language-ts\">type AB = \"A\" | \"B\"\ntype AB12 = \"A\" | \"B\" | 12\n</code></pre>\n</li>\n<li>집합의 범위가 한정되어 있지 않은 타입들\n<ul>\n<li>number, string 등의 타입은 범위가 무한대이다. 나올 수 있는 경우의 수가 무수히 많기 때문이다.</li>\n</ul>\n</li>\n<li>서브 타입\n<pre><code class=\"language-ts\">interface Person {\n  name: string\n}\ninterface PersonSpan extends Person {\n  birth: Date\n  death?: Date\n}\n</code></pre>\nPersonSpan은 Person의 서브타입이라고 할 수 있다. PersonSpan은 Person의 모든 조건을 만족해야한다.</li>\n</ol>\n<h2>키워드</h2>\n<h3>&#x26;</h3>\n<p>두 타입의 인터섹션(교집합)을 계산한다. 예시를 통해서 알아보도록 한다.</p>\n<pre><code class=\"language-ts\">interface Person {\n  name: string\n}\n\ninterface LifeSpan {\n  birth: Date\n  death?: Date\n}\n\ntype PersonSpan = Person &#x26; LifeSpan\n\nconst ps: PersonSpan = {\n  name: \"hi\",\n  birth: new Date(),\n}\n</code></pre>\n<p>위의 PersonSpan의 경우 두 인터페이스가 공통적으로 가지는 속성이 없기 때문에 공집합이라고 생각할 수 있지만 이것은 틀린 것이다. 덕 타이핑으로 인해서 Person 인터페이스의 경우 어떤 객체가 name 속성을 보유하고 그것이 문자열이면 모두 만족한다. LifeSpan 인터페이스의 경우 마찬가지로 birth의 속성이 날짜인 객체도 전부 만족한다. 따라서 교집합이므로, name 속성과 birth 속성 2개다 존재해야 하는 것이다.</p>\n<p>하지만 유니온에 대해서는 다른 형태를 보여준다.</p>\n<pre><code class=\"language-ts\">type union = Person | LifeSpan\n\ntype K = keyof union\ntype M = typeof (Person &#x26; LifeSpan)\n</code></pre>\n<p>K는 never이고, M은 <code>name | birth | death</code>이다.\nK가 never인 이유는 union의 키는 (name) | (birth | death) 인데 둘 중 무슨 값이 될지 모르기 때문에 2개 다 만족하는 값이 나와야한다(?)</p>\n<pre><code class=\"language-ts\">keyof (A|B) = (keyof A) &#x26; (keyof B)\n</code></pre>\n<h3>extends</h3>\n<p>extends 키워드를 활용하여 서브 타입을 만들어낼 수 있다.</p>\n<p>extends 키워드는 제너릭 타입에서 한정자로도 쓰인다. 해당 문맥에서는 ~의 부분 집합을 의미하기도 한다.</p>\n<pre><code class=\"language-ts\">function getKey&#x3C;K extends string>(val: any, key: K) {\n  //....\n}\n\ngetKey(val, \"3\")\ngetKey(val, 12)\n//오류가 발생한다. K는 string의 부분 집합이므로.\n</code></pre>\n<h1>타입 공간과 값 공간의 심벌 구분하기</h1>\n<p>타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재한다.</p>\n<p><em>symbol이란 es5에서 추가로 명세된 원시값이다. 고유하기 때문에 충돌이 없어 객체의 키값으로 주로 사용된다.</em></p>\n<pre><code class=\"language-ts\">interface Cylinder {\n  radius: number\n  height: number\n}\n\nconst Cyclinder = (radius: number, height: number) => ({ radius, height })\n</code></pre>\n<p>interface에서는 Cylinder는 타입으로, const에서는 값으로 사용된다. 심벌에 어떤 키워드가 사용되었는지 잘파악하여 문맥으로 유추해야한다.</p>\n<p>클래스의 경우 타입으로 쓰일 때는 형태(속성과 메소드)가 사용되는 반면, 값으로 쓰일 때는 생성자가 사용된다.</p>\n<p>typeof, this 그리고 많은 다른 연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.</p>\n<h1>타입 단언보다는 타입 선언하기</h1>\n<p>타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법은 타입 단언, 타입 선언 두가지이다.\n타입 단언이 꼭 필요한 경우가 아니라면 타입 선언을 사용해야한다. 타입 단언의 경우 강제로 타입을 지정한 것과 마찬가지이다. 타입 체커의 오류도 나타나지 않는다.</p>\n<pre><code class=\"language-ts\">interface Person {\n  name: string\n}\n\nconst person: Person = { name: \"jinwook\" }\nconst e_person = { nickname: \"jinwook\" } as Person\n//e_person의 경우 타입 체커에 의해서 오류가 발생해야 하지만, 타입 단언으로 인해서 오류가 발생하지 않음.\n</code></pre>\n<pre><code class=\"language-ts\">document.querySelector(\"#myButton\").addEventListener(\"click\", e => {\n  const button = e.currentTarget as HTMLButtonElement\n})\n</code></pre>\n<p>타입 단언이 꼭 필요한 경우는 타입 체커가 추론한 타입보다 내가 판단하는 타입이 더 정확할 때 의미가 있다.\n예를 들어 DOM 엘리먼트에 대해서는 타입스크립트보다 개발자가 더 정확히 알고있다. 타입스크립트는 DOM에 접근할 수 없기 때문에 myButton이 버튼 엘리먼트인지 알 수 없다.</p>\n<h2>화살표 함수에서 타입 선언</h2>\n<p>화살표 함수의 타입 선언은 추론된 타입이 모호할 때가 있다.</p>\n<pre><code class=\"language-ts\">const people = [\"jinwook\"].map(name => ({ name }))\n//{name:string}[] 형태이다. 원하는 Person[]이 나오지 않는다.\n</code></pre>\n<p>타입 단언을 써도 문제가 해결되긴 하지만, 런타임에 문제가 발생한다.</p>\n<pre><code class=\"language-ts\">const people = [\"jinwook\"].map(name => ({ name } as Person))\nconst e_people = [\"jinwook\"].map(name => ({} as Person))\n//e_people의 경우 Person 형태를 만족하지 않지만 에러를 반환하지 않음.\n</code></pre>\n<p>화살표 함수의 반환값에 타입을 선언하거나 화살표 함수 내에서 타입과 함께 변수를 선언함으로써 이러한 문제를 해결할 수 있다.</p>\n<pre><code class=\"language-ts\">const people = [\"jinwook\"].map((name): Person => ({ name }))\n\nconst people = [\"jinwook\"].map((name): Person => {\n  const person: Person = { name }\n  return person\n})\n</code></pre>\n<p>타입 단언을 사용하더라도, 서로의 서브타입이 아니면 변환이 불가능하다.</p>\n<pre><code class=\"language-ts\">const body = document.getElementById(\"foo\") //HTMLElement | null\nconst el = body as Person //타입 체커 오류 발생.\n</code></pre>\n<h1>객체 래퍼 타입 피하기</h1>\n<pre><code class=\"language-ts\">\"Thisisstring\".charAt(3)\n</code></pre>\n<p>위와 같은 코드는 어떻게 동작하는 것일까? string은 기본형으로 불변이며 메소드를 가지지 않는데 말이다.\n정확히 알아보면 charAt 메소드는 string의 메소드가 아니라 String 객체의 메소드이다. 자바스크립트는 기본형과 객체 타입을 서로 자유롭게 변환한다.</p>\n<p><strong>string 기본형에 charAt과 같은 메서드를 사용할 때, 기본형을 String 객체로 래핑하고 메소드를 호출하고 마지막에 래핑한 객체를 버린다.</strong></p>\n<p>이 String 객체는 오직 자기 자신하고만 동일하다.</p>\n<p>객체 래퍼 타입의 자동 변환은 종종 당황스러운 동작을 보인다.</p>\n<pre><code class=\"language-ts\">x = \"hello\"\nx.lanuage = \"English\"\nx.lanuage //undefined\n</code></pre>\n<p>String 객체로 변환되었다가 lanuage 속성을 할당하고 객체는 버려진다. 따라서 해당 속성으로 접근해도 undefined가 출력되는 것이다.</p>\n<p>이러한 래퍼 타입들 덕분에 기본형 값에 메소드를 사용할 수 있고, 정적 메소드(String.fromCharCode)도 사용할 수 있다. 타입스크립트는 기본형과 객체 래퍼 타입을 별도로 모델링한다.</p>\n<p>기본형은 객체 래퍼 타입에 할당될 수 있지만, 객체 래퍼 타입은 기본형에 할당될 수 없다. 객체 래퍼 타입의 할당은 지양해야 한다.</p>\n<pre><code class=\"language-ts\">const getStrLen = (foo: String): number => foo.length\ngetStrLen(\"hello\") //정상 작동\n\nconst isGreeting = (phrase: String) => [\"hi\", \"hello\"].includes(phrase)\n//타입 체크 에러 발생. includes에 들어가는 인수는 객체 래퍼 타입이 아니라 기본형이여햐함.\n</code></pre>\n<h1>잉여 속성 체크 한계 인지하기</h1>\n<p>타입이 명시된 변수에 <strong>객체 리터럴을 할당할 때 타입스크립트는 해당 타입의 속성이 있는지 그리고 그외의 속성은 없는지 확인한다.</strong>\n덕 타이핑 관점에서 본다면, 타입스크립트의 해당 타입의 속성만 만족시키면 되는데 왜 이런 현상이 발생할까?</p>\n<pre><code class=\"language-ts\">interface Room {\n  num: number\n  isSuite: boolean\n}\n\nconst r: Room = {\n  num: 10,\n  isSuite: false,\n  elephant: \"present\", //타입 체커 오류 발생. Room 형식에 elephant는 존재하지 않음.\n}\n\nconst r2 = {\n  num: 10,\n  isSuite: false,\n  elephant: \"present\",\n}\n\nconst r3: Room = r2 //오류 발생하지 않음.\n</code></pre>\n<p>위와 같이 객체 리터럴이 아닌, 임시 변수를 도입하면 구조적 타이핑 관점에서 타입이 할당이 가능한 것을 볼 수 있다.</p>\n<p>이러한 시스템이 도입된 이유는 단순히 런타임에 예외를 던지는 코드에 오류를 표시하는 것뿐만 아니라, 의도와 다르게 작성된 코드까지 찾으려고 하기 때문이다. 잉여 속성 체크는 할당 가능 검사와 별도의 과정으로 구조적 타이핑의 개념과 헷갈려서는 안된다.</p>\n<pre><code class=\"language-ts\">interface Options {\n  title: string\n  darkMode: boolean\n}\n\nfunction createWindow(options: Options) {\n  if (options.darkMode) {\n    setDarkMode()\n  }\n}\n\ncreateWindow({ title: \"blahblah\", darkmode: true })\n//타입 체커 오류 발생. darkMode를 쓰려고 했습니까?\n</code></pre>\n<p>위의 코드는 런타임에서 어떠한 오류도 발생시키지 않는다. 하지만 의도한대로 동작하지 않을 수 있다.</p>\n<p>Options 타입에는 실제로 무수히 많은 타입이 할당될 수 있다. document 객체도 할당이 가능하다. <code>title:string</code>속성이 있기 때문이다. <strong>잉여 속성 체크를 이용하면 기본적으로 타입 시스템의 구조적 본질을 해치지 않으면서 객체 리터럴에 알 수 없는 속성을 허용하지 않음으로써, 앞에 예시에서 다룬 문제를 해결할 수 있다.</strong></p>\n<p>만일 잉여 속성 체크를 원하지 않는다면 인덱스 시그니처를 활용하여 추가적으로 속성이 할당될 수 있음을 명시해주시면 된다.</p>\n<h2>약한 타입</h2>\n<p>선택적 속성만 가지는 타입을 약한(weak) 타입이라고 한다.</p>\n<pre><code class=\"language-ts\">interface Animal {\n  hasLeg?: boolean\n  isHerbivores?: boolean\n}\n\nconst elephant = { isBig: true }\n//타입 체크 에러 발생. 공통적인 속성이 없음.\n</code></pre>\n<p>구조적인 관점에서 Animal 타입은 모든 속성이 선택적이므로 모든 객체를 포함할 수 있다. 이런 약한 타입에 대해서 타입스크립트는 값 타입과 선언 타입에 공통된 속성이 있는지 확인하는 별도의 체크를 수행한다. 객체 리터럴에만 수행하는 잉여 속성 체크와 다르게 모든 할당문에서 수행된다. 따라서 임시 변수 패턴을 사용하더라도 공통 속성 체크는 여전히 동작한다.</p>\n<h1>함수 표현식에 타입 적용하기</h1>\n<p>함수를 정의하는 방법은 함수 선언문, 함수 표현식 2가지가 있다. 타입스크립트의 경우 함수 표현식으로 정의하면 좋다. 그 이유는 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용 할 수 있기 때문이다.</p>\n<pre><code class=\"language-ts\">type BinaryFn = (a: number, b: number) => number\nconst sum: BinaryFn = (a, b) => a + b\nconst mul: BinaryFn = (a, b) => a * b\nconst sub: BinaryFn = (a, b) => a - b\n</code></pre>\n<p>위의 예제를 통해서, 재사용성과 함수 타입을 매개변수부터 반환값까지 선언했을 때보다 함수 구현부가 분리되어 있어 로직이 보다 분명해진다는 장점이 있다. 따라서 라이브러리는 공통 ㅏㅎㅁ수 시그니처를 타입으로 제공하기도 한다. 예시로 리액트에서 함수의 매개변수에 명시하는 MouseEvent 타입 대신 함수 전체에 적용할 수 있는 MouseEventHandler 타입을 제공한다.</p>\n<h2>시그니처가 일치하는 다른 함수</h2>\n<p>fetch 함수를 예시로 살펴본다.</p>\n<pre><code class=\"language-ts\">async function getQuote() {\n  const response = await fetch(\"/quote?by=Mark+Twain\")\n  const qutoe = await response.json()\n  return qutoe\n}\n</code></pre>\n<p>위의 예시에서 만일 /quote가 존재하지 않는 API라면 response.json()은 JSON 형식이 아니라는 요상한 오류 메시지를 담아 거절된 프로미스를 반환한다. 이럴 경우 우리는 왜 거절되었는지 이유를 명확히 알 수 없다. 따라서 상태도 체크해주는 새로운 함수를 정의해본다.</p>\n<pre><code class=\"language-ts\">async function checkedFetch(input: RequestInfo, init: ReuqestInit) {\n  const response = await fetch(input, init)\n  if (!response.ok) {\n    throw new Error(response.status)\n  }\n  return response\n}\n</code></pre>\n<p>위의 코드는 아래와 같이 간결하게 고쳐질 수 있다. 함수 표현식에 타입을 적용하면 된다. 다른 함수의 시그니처를 참조하려면 typeof fn을 사용하면 된다.</p>\n<pre><code class=\"language-ts\">const checkedFetchasync: typeof fetch = (input, init) => {\n  const response = await fetch(input, init)\n  if (!response.ok) {\n    throw new Error(response.status)\n  }\n  return response\n}\n</code></pre>\n<p>아래와 같이 적용할 경우 <code>throw new Error(response.status)</code> 부분을 <code>return new Error(response.status)</code>로 변경할 경우 에러도 반환해준다. 반환타입이 fetch와 동일해야하기 떄문이다.</p>\n<h1>타입과 인터페이스의 차이점 알기</h1>\n<p>타입스크립트에서 명명된 타입을 정의하는 방법은 두 가지있다. <code>type</code>(타입 별칭)과 <code>interface</code>이다. <strong>대부분의 경우 타입을 사용해도 되고 인터페이스를 사용해도 된다. 하지만 공통점과 차이점을 명확히 이해하고 같은 상황에서는 동일한 방법으로 명명된 타입을 정의해 일관성을 유지해야한다.</strong></p>\n<p><em>타입에 I혹은 T를 붙여 어떤 형태로 사용되었는지 알려주는 패턴은 초기에는 종종 사용되었으나 현재는 지양해야 할 스타일이다.</em></p>\n<h2>공통점</h2>\n<ol>\n<li>명명된 타입은 어떤 타입으로 정의하던 상태에는 차이가 없다.</li>\n<li>인덱스 시그니처는 인터페이스와 타입에서 모두 사용할 수 있다.</li>\n<li>함수 타입도 인터페이스나 타입으로 정의할 수 있다.\n<pre><code class=\"language-ts\">type TFn = (x: number) => string\ninterface IFn {\n  (x: number): string\n}\n</code></pre>\n</li>\n<li>제너릭 사용이 가능하다.</li>\n<li>클래스를 구현할 때 둘 다 사용할 수 있다.</li>\n</ol>\n<h2>차이점</h2>\n<ol>\n<li>유니온 타입은 있지만, 유니온 인터페이스라는 개념은 없다.</li>\n<li>인터페이스는 타입을 확장(extends)할 수 있지만, 유니온은 할 수 없다.</li>\n<li>튜플과 배열 타입도 타입 별칭을 사용하면 간결하게 표현할 수 있다. 인터페이스로도 튜플과 비슷하게 구현할 수 있지만, concat과 같은 메서드를 사용할 수 없다.</li>\n<li>인터페이스에는 타입에는 없는 보강(augment)이 가능하다.\n<pre><code class=\"language-ts\">interface IState {\n  name: string\n  capital: string\n}\ninterface IState {\n  population: number\n}\nconst wyoming: State = {\n  name: \"Wyoming\",\n  capital: \"Cheyenne\",\n  population: 500000,\n}\n//정상이다.\n</code></pre>\n속성을 확장하는 것을 선언 병합이라고 한다. 선언 병합은 주로 타입 선언 파일에서 사용된다. 따라서 타입 선언 파일을 작성할 때는 선언 병합을 지원하기 위해 반드시 인터페이스를 사용해야 하며 표준을 따라야한다.</li>\n</ol>\n<h2>그렇다면 언제 type, interface를 사용하면 좋을까?</h2>\n<ol>\n<li>복잡한 타입이라면 타입 별칭을 사용하면 된다.</li>\n<li>둘다 표현 가능한 간단한 객체 타입이라면 일관성과 보강의 관점에서 생각해야함.\n<ul>\n<li>기존 프로젝트의 룰에 따른다.</li>\n<li>어떤 API에 대한 타입 선언을 작성해야 한다면 인터페이스가 좋다. 추후에 보강될 여지가 있기 떄문이다.</li>\n</ul>\n</li>\n</ol>\n<h1>타입 연산과 제너릭 사용으로 반복 줄이기</h1>\n<p>코드를 중복하면 안된다. 코드를 중복하면 유지보수 비용이 급격하게 늘어난다. 수정을 할 때 수정이 필요한 요소를 일일이 찾아서 빠짐없이 수정해줘야 하기 때문이다. DRY(Don't Repeat Yourself) 원칙이다.</p>\n<h2>타입 반복을 줄이는 방법들</h2>\n<h3>타입에 이름 붙이기</h3>\n<pre><code class=\"language-ts\">function distance(a: { x: number; y: number }, b: { x: number; y: number }) {\n  return a.x + a.y + b.x + b.y\n}\n\ninterface Point2D {\n  x: number\n  y: number\n}\n\nfunction distance(a: Point2D, b: Point2D) {}\n</code></pre>\n<h3>함수가 같은 타입의 시그니처를 가지고 있을 때</h3>\n<p><a href=\"#%ED%95%A8%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D%EC%97%90-%ED%83%80%EC%9E%85-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0\">예시</a></p>\n<h3>인터페이스 확장을 통한 반복 제거</h3>\n<pre><code class=\"language-ts\">interface Person {\n  firstName: string\n  lastName: string\n}\n\ninterface PersonWithDate {\n  firstName: string\n  lastName: string\n  birth: Date\n}\n\ninterface PersonWithDate extends Person {\n  birth: Date\n}\n\n//이미 존재하는 타입을 확장할 경우(일반적이지는 않음.)\ntype PersonWithDate = Person &#x26; { birth: Date }\n</code></pre>\n<h3>한 타입의 부분 집합인 타입</h3>\n<p>부모 타입을 이용해서 부분 집합 타입을 정의하라.</p>\n<pre><code class=\"language-ts\">interface State {\n  userId: string\n  pageTitle: string\n  recentFiles: string[]\n  pageContents: string\n}\n\ninterface TopNavState {\n  userId: State[\"userId\"]\n  pageTitle: State[\"pageTitle\"]\n  recnetFiles: State[\"recentFiles\"]\n}\n</code></pre>\n<p>매핑된 타입을 이용하는 방식</p>\n<pre><code class=\"language-ts\">type TopNavState = {\n  [k in \"userId\" | \"pageTitle\" | \"recentFiles\"]: State[k]\n}\n</code></pre>\n<p>매핑된 타입은 배열의 필드를 루프 도는 것과 같은 방식이다 이 패턴은 표준 라이브러리의 Pick 제너릭 타입과 동일하다.</p>\n<pre><code class=\"language-ts\">type TopNavState = Pick&#x3C;State, \"userId\" | \"pageTitle\" | \"recentFiles\">\n</code></pre>\n<p><strong>생성하고 난 다음에 업데이트가 되는 클래스의 경우, 타입 대부분이 선택적 필드가 된다.</strong></p>\n<pre><code class=\"language-ts\">interface Options {\n  width: number\n  height: number\n  color: string\n  label: string\n}\n\ninterface OptionsUpdate {\n  width?: number\n  height?: number\n  color?: string\n  label?: string\n}\n</code></pre>\n<p>매핑된 타입과 keyof를 사용하여 중복을 제거</p>\n<pre><code class=\"language-ts\">type OptionsUpdate = { [k in keyof Options]?: Options[k] }\n</code></pre>\n<p>매핑된 타입은 순회하며 Options 내 k 값에 해당하는 속성이 있는지 찾는다. 표준 라이브러리의 Partial 제너릭과 동일하다.</p>\n<pre><code class=\"language-ts\">type OptionsUpdate = Partial&#x3C;Options>\n</code></pre>\n<h3>값 형태에 해당하는 타입을 정의하고 싶을 때</h3>\n<pre><code class=\"language-ts\">const INIT_OPTIONS = {\n  width: 640,\n  height: 480,\n  color: \"#00FFD\",\n  label: \"VGA\",\n}\n\ninterface Options {\n  width: number\n  height: number\n  color: string\n  label: string\n}\n\ntype Options = typeof INIT_OPTIONS\n</code></pre>\n<p>여기서 typeof는 자바스크립의 연산자 typeof로 사용된 것으로 보이지만, 실제로는 타입스크립트 단계에서 연산되고 정교하게 타입을 표현한다. 값으로부터 타입을 만들어 낼 때 선언의 순서에 주의해야한다. 타입 정의를 먼저하고 값이 그 타입에 할당 가능하다고 선언하는 것이 좋다.</p>\n<p>함수나 메소드의 반환 값에 명명된 타입을 만들고 싶을 때</p>\n<pre><code class=\"language-ts\">function getUserInfo(userId: string) {\n  //.....\n  return {\n    userId,\n    name,\n    age,\n    height,\n    width,\n  }\n}\n\ntype UserInfo = ReturnType&#x3C;typeof getUserInfo>\n</code></pre>\n<p>ReturnType을 사용할 때 유의해야 할 점은 getUserInfo의 값이 아니라, typeof로 타입을 적용시켰다는 점이다.</p>\n<h3>제너릭 타입에서 매개변수를 제한하고 싶을 때</h3>\n<p>extends를 사용하면 된다. extends를 사용하면 제너릭 매개변수가 특정 타입을 확장한다고 선언할 수 있다.</p>\n<pre><code class=\"language-ts\">interface Name {\n  first: string\n  last: string\n}\n\ntype DancingDuo&#x3C;T extends Name> = [T, T]\n\nconst couple1: DancingDuo&#x3C;Name> = [\n  { first: \"Fred\", last: \"Artster\" },\n  { first: \"Ginager\", last: \"Rogers\" },\n]\n\nconst couple2: DancingDuo&#x3C;{ first: string }> = [\n  //...,\n  //...\n]\n//{first:string}에는 last 속성이 없어서 오류가 발생한다. extends 구문으로 확장한다고 선언했기 때문에 last가 꼭 필요함.\n</code></pre>\n<h1>동적 데이터에 인덱스 시그니처 사용하기</h1>\n<p>자바스크립트 객체는 문자열 키를 타입의 값에 관계없이 매핑한다. 타입스크립트에서는 타입에 인덱스 시그니처를 명시하여 유연하게 매핑을 표현할 수 있다.</p>\n<pre><code class=\"language-ts\">type Obj = { [property: string]: string }\n</code></pre>\n<p>위와 같은 방식이 인덱스 시그니처이다. 다음 3가지 의미를 담는다.</p>\n<ol>\n<li>키의 이름: 키의 위치만 표시하는 용도. 타입 체커에서는 사용되지 않음.</li>\n<li>키의 타입: string | number | symbol 조합이지만, 보통은 string 사용</li>\n<li>값의 타입: 어떤 값이든 될 수 있음.</li>\n</ol>\n<h2>인덱스 시그니처의 단점</h2>\n<ol>\n<li>잘못된 키를 포함해 모든 키를 허용한다. 만약 name이라는 속성이 필요한 객체임에도 불구하고 Name이라는 속성을 기입해도 타입 체크 오류가 발생하지 않는다.</li>\n<li>특정 키가 필요하지 않다. {}도 인덱스 시그니처 타입이다.</li>\n<li>키마다 다른 타입을 가질 수 없다.</li>\n<li>타입스크립트 언어 서비스의 기능이 일부 동작하지 않는다. name:을 입력할 때 키는 무엇이든 가능하기 때문에 자동완성안됨.</li>\n</ol>\n<h2>언제 인덱스 시그니처를 사용하고 사용하지 말아야 하는가?</h2>\n<p>인덱스 시그니처는 부정확하다. 만일 객체의 모든 속성이 string이라서 인덱스 시그니처를 사용한다면 이는 잘못된 것이다. <strong>인덱스 시그니처는 동적 데이터를 표현할 때 사용해야 한다.</strong></p>\n<p>예시로 CSV 파일처럼 헤더 행에 열 이름이 있고, 데이터 행을 열 이름과 값으로 매핑하는 객체로 나타내고 싶은 경우이다.</p>\n<p><em>declare 키워드는 컴파일러에게 해당 변수나 함수가 이미 존재한다고 알리는 역할을 한다.</em></p>\n<p><strong>어떤 타입에 가능한 필드가 제한되어 있는 경우라면 인덱스 시그니처로 모델링하면 안된다.</strong></p>\n<p>만일 객체에 a,b,c,d와 같은 키가 있지만 얼마나 많이 있는지 모른다면 선택적 필드 또는 유니온 타입으로 모델링 해야한다.</p>\n<pre><code class=\"language-ts\">interface Row1 {\n  [column: string]: number\n}\ninterface Row2 {\n  a: number\n  b?: number\n  c?: number\n  d?: number\n}\ntype Row3 =\n  | { a: number }\n  | { a: number; b: number }\n  | { a: number; b: number; c: number }\n  | { a: number; b: number; c: number; d: number }\n</code></pre>\n<p>마지막 Row3의 방식의 경우 정확하지만, 사용하기에는 조금 번거롭다.\n우리는 2가지 옵션이 존재한다.</p>\n<ol>\n<li>\n<p>Record 제너릭 타입 사용</p>\n<ul>\n<li>키 타입에 유연성을 제공하는 제너릭 타입이다.</li>\n</ul>\n<pre><code class=\"language-ts\">type Vec3D = Record&#x3C;'x' | 'y' | 'z', number>\n&#x3C;!-- Vec3D = {\n  x: number\n  y:number\n  z:number\n} -->\n</code></pre>\n</li>\n<li>\n<p>매핑된 타입 사용</p>\n<pre><code class=\"language-ts\">type Vec3D = { [k in \"x\" | \"y\" | \"z\"]: number }\ntype ABC = { [k in \"a\" | \"b\" | \"c\"]: k extends \"b\" ? string : number }\n// ABC = {\n//   a:number\n//   b:string\n//   c: number\n// }\n</code></pre>\n</li>\n</ol>\n<h1>number 인덱스 시그니처보다는 Array, 튜플, ArrayLike 사용하기</h1>\n<p>자바스크립트의 객체는 문자열을 키값으로 사용한다. 만일 문자열이 아닌 것을 키값으로 할당하면 .toString 메소드를 사용하여 문자열로 변환된다.</p>\n<pre><code class=\"language-ts\">x = {}\nx[[1, 2, 3]] = 2\n//x: '1,2,3' = 2\n//[1,2,3]이 toString으로 문자열로 변환됨.\n</code></pre>\n<p>자바스크립트에서 배열은 객체이다. 배열에서 인덱스에 접근하기 위해서 숫자로 된 키를 사용하지만, 내부에서 문자열로 변환되어 사용된다.</p>\n<pre><code class=\"language-ts\">const arr = [1, 2, 3]\narr[0] // 1\narr[\"0\"] //1\n</code></pre>\n<p>타입스크립트는 이러한 혼란을 막기위해 숫자 키를 허용하고, 문자열 키와는 다른 것으로 인식한다.</p>\n<p>인덱스 시그니처에 number를 사용하기 보다는 Array나 튜플, 또는 ArrayLike 타입을 사용하는 것이 좋다.</p>\n<h1>변경 관련된 오류 방지를 위해 readonly 사용하기</h1>\n<p>함수가 매개변수를 수정하지 않는다면, readonly로 설정하는 것이 좋다. 매개변수의 비의도적인 변경을 방지할 수 있다.</p>\n<p>readonly는 얕게 동작한다. 깊게 동작을 원한다면 ts-essentials에 있는 DeepReadonly 제네릭을 사용하면 된다.</p>\n<h1>매핑된 타입을 사용하여 값 동기화하기.</h1>\n<p>매핑된 타입을 사용해서 관련된 값과 타입을 동기화 할 수 있다.</p>\n<p>만일 이전 객체와 현재 객체를 비교하여 다르다면 업데이트를 수행해야 하는 상황인데, 효율성을 위해서 특정 속성의 차이만 비교한다고 해보자. 그렇다면 속성이 추가될 때마다 해당 속성이 특정 속성에 해당하는지 안하는지 코드를 작성해줘야 할 것이다. 매핑된 타입을 사용하면, 타입 시스템을 활용하여 안전하게 유지보수 할 수 있다.</p>\n<pre><code class=\"language-ts\">interface ScatterProps {\n  xs: number[]\n  ys: number[]\n  xRange: [number, number]\n  yRange: [number, number]\n  color: string\n  onClick: (x: number, y: number, index: number) => void\n}\n\nconst REQUIRES_UPDATE: { [k in keyof ScatterProps]: boolean } = {\n  xs: true,\n  ys: true,\n  xRange: true,\n  yRange: true,\n  color: true,\n  onClick: true,\n}\n\nfunction shouldUpdate(oldProps: ScatterProps, newProps: ScatterProps) {\n  let k: keyof ScatterProps\n  for (k in oldProps) {\n    if (oldProps[k] !== newProps[k] &#x26;&#x26; REQUIRES_UPDATE[k]) {\n      return true\n    }\n  }\n  return false\n}\n</code></pre>\n<p>이후에 만일 ScatterProps에 어떤 속성이 추가된다면, REQUIRES_UPDATE 해당 속성이 없다고 타입 시스템에 오류가 발생할 것이다.</p>","id":"4f71d23a-e4d0-5efb-a1b0-e52d6c4f76bd"},{"fields":{"slug":"/programming/이펙티브타입스크립트/1장/"},"excerpt":"타입스크립트와 자바스크립트의 관계 타입스크립트는 자바스크립트의 상위 집합이다. 즉 모든 자바스크립트 프로그램은 타입스크립트 프로그램이다. 하지만 타입스크립트의 경우 타입 선언 등 별도의 문법을 가지고 있기 때문에 유효한 자바스크립트 프로그램이라고는 할 수 없다. 자바스크립트가 타입스크립트 프로그램이기에 마이그레이션 하는데 큰 이점을 가진다. 타입 시스템 타입스크립트는 자바스크립트에 타입 시스템을 더한 것이다. 타입 시스템의 목표 중 하나는 런…","frontmatter":{"date":"2022-10-17T00:00:00.000Z","description":"타입스크립트 알아보기","title":"이펙티브 타입스크립트 1장"},"html":"<h1>타입스크립트와 자바스크립트의 관계</h1>\n<p>타입스크립트는 자바스크립트의 상위 집합이다. 즉 모든 자바스크립트 프로그램은 타입스크립트 프로그램이다. 하지만 타입스크립트의 경우 타입 선언 등 별도의 문법을 가지고 있기 때문에 유효한 자바스크립트 프로그램이라고는 할 수 없다. 자바스크립트가 타입스크립트 프로그램이기에 마이그레이션 하는데 큰 이점을 가진다.</p>\n<h2>타입 시스템</h2>\n<p>타입스크립트는 자바스크립트에 타입 시스템을 더한 것이다. 타입 시스템의 목표 중 하나는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것이다. '정적'타입 시스템이라는 것은 바로 이런 특징을 말하는 것이다. 하지만 타입 체커가 모든 오류를 찾아내지는 않으니 유의해야한다.</p>\n<p>타입을 선언하지 않아도 타입스크립트는 오류는 발생시키지 않지만 의도와 다르게 동작하는 코드를 찾아내기도 한다. 하지만 정확하지 않기에 명시적으로 타입을 선언해야한다.</p>\n<pre><code class=\"language-typescript\">interface State {\n  name: string\n  capital: string\n}\n\nconst states: State[] = [\n  { name: \"Alaska\", capital: \"Juneau\" },\n  { name: \"Korea\", capitol: \"Seoul\" },\n]\n//만일 State 타입을 명시하지 않았다면, 에러를 발생시키지 않지만 State 타입을 명시함으로써 capitol 속성 부분에 에러를 표시해준다. 이는 잠재적으로 생길 수 있는 문제를 해결해준다.\n</code></pre>\n<p>타입스크립트 타입 시스템은 자바스크립트의 런타임 동작을 모델링한다.</p>\n<pre><code class=\"language-ts\">const x = 2 + \"3\"\nconst a = null + 7\nconst b = [] + 12\nalert(\"hi\", \"ts\")\n</code></pre>\n<p>변수 x의 경우 문자열 \"23\"이 되는 자바스크립트 런타임 동작으로 모델링된다. 하지만 변수 a,b, alert 함수의 경우에 자바스크립에서는 정상적으로 동작하지만 타입스크립에서는 타입 체커가 문제점을 표시한다.</p>\n<p>이러한 불명확함이 타입스크립트를 사용하는데 의문이 들 수 있지만, 타입스크립트를 사용하면 오류가 적은 프로그램을 만들 수 있다. <code>null+7</code>과 같은 코드가 당연하다고 생각된다면 타입스크립트를 안쓰는게 낫다.</p>\n<h1>타입스크립트 설정 이해하기</h1>\n<pre><code class=\"language-ts\">function sum(a, b) {\n  return a + b\n}\n</code></pre>\n<p>다음 함수가 타입스크립트에서 오류를 발생시키는지, 아닌지 알 수 있을까? 해당 프로그램의 타입스크립트 설정을 보지 않는 이상 알 수 없다. 설정은 커맨드라인에서도 사용할 수 있지만, 설정 파일을 만들어서 동료 개발자나 다른 도구들이 알 수 있도록 해야한다.</p>\n<h2>주요 설정</h2>\n<h3>noImplicitAny</h3>\n<p>noImplicitAny는 변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어한다.\n위의 <code>sum</code> 함수는 noImplicitAny가 설정되었다면 유효하지 않다. a,b가 any 타입으로 간주되기 때문이다. 되도록이면 noImplicitAny로 설정하도록 하고 새 프로젝트를 한다면 꼭 noImplicitAny로 설정하도록 한다.</p>\n<h3>strictNullChecks</h3>\n<p>null과 undefined가 모든 타입에서 허용되는지 확인하는 설정이다.</p>\n<pre><code class=\"language-ts\">const x: number = null\n</code></pre>\n<p>위의 예시는 정상이다. 하지만 strictNullChecks 설정하면 오류가 발생한다.</p>\n<pre><code class=\"language-ts\">const x: number | null = null\n</code></pre>\n<p>만일 null을 허용하려면 위와같이 명시적으로 null을 타입에 넣어주어야 한다.</p>\n<p>만일 null을 허용하지 않으려면 null을 체크하는 코드나 단언문을 추가해야한다.</p>\n<pre><code class=\"language-ts\">const el = document.getElementById(\"status\")\n//el.textContent = \"ready'; -> 개체가 null인 것 같습니다.\n\nif (el) {\n  el.textContent = \"ready\"\n}\nel!.textContent = \"ready\"\n</code></pre>\n<p>strictNullChecks 설정은 null, undefined 관련된 오류를 잡는데 큰 도움을 주지만 코드 작성을 어렵게 한다. 새 프로젝트를 시작한다면 가급적 사용을 권장하고 처음이거나 마이그레이션 중이라면 설정하지 않아도 좋다.</p>\n<h3>strict</h3>\n<p>모든 체크를 설정하고 싶다면 strict 설정을 하면 된다. 타입스크립트에 strict 설정을 하면 대부분 오류를 잡아낸다.</p>\n<h1>코드 생성과 타입이 관계없음을 이해하기</h1>\n<p>타입스크립트의 컴파일러는 두 가지 역할을 수행한다.</p>\n<ol>\n<li>최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일 한다.</li>\n<li>코드의 타입 오류를 체크한다.</li>\n</ol>\n<p>여기서 주의해야 할 점은 두 가지가 완벽히 독립적이라는 점이다. <strong>타입스크립트가 자바스크립트로 변환될 때 타입은 영향을 미치지 않는다. 타입과 관련된 코드는 전부 사라진다!</strong></p>\n<h2>독립적이기에 생기는 특징</h2>\n<h3>1. 타입 오류가 있는 코드도 컴파일 가능</h3>\n<p>타입 오류가 있어도 컴파일 된다는 것은 엉성해보이지만, 실제로는 도움이 되는 경우가 있다. 애플리케이션에서 어떤 부분이 오류가 발생했다고 했을 때, 컴파일이 가능하기에 다른 부분에 대한 테스트가 가능하다.</p>\n<p>만일 오류가 있을 때 컴파일 하지 않으려면 noEmitOnError를 설정하면 된다.</p>\n<h3>2. 런타임에는 타입 체크가 불가능하다.</h3>\n<p>만일 어떤 코드에서 <code>instanceof</code>와 타입을 사용하여 분기를 만든다면, 런타임 환경에서 타입은 사라지기에 전혀 유효하지 않다. 런타임에 타입 정보를 유지하는 방법으로는 3가지가 있다.</p>\n<ol>\n<li>\n<p>속성이 존재하는지 체크 - 속성 체크는 런타임에 접근 가능한 값에만 관련되지만, 타입 체커 역시 보정해주기 때문에 오류가 사라진다.</p>\n</li>\n<li>\n<p>타입 정보를 명시적으로 저장하는 태그 기법</p>\n<pre><code class=\"language-ts\">interface Square {\n  kind: \"square\"\n  width: number\n}\n\ninterface Rectangle {\n  kind: \"rectangle\"\n  width: number\n  height: number\n}\n</code></pre>\n<p>kind 속성을 추가해서, 명시해준다. 타입스크립트에서 흔하게 볼 수 있는 패턴이다.</p>\n</li>\n<li>\n<p>타입을 클래스로 만든다.</p>\n<pre><code class=\"language-ts\">class Square {\n  constructor(public width: number) {}\n}\nclass Rectangle extends Square {\n  constructor(public width: number, public height: number) {\n    super(width)\n  }\n}\ntype Shape = Square | Rectangle\n\nfunction calculateArea(shape: Shape) {\n  if (shape instanceof Rectangle) {\n    //...\n  }\n}\n</code></pre>\n<p><code>type Shape = Square | Rectangle</code> 부분에서 Rectangle은 타입으로 참조되지만, <code>shape instanceof Rectangle</code> 부분에서는 값으로 참조되어 분기가 가능한 것이다.</p>\n</li>\n</ol>\n<h3>3. 타입 연산은 런타임에 영향을 주지 않는다.</h3>\n<p>타입이 사라지기 때문에 당연히 타입 연산도 런타임에 어떠한 영향을 주지 않는다.</p>\n<pre><code class=\"language-ts\">function asNumber(val: number | string): number {\n  return val as number\n}\n</code></pre>\n<pre><code class=\"language-js\">function asNumber(val) {\n  return val\n}\n</code></pre>\n<p>위의 코드는 아래와 같이 컴파일 되기 때문에 해당 인수가 해당 함수를 통과하더라도 그대로이다. 즉 어떠한 영향도 받지 않는다.</p>\n<h3>4. 런타임 타입은 선언된 타입과 다를 수 있다.</h3>\n<p>만약 API값을 수신할 때, API값을 잘못 파악하고 타입을 입력해놨다면 런타임 타입과 선언된 타입이 다르다.</p>\n<h3>5. 함수 오버로드 할 수 없다.</h3>\n<p>타입스크립트가 함수 오버로딩 기능을 지원하기는 하지만, 실제 컴파일 되어있을 때 선언문을 여러개 작성하더라도 구현체는 오직 하나뿐이다. 자바스크립트에서 함수 선언문으로 작성할 경우, 함수명이 동일하면 맨 마지막 함수로 덮어써진다. 이는 자바스크립트의 특징이다.</p>\n<h1>구조적 타이핑 익숙해지기</h1>\n<p>자바스크립트는 덕 타이핑 기반이다.</p>\n<p><em>덕 타이핑이란, 객체가 어떤 타입에 부합하는 변수와 메소드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주한다. 독수리가 오리처럼 걷고, 헤엄치고, 꽥꽥거린다면 독수리는 오리라고 할 수 있다.</em></p>\n<pre><code class=\"language-ts\">function calculateLength(v: { a: number; b: number }) {\n  return v.a + v.b\n}\n\nconst v1 = { a: 1, b: 2, c: 3 }\ncalculateLength(v1) //3\n</code></pre>\n<p>calculateLength의 매개변수 v는 a,b의 속성만 가지지만 c의 속성도 가지고 있는 v1을 해당 함수에 넣어도 문제로 인식하지 않는다. 구조적 관점에서 a,b가 있기 때문에 호환되기 때문이다.</p>\n<p>함수를 작성할 때 호출에 사용되는 매개변수의 속성들이 매개변수의 타입에 선언된 속성만을 가질거라 생각하기 쉽다. 이러한 타입은 봉인된 또는 정확한 타입이라고 불리며 타입스크립트 타입 시스템에서는 표현할 수 없다. 좋든 싫든 타입은 열려있다. 이러한 특성때문에 발생하는 오류는 아래와 같다.</p>\n<pre><code class=\"language-ts\">let sum: number = 0\nfor (let p of Object.keys(v1)) {\n  const num = v1[p]\n  //string은 v1의 인덱스로 사용할 수 없다.\n  sum += num\n}\nreturn sum\n</code></pre>\n<p>Object.keys(v1)을 호출하면 도출되는 배열은 무조건 객체의 속성 중 하나이지만, 타입은 확장될 수 있기 때문에 Object.keys(v1)의 타입은 string[]가 될 수도 있다. 즉 v1이 <code>{a:1,b:2,c:3, d: \"this is string\"}</code>이라면 NaN을 반환한다.\n이럴 경우에 루프보다는, 모든 속성을 각각 더하는 구현이 더 간결하다.</p>\n<p>정확한 타입으로 객체를 순회하는 방법은 추후에 다루도록 하겠다.</p>\n<p>클래스 역시 구조적 타이핑을 따른다. 클래스의 인스턴스가 예상과 다를 수 있음을 유의해야한다.</p>\n<h2>구조적 타이핑의 장점</h2>\n<p>구조적 타이핑은 테스트하는데 유리하다. 함수를 테스트하기 위해서는 모킹한 객체를 생성해야 하는데, 테스트에 필요한 객체의 속성만 작성해주면 되기 때문이다.</p>\n<h1>any 타입 지양하기</h1>\n<p>any의 위험성..</p>\n<h2>any 타입에는 타입 안정성이 없다.</h2>\n<pre><code class=\"language-ts\">let age: number = 10\nconst one = \"1\" as any\nage += one\n//age \"101:\n</code></pre>\n<p>age는 number 타입이지만, any를 설정함으로써 string 타입을 할당할 수 있게 된다. 런타임에서 age는 string이다..</p>\n<h2>함수 시그니처를 무시해버린다.</h2>\n<p>함수를 작성할 때는 시그니처를 명시해야 한다. 호출하는 쪽은 약속된 타입의 입력을 제공하고, 함수는 약속된 타입의 출력을 반환한다. any는 이런 약속을 무시해버릴 수 있다.</p>\n<pre><code class=\"language-ts\">function sum(a: number, b: number): number {\n  return a + b\n}\n\nconst a = \"3\" as number\nconst b = 5\nsum(a, b) //정상적으로 작동함.\n</code></pre>\n<h2>언어 서비스가 적용되지 않는다.</h2>\n<p>자동완성 기능 제공하지 않는다. 또한 Rename Symbol 기능을 사용하면 프로그램 내 모든 속성의 이름을 변경해주지만 any 타입이라면 적용되지 않는다.</p>\n<h2>타입 설계를 감춘다.</h2>\n<p>상태 객체의 설계를 감추기 때문에, 설계가 어떻게 되어있는지 전혀 알 수 없다. 내가 아닌 다른 사람이 코드를 본다면 파악하기 위해 코드를 재구성 해봐야 한다.</p>\n<h2>신뢰도를 떨어트린다.</h2>\n<p>런타임 오류가 더 자주 발생한다. 또한 타입 오류를 고쳐야하고 머릿속에 실제 타입을 기억해야 하기 때문에 번거롭다.</p>","id":"c6927e48-b60a-5406-8e46-4523fec67491"},{"fields":{"slug":"/tech/React/GlobalState/"},"excerpt":"React에서 전역 상태 관리는 왜 필요할까? 리액트는 단방향 데이터 바인딩이라는 특징을 가진다. 단방향 데이터 바인딩 특징은 어플리케이션이 예측 가능하다는 장점이 있지만, 뷰를 업데이트 해주는 부분을 매번 작성해주어야 한다는 단점이 있다. 리액트의 경우 뷰가 state에 따라서 자동으로 갱신되어 뷰를 업데이트 해주는 코드를 작성할 필요는 없지만, 이 state를 어플리케이션 구조에 맞게 잘 전달해주는 과정이 필요하다. 만일 컴포넌트 구조가 …","frontmatter":{"date":"2022-10-17T00:00:00.000Z","description":"전역 상태 관리는 왜 필요하고, 어떤 도구들이 있나","title":"React의 전역 상태 관리"},"html":"<h1>React에서 전역 상태 관리는 왜 필요할까?</h1>\n<p>리액트는 단방향 데이터 바인딩이라는 특징을 가진다. 단방향 데이터 바인딩 특징은 어플리케이션이 예측 가능하다는 장점이 있지만, 뷰를 업데이트 해주는 부분을 매번 작성해주어야 한다는 단점이 있다. 리액트의 경우 뷰가 state에 따라서 자동으로 갱신되어 뷰를 업데이트 해주는 코드를 작성할 필요는 없지만, 이 state를 어플리케이션 구조에 맞게 잘 전달해주는 과정이 필요하다. 만일 컴포넌트 구조가 매우 깊은 트리 구조라면 해당 state를 넘겨주는데 여러 단계를 거쳐야하고, 이 state가 어디서부터 전달되었는지 추적하기 어려울 것이다.</p>\n<p>이러한 문제를 해결하기위해 전역 상태 관리 도구는 어떠한 컴포넌트에서도 전역으로 관리되는 state에 바로 접근할 수 있도록 해준다. state를 전달하기위해 여러 단계를 거칠 필요가 없는 것이다.</p>\n<p>해당 상태가 어플리케이션 전반에 이용되어 상태를 전달하기 위한 단계가 복잡할 경우, 혹은 전반에 이용되지 않더라도 상태를 전달하기 위한 단계가 복잡할 경우 사용된다.</p>\n<h1>전역 상태 관리를 위한 도구들</h1>\n<h2>Redux</h2>\n<p>리덕스는 리액트 이외에도 자바스크립트로 만들어진 어플리케이션이라면 사용할 수 있다.</p>\n<p>리덕스는 액션이라고 불리는 이벤트를 통해서만 state를 업데이트 시킬 수 있다. 이는 리액트가 사용하는 단방향 데이터 바인딩과 같은 원리로 상태 변경을 예측하기 쉽도록 한다. 언제, 어디서, 왜, 어떻게 state가 변경되었는지 파악할 수 있다.</p>\n<p>리덕스의 이러한 구조는 상태의 변경이 예측 가능하다는 장점도 있지만, 러닝 커브가 있고 구현하기위해 더 많은 코드를 작성해야한다.</p>\n<h3>언제 리덕스를 도입하면 좋을까</h3>\n<ul>\n<li>어플리케이션이 많은 상태를 보유하고, 어플리케이션의 여러 공간에서 사용될 때</li>\n<li>상태가 매우 자주 변경될 때</li>\n<li>상태 변경 로직이 복잡할 때</li>\n<li>어플리케이션의 규모가 클 때, 많은 사람들과 작업해야 할 때</li>\n</ul>\n<p>예측 가능하고, 테스트가 쉽다는 장점에 대규모 어플리케이션에 적합하다. 또한 상태 변경을 손쉽게 추적할 수 있기에 상태 변경 로직이 복잡할 때도 사용하면 좋다.</p>\n<h3>주요 개념</h3>\n<ul>\n<li>스토어는 전역 state를 저장하는 곳으로 자바스크립트 object인데 특별한 함수와 기능을 내장하고 있어 순수 전역 객체와 다르다.</li>\n<li>우리는 스토어 내부의 state를 직접적으로 수정하면 안된다. 이는 정해진 방식으로만 state를 조작하여 예측가능하다는 redux의 원칙을 위배한다.</li>\n<li>state를 변경하는 방법은 순수 액션 객체를 만들고 활용함으로써 가능하다. 액션 객체는 어플리케이션에 무슨 일이 발생할 것인지 알려준다. 그리고 dispatch를 사용해서, action을 전달한다.</li>\n<li>액션이 dispatch되면, reducer를 실행시키고 old state를 기반으로 new state를 계산하여 업데이트한다. old state에서 new state로 변경시킬 때 immutable을 유지해야한다. 만약 immutable하지 않다면 old state와 new state를 비교할 때 문제가 발생하고 리듀서가 올바르게 작동하지 않는다. (객체는 참조값이기 때문에.)</li>\n<li>마지막으로 스토어는 subscribers에게 구독중인 state가 변경되었다고 알려주고 UI가 변경되게 된다.</li>\n</ul>\n<h2>Recoil</h2>\n<p>Recoil은 facebook에서 출시한 상태관리 라이브러리이다.</p>\n<p>state는 공통된 상위 컴포넌트로 끌어올려야만 공유될 수 있으며 이 과정에서 거대한 트리가 다시 렌더링 되는 문제와 Context는 단일값만 저장할 수 있으며, 자체 소비자를 가지는 여러 값들의 집합을 담을 수 없다는 문제를 해결하기위해 탄생했다.</p>\n<h3>Recoil의 특징</h3>\n<p>boiler-plate free api로 redux는 간단한 상태 한개만 처리하려고 해도 수많은 보일러 플레이트 코드가 필요하였으나 recoil은 매우 간단하게 사용할 수 있다. 즉 러닝커브가 낮다고 할 수 있다.\n또한 비동기처리를 하기 위해서 redux의 경우는 redux-thunk와 같은 비동기 처리 라이브러리에 의존했지만 recoil에는 내장되어 있다.</p>\n<h3>주요 개념</h3>\n<ol>\n<li>atoms\n<ul>\n<li>atoms는 상태의 단위이며 업데이트와 구독이 가능하다. atom이 업데이트되면 각각의 구독된 컴포넌트는 새로운 값을 받아 리렌더링 된다. atoms는 런타임 중에서도 생성될 수 있다.</li>\n</ul>\n</li>\n<li>selectors\n<ul>\n<li>atoms나 다른 selectors를 입력으로 받아들이는 순수 함수다. 상위의 atoms 또는 selectors가 업데이트되면 하위의 selector 함수도 다시 실행된다. 컴포넌트들은 selectors를 atoms처럼 구독할 수 있으며 selectors가 변경되면 컴포넌트들도 다시 렌더링된다. selectors는 상태를 기반으로 파생된 데이터를 사용하는데 이용된다. <strong>최소한의 상태 집합만 atoms에 저장하고 파생된 데이터는 selectos를 통해서 처리함으로써 불필요한 상태의 보존을 방지할 수 있다.</strong></li>\n</ul>\n</li>\n</ol>\n<h2>Context api</h2>\n<p>Context api는 react에 자체적으로 내장된 전역 상태 관리 도구이다.</p>\n<h3>언제 Context api를 사용하면 좋을까?</h3>\n<p>상태 변경이 빈번하게 일어나지 않을 때, 간단한 데이터를 전역으로 공유하고 싶을 때 사용하면 좋다. Provider의 모든 하위 컴포넌트가 렌더링이 일어나기 때문이다. 예시로 언어 설정이나, 다크 모드 변경과 같은 스타일 설정을 저장해놓는데 적합하다.</p>\n<h1>API Response 캐싱을 위한 전역 상태 관리 이용</h1>\n<p>위투디 정식 서비스를 제작할 때, 나는 API Response를 캐싱하기로 했다. 기존에는 local state,useEffect로 구현되어 있어 컴포넌트가 렌더링 될 때마다 api를 요청했다. 유저 입장에서는 이미 한번 불러온 데이터를 다시 불러오는데 불필요한 로딩 시간이 생겼고, 성능적으로도 불필요한 네트워크 요청을 하기에 좋지 않았기 때문이다.</p>\n<p>초기에 Redux를 선택했다. 하지만 Redux는 비동기 처리가 불가능하기에 redux-thunk와 같은 비동기 미들웨어를 사용해야 하였고, 하나의 api 결과값을 캐싱하는데 매우 많은 코드가 필요하였다. 또한 redux를 활용하여 캐싱할 경우 결과값이 언제까지 유효할지에 대해서도 직접 설정을 해주어야했다.</p>\n<p>이후에는 react-query라는 라이브러리를 사용했다. redux와 같은 많은 보일러플레이트 코드들이 필요없었고, 유효 시간을 정해줄 수 있어 매우 유용했다. 또한 최근에는 Suspense와 연동이 되기에 데이터를 fetch 할 동안 fallback-ui를 보여줄 수 있다. 매번 컴포넌트마다 loading 관련 분기를 만들어 처리하지 않아도 된다. 마치 try-catch 구문처럼 관심사를 분리하여 더 효율적이고 가독성 높은 코드를 만들 수 있는 것이다.</p>\n<p>recoil의 경우, 비동기 처리를 별도의 라이브러리 없이 할 수 있고 fetch 중에는 Promise를 리턴하기에 Suspense 기능도 react-query와 마찬가지로 적용할 수 있다.</p>\n<p>만일 API Response를 캐싱하기 위해서 Redux를 선택한다면, 나는 기술에 대한 올바른 선택이 아니라고 말하고 싶다. Redux는 위에서 작성했듯 상태 변경이 빈번하게 일어나고, 상태 변경이 매우 복잡할 때 사용하면 좋다. 나의 경우 웹기반 디자인 에디터를 만들 때 리덕스를 활용했는데 리덕스의 특징에 따라 상태 변경이 매우 예측가능 하였고, 상태 변경을 쉽게 추적할 수 있다는 장점이 있었다.</p>\n<p>기술의 특징과 컨셉을 파악하고, 상황에 맞게 올바른 기술을 선택한다면 개발 생산성 향상을 통해 많은 시간을 세이브 할 수 있을 것이다!</p>","id":"d1ab9ee2-c0be-5477-b15c-54461acf94e5"},{"fields":{"slug":"/cs/web/브라우저/"},"excerpt":"브라우저 목적 브라우저의 주요 기능은 사용자가 명시한 자원을 서버에 요청하고 이를 브라우저에 표시하는 것이다.\n대부분 HTML 문서이며, 브라우저는 HTML 파일을 해석하여 화면에 보여주는 역할을 한다.\n헤석 과정에서 요즘 브라우저는 W3C에서 정하는 표준 명세를 대부분 따라서 호환성이 과거에 비해 크게 향상되었다. 브라우저의 구성 브라우저는 7개의 부분으로 구성되어 있다. 사용자 인터페이스 - 주소 표시줄, 이전/다음/새로고침 버튼 등 웹페…","frontmatter":{"date":"2022-10-15T00:00:00.000Z","description":"작성중.","title":"브라우저에 대해서"},"html":"<h1>브라우저 목적</h1>\n<p>브라우저의 주요 기능은 사용자가 명시한 자원을 서버에 요청하고 이를 브라우저에 표시하는 것이다.\n대부분 HTML 문서이며, 브라우저는 HTML 파일을 해석하여 화면에 보여주는 역할을 한다.\n헤석 과정에서 요즘 브라우저는 W3C에서 정하는 표준 명세를 대부분 따라서 호환성이 과거에 비해 크게 향상되었다.</p>\n<h1>브라우저의 구성</h1>\n<p>브라우저는 7개의 부분으로 구성되어 있다.</p>\n<ol>\n<li><strong>사용자 인터페이스</strong> - 주소 표시줄, 이전/다음/새로고침 버튼 등 웹페이지를 제외하고 사용자와 상호 작용하는 인터페이스이다.</li>\n<li><strong>브라우저 엔진</strong> - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어한다.</li>\n<li><strong>렌더링 엔진</strong> - 요청한 콘텐츠를 표시한다. HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 보여준다.</li>\n<li><strong>통신(Networking)</strong> - HTTP 요청과 같은 네트워크 호출에 사용된다. 플랫폼의 독립적인 인터페이스로 구성되어 있다.</li>\n<li><strong>자바스크립트 해석기</strong> - JS 코드를 해석하고 실행한다.</li>\n<li><strong>UI 백엔드</strong> - 콤보 박스와 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않았기에 OS 사용자 인터페이스 체계를 따른다.</li>\n<li><strong>자료 저장소</strong> - 쿠키, 로컬 스토리지 등 브라우저에 데이터를 저장할 수 있는 공간.</li>\n</ol>\n<h1>브라우저의 렌더링 과정</h1>\n<h1>브라우저의 이벤트 루프</h1>\n<p><a href=\"https://www.youtube.com/watch?v=YpQTeIqjC4o\">우테코 브라우저의 이벤트 루프</a></p>\n<h1>참고 자료</h1>\n<p><a href=\"https://d2.naver.com/helloworld/59361\">네이버 D2 자료</a></p>\n<p><a href=\"https://d2.naver.com/helloworld/5237120\">네이버 D2 자료2</a></p>","id":"cce72fd4-a726-5f4c-9012-179561fd66a4"},{"fields":{"slug":"/알고리즘/스타수열/"},"excerpt":"문제 링크 해결 전략 처음에 이 문제를 완전탐색 형태로 해결하고자 하였다. a의 부분 수열을 모두 만들고, 스타 수열인지 확인하는 방식으로 알고리즘을 짰다. 하지만 이 방식은, a의 길이가 최대 500,000이므로 절대 만족할 수 없다. 조합의 경우 O(2^n)의 시간 복잡도를 가지기 때문이다. 그렇다면 반대로 생각해봐야 한다. 모든 부분 수열을 만들어보고 스타 수열인지 검증하는 대신, 주어진 배열을 활용해서 직접 스타 수열을 만들어보면 된다…","frontmatter":{"date":"2022-10-13T00:00:00.000Z","description":"백트래킹","title":"스타수열"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/70130\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>처음에 이 문제를 완전탐색 형태로 해결하고자 하였다. a의 부분 수열을 모두 만들고, 스타 수열인지 확인하는 방식으로 알고리즘을 짰다. 하지만 이 방식은, a의 길이가 최대 500,000이므로 절대 만족할 수 없다. 조합의 경우 O(2^n)의 시간 복잡도를 가지기 때문이다.</p>\n<p>그렇다면 <strong>반대로 생각해봐야 한다.</strong> 모든 부분 수열을 만들어보고 스타 수열인지 검증하는 대신, 주어진 배열을 활용해서 직접 스타 수열을 만들어보면 된다!</p>\n<p>스타수열을 만들 때, 우리는 중복된 숫자가 꼭 필요하다. 따라서 중복된 숫자가 많을수록 더 길이가 긴 스타수열을 만들 수 있다. 하지만 중복된 숫자가 많다고 해서 꼭 스타수열의 길이가 긴 것은 아니기에, 중복된 숫자의 개수가 큰 순서대로 검증해나가는 백트래킹 방식을 사용하면 된다.</p>\n<p><code>[1,1,1,1,1,1,1,1,1,1,2,3,2,3,2]</code>과 같은 배열의 경우 1이 가장 많은 중복된 숫자지만, 1을 교집합으로 두었을 때 스타 수열을 만들 수 없다. 1이 연속적으로 배치되어 있어 i번쨰와 i+1번째가 같기 때문이다. 따라서 그 다음으로 중복된 개수가 많은 2를 검증해야 한다.</p>\n<p>스타 수열 조건을 만족하는 부분 수열들을 찾아나가면서 합하는 방식으로 스타 수열의 최대 길이를 구할 것이다. 최대한 길이가 긴 스타 수열을 구하기 위해서는 좌측부터 만족시키면서 나가면 된다. 그래야 우측에 남은 배열의 길이가 길어져 더 길이가 긴 부분 수열을 만들 수 있다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-js\">function solution(a) {\n  //배열 내에서, 중복된 숫자의 순서가 많은 순서대로 정렬한다.\n  const obj = {}\n  a.forEach(v => {\n    if (!obj[v]) obj[v] = 1\n    else obj[v] += 1\n  })\n\n  const sameNumberCounts = Object.entries(obj).sort((a, b) => b[1] - a[1])\n\n  //스타 수열을 만족하는 최대 부분 수열을 찾는다.\n  let answer = 0\n\n  for (let [number, cnt] of sameNumberCounts) {\n    number = Number(number)\n    if (answer > cnt) break\n\n    let len = 0\n    for (let i = 0; i &#x3C; a.length; i++) {\n      if (a[i + 1] === undefined) continue\n\n      if (a[i] === number &#x26;&#x26; a[i + 1] !== number) {\n        len += 2\n        i++\n        continue\n      }\n      //좌측부터 만족하는지 확인, 좌측부터 만족하는지 확인해야 남는 우측 길이가 김.\n\n      if (a[i] !== number &#x26;&#x26; a[i + 1] === number) {\n        len += 2\n        i++\n        continue\n      }\n      //좌측이 만족하지 않는다면 우측으로 확인\n    }\n    answer = Math.max(answer, len)\n  }\n  return answer\n}\n</code></pre>","id":"46cdd6bd-2022-521c-8533-167ea9cf86fb"},{"fields":{"slug":"/programming/함수형 자바스크립트/2장/"},"excerpt":"함수형 대 객체지향 프로그래밍 객체지향은 잘게 나뉜 기능을 구현하기위해 상속을 통하여 특수한 자료형을 생성한다.\n예시로 학습 관리 시스템의 Student 객체를 모형화 해보면 해당 클래스는 Person 클래스의 하위형이다. 만일 대학교를 다니는 학생이라면, ColleageStudent 같은 형식을 만들어서 붙인다.\nOOP는 새로운 파생 객체를 생성하여 코드를 재사용한다. 하지만 이러한 방식은 모든 하위형에 적용할 필요가 없는 기능을 기존 객체…","frontmatter":{"date":"2022-10-13T00:00:00.000Z","description":"고계 자바스크립트","title":"함수형 자바스크립트 2장"},"html":"<h1>함수형 대 객체지향 프로그래밍</h1>\n<p>객체지향은 잘게 나뉜 기능을 구현하기위해 상속을 통하여 특수한 자료형을 생성한다.\n예시로 학습 관리 시스템의 <code>Student</code> 객체를 모형화 해보면 해당 클래스는 <code>Person</code> 클래스의 하위형이다. 만일 대학교를 다니는 학생이라면, <code>ColleageStudent</code> 같은 형식을 만들어서 붙인다.\n<strong>OOP는 새로운 파생 객체를 생성하여 코드를 재사용한다.</strong></p>\n<p>하지만 이러한 방식은 모든 하위형에 적용할 필요가 없는 기능을 기존 객체에 추가할 때 문제가 발생한다. 예를 들면 <code>Person</code>에 <code>workAddress</code>라는 속성이 있다고 가정해보자. 이는 <code>Student</code>, <code>ColleageStudent</code> 객체에서 전혀 쓸모가 없다.</p>\n<p>명령형 코드인 OOP는 인스턴스 메소드를 통해 가변 상태를 노출하고 조작하는데 이를 위해서 캡슐화에 지나치게 의존하여 무결성을 유지한다. 데이터와 기능이 단단히 응집된다.</p>\n<p>반면에 함수형은 호출자로부터 데이터를 숨길 필요 없이 소규모의, 아주 단순한 자료형만을 대상으로 움직인다. 즉 데이터와 기능이 느슨하게 결합되어 있다.</p>\n<p>FP와 OOP를 적절히 조합하면 최고의 생산성으로 코드를 짤 수 있다. 그러기 위해서는 객체를 불변 개체나 불변 값으로 바라보고 기능을 함수로 분리하여 객체 내에서 작동되게끔 해야한다. <code>Person</code> 객체를 통해서 예시를 들어보자.</p>\n<pre><code class=\"language-js\">//oop\nget fullname(){\n    return [this._firstname, this._lastname].join('')\n}\n\n//함수로 분리\nconst fullname = (person) => [person._firstname, person._lastname].join('')\n</code></pre>\n<p>기반형을 레퍼런스를 사용하는 함수라면 파생형 객체에서도 문제없이 작동한다. (<code>Student</code>나 <code>ColleageStudent</code>에도 <code>Person</code>의 <code>_firstname</code>, <code>_lastname</code>을 상속받기 때문.)\n독립형 함수로 분리함으로써 객체 데이터를 this로 접근할 이유가 사라진다. this를 사용한다는 것이 메소드에 범위의 벗어나 인스턴스 수준의 데이터에 접근한다는 것으로 부수효과를 발생한다. 또한 범용성이 높아졌다.</p>\n<h1>JS 객체의 상태 관리</h1>\n<p>프로그램의 상태란 어느 한 시점에 찍은 모든 객체에 저장된 데이터의 스냅샷이다. JS는 객체 상태를 보호하는 측면에서 최악의 언어 중 하나이기에 함수형 프로그래밍을 하기 위해서는 객체의 상태 관리에 유의해야 한다. 불변성 관리를 위한 지침과 패턴을 소개하도록 한다.</p>\n<ol>\n<li>객체를 값으로 취급</li>\n<li>가동부를 깊이 동결</li>\n<li>객체 그래프를 렌즈로 탐색 수정</li>\n</ol>\n<h2>1. 객체를 값으로 취급</h2>\n<p>숫자와, 문자열 같은 자료형은 불변값이다. FP에서는 이러한 불변값을 값(value)이라고 한다.</p>\n<p>객체 구조가 단순하다면 값-객체 패턴도 괜찮은 방안이다. 값 객체는 객체의 동등성이 항등성이나 레퍼런스가 아닌 오직 값에 따라 좌우되는 객체이다. 일단 값 객체를 선언한 이후엔 그 상태는 절대 변하지 않는다. 예시로 클로저를 사용하고 내부 상태 변화를 일으키지 않는 메소드만을 제공한다면, 외부에서 접근하여 값을 변경할 수 없다. 동일한 모형의 값이 다른 객체가 필요한 경우 사본을 만들어서 리턴한다.</p>\n<h2>2. 가동부를 깊이 동결</h2>\n<p>실무에서 모든 객체를 값-객체 패턴으로 만들 수 없다. 또한 Student-Person과 같은 계층적 데이터를 처리하는 코드가 필요할 때가 있다.\nwritable처럼 숨겨진 메타속성을 제어하면 내부 조작이 가능하다. Object.freeze() 함수는 writable 속성을 전부 false로 세팅하여 객체 상태를 못 바꾸도록 동결한다. 하지만 객체 내부의 객체와 같은 중첩 객체의 경우에는 동결되지 않는 얕은 동결이기에 만일 객체 내부의 모든 값을 동결시키기를 원한다면 재귀함수를 이용하여 구현해줘야 한다.</p>\n<p>하지만 상태를 전혀 바꿀 수 없는 애플리케이션이란 현실적이지 않다. 원본 객체에서 새 객체를 만드는 엄격한 정책을 적용하면 도움이 된다.</p>\n<h2>3. 객체 그래프를 렌즈로 탐색/수정</h2>\n<p>해당 방식은 원본 객체에서, 새 객체를 만드는 방식이다. 다만 내부 저장소 컴포넌트를 이용하기에 한번 등록 시켜놓으면 매번 새로운 객체를 만드는 행위를 할 필요가 없다. 람다JS라는 라이브러리가 해당 기능을 제공한다. R.set 함수는 원래 상태는 그대로 유지한 채 새로운 값이 포함된 객체 사본을 새로 만들어 반환한다. 중첩 객체까지 지원한다.</p>\n<h1>함수</h1>\n<h2>함수를 일급 시민으로</h2>\n<p>JS의 함수는 실제로 객체이기 때문에 일급이다.</p>\n<p><em>일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 뜻한다. 3가지 원칙을 만족해야한다. 1. 변수에 담을 수 있다. 2. 인자로 전달할 수 있다. 3. 반환값으로 전달할 수 있다.</em></p>\n<p><em>함수를 다른 변수와 동일하게 다루는 언어는 일급 함수를 가졌다라고 표현한다. 함수를 다른 함수의 인수로 제공하거나 함수가 함수를 반환할 수 있고, 변수에도 할당할 수 있다. 자바스크립트는 일급 함수를 가졌다.</em></p>\n<h2>고계 함수</h2>\n<p>함수를 함수 인수로 전달하거나 함수를 반환받을 수 있다. 이러한 함수를 고계함수(higher-order-function)이라고 한다. 예시로 Array.sort()의 comparator 함수도 고계함수이다.</p>\n<p>JS에서 함수는 일급+고계여서 여느 값이나 다름이 없다. 즉 자신이 받은 입력값을 기반으로 정의된 언제가는 실행될 값에 지나지 않는다.</p>\n<p>고계함수를 사용하면 아주 장황했을 프로그램이 매우 단순해진다. 미국 거주자 명단을 출력하는 프로그램 예시를 통해서 알아보도록 한다.</p>\n<pre><code class=\"language-js\">//명령형\nfunction printPeopleInUs(people) {\n  for (let person of people) {\n    if (person.address.country === \"US\") {\n      console.log(person)\n    }\n  }\n}\n</code></pre>\n<pre><code class=\"language-js\">//고계함수 이용\nfunction printPeople(people, action) {\n  for (let person of people) {\n    action(person)\n  }\n}\n\nfunction action(person) {\n  if (person.address.county === \"US\") {\n    console.log(person)\n  }\n}\n</code></pre>\n<pre><code class=\"language-js\">//범용성을 위한 리팩토링\nfunction printPeople(people, selector, printer) {\n  people.forEach(person => {\n    if (selector(person)) {\n      printer(person)\n    }\n  })\n}\n\nconst selector = person => person.address.country === \"US\"\nconst printer = somthing => console.log(somthing)\nprintPeople(people, selector, printer)\n</code></pre>\n<p>리팩토링을 통해서 데이터를 고르는 기준을 변경할 수 있고 출력 대상을 바꾸는 일도 자유롭다.</p>\n<h2>함수 호출 유형</h2>\n<ol>\n<li>전역 함수로 호출\n<ul>\n<li>this 레퍼런스는 전역 객체, 엄격 모드일 경우에는 undefined를 가르킨다.</li>\n</ul>\n</li>\n<li>메소드로 호출\n<ul>\n<li>this 레퍼런스는 해당 메서드를 소유한 객체이다.</li>\n</ul>\n</li>\n<li>new를 붙여 생성자로 호출\n<ul>\n<li>새로 만든 객체의 레퍼런스를 암시적으로 반환한다.</li>\n</ul>\n</li>\n</ol>\n<h2>함수 메서드</h2>\n<p>apply, call, map, filter와 같은 메소드가 있다.</p>\n<h1>클로저</h1>\n<p><a href=\"https://ko.javascript.info/closure\">클로저 상세 설명 링크</a></p>\n<p>클로저는 다음과 같이 응용될 수 있다.</p>\n<ol>\n<li>프라이빗 변수를 모방</li>\n<li>서버 측 비동기 호출</li>\n<li>가상의 블록 스코프 변수 생성</li>\n</ol>\n<h2>프라이빗 변수 모방</h2>\n<p>다른 프로그래밍 언어는 private 접근자로 객체 내부 속성을 세팅할 수 있으나 JS는 불가능하다. 클로저를 활용하면 프라이빗 변수를 모방할 수 있다.</p>\n<p>자바스크립트 라이브러리나 모듈 개발자는 전체 모듈의 프라이빗 메서드와 데이터를 숨길 때 클로저를 적극 활용한다. 이를 모듈 패턴이라고 한다. 전역 레퍼런스 개수를 줄이기 위해서 즉시 실행 함수를 사용한다.</p>\n<pre><code class=\"language-js\">var myModule = (function myModule(export){\n    //에러 발생 시 스택을 보며 추적할 수 있도록 함수에 이름을 붙인다.\n    let privateVar;\n\n    export.method1 = function () {\n        //작업 수행\n    }\n\n    export.method2 = function () {\n        //작업 수행\n    }\n    return export\n})(myModule || {})\n</code></pre>\n<h3>전역 스코프의 문제점</h3>\n<p>전역 스코프는 가장 단순하면서 나쁜 스코프이다. JS의 함수는 스코프 체인을 따라서 변수를 확인하기 떄문에 전역 스코프를 사용하는 것이 관찰 가능한 어떤 변화를 함수에 전파하는 것과 동일하다. 또한 전역 데이터는 변수 상태가 언제 어떻게 바뀌는지 디버깅하기 어렵다.</p>\n<h2>서버 측 비동기 호출</h2>\n<p>콜백 함수(고계 함수)를 사용하여 비동기 처리를 할 수 있다.</p>\n<h2>가상의 블록 스코프 변수 생성</h2>\n<p>루프 카운터 문제 역시 클로저로 해결할 수 있다. let을 쓴다면 기존 루프 체제 문제는 해결이 되지만, 클로저와 함수 스코프를 활용한 forEach가 정답이다. 루프 카운터와 다른 변수들을 스코프 내부에 묶느라 고민하지 않아도 루프문에 함수 스코프 블록이 존재하는 것처럼 루프 본체를 효과적으로 감쌀 수 있다.</p>\n<pre><code class=\"language-js\">const arr = [1, 2, 3, 4]\narr.forEach(el => {\n  let blockScopeVar = \"hi\"\n})\n</code></pre>","id":"8b6ed648-4502-5ab2-94ea-7b151bb8595d"},{"fields":{"slug":"/알고리즘/기지국설치/"},"excerpt":"문제 링크 해결 전략 이 문제는 아이디어로 푸는 문제이다. 우리가 구하고자 하는 값은 추가적으로 설치된 기지국의 개수이다. 즉, 기지국이 어디에 설치되는지는 알 필요가 없다는 의미이다. 작은 예시를 통해서 설치해야 할 기지국 개수를 알아본다. 만일 기지국이 전혀 없는 4개의 아파트가 있다고 가정하고, 전파 도달 거리가 1이라면 몇 개의 기지국 설치가 필요할까? 1개의 기지국이 차지하는 영역은 본인의 자리 + 앞 뒤로 w 만큼이다. 즉 2*w+…","frontmatter":{"date":"2022-10-12T00:00:00.000Z","description":"투포인터","title":"기지국 설치"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/12979\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>이 문제는 아이디어로 푸는 문제이다.</p>\n<p><strong>우리가 구하고자 하는 값은 추가적으로 설치된 기지국의 개수이다.</strong> 즉, 기지국이 어디에 설치되는지는 알 필요가 없다는 의미이다.</p>\n<p>작은 예시를 통해서 설치해야 할 기지국 개수를 알아본다. 만일 기지국이 전혀 없는 4개의 아파트가 있다고 가정하고, 전파 도달 거리가 1이라면 몇 개의 기지국 설치가 필요할까?</p>\n<p>1개의 기지국이 차지하는 영역은 본인의 자리 + 앞 뒤로 w 만큼이다. 즉 <code>2*w+1</code>의 길이만큼 차지하게 된다. 위의 예시의 경우 총 2개의 기지국 설치가 필요하다. 기지국의 영역이 4를 넘어가기는 하지만, 전체 영역을 채워야 하기에 2개가 필요하다. <code>3 * 2 > 4</code></p>\n<p>문제에서는 기지국이 설치된 <code>stations</code> 배열이 주어진다. <strong>추가적으로 기지국을 설치해야 할 부분은 설치된 기지국들이 포함하지 못하는 기지국이 전혀 없는 영역이다.</strong></p>\n<p>우리는 방금 예시를 통해서 기지국이 전혀 없는 영역에서 몇개의 기지국을 설치해야 하는지 알게되었다. 그렇다면 이제 필요한 것은 기지국이 전혀 없는 영역을 구하는 것이다.</p>\n<p>기지국이 전혀 없는 영역을 구하기 위해서는 투포인터 알고리즘을 사용하면 된다.</p>\n<pre><code>before = 이전 기지국의 전파가 도달하지 않는 우측 위치.\ncurrent = 현재 기지국의 전파가 마지막으로 도달하는 좌측 위치.\n</code></pre>\n<p>또한 가장 중요한 부분은 포인터에 넣을 위치를 기지국이 마지막으로 포함하는 거리인지, 아니면 바로 못미치는 영역인지 정의해주어야 한다.</p>\n<p>나는 기지국이 처음 시작할 때의 환경을 고려하여 <code>before</code> 변수에는 기지국이 존재하지 않는 상태의 위치, <code>current</code> 변수에는 기지국이 마지막으로 포함하는 거리로 넣어주었다.</p>\n<pre><code class=\"language-js\">let current = 1\nlet before = 1\n\nlet answer = 0\nconst area = w => w * 2 + 1\n\nfor (let i = 0; i &#x3C; stations.length; i++) {\n  current = stations[i] - w\n\n  const diff = current - before\n\n  if (diff > 0) {\n    answer += Math.ceil(diff / area(w))\n  }\n\n  before = stations[i] + w + 1\n}\n</code></pre>\n<p>마지막 라인에 <code>before</code>변수를 <code>stations[i] + w + 1</code>로 초기화 시켜준 이유는 i번째 기지국이 이제 이전 기지국이 되었으며 <code>stations[i] + w + 1</code>이 전파가 도달하지 않는 우측 위치이다.</p>\n<pre><code class=\"language-js\">if (before &#x3C;= n) {\n  answer += Math.ceil((n - before + 1) / area(w))\n}\n</code></pre>\n<p>마지막으로 위의 코드가 필요하다. 왜냐면 마지막 기지국이 n까지 전파가 닿지 않는다면 해당 부분을 채워주어야 하기 때문이다. 여기서 n은 기지국이 설치되어 있지 않는 상태이기 때문에 <code>before &#x3C;=n</code>으로 작성했으며 <code>n-before+1</code>을 한 값을 <code>area(w)</code>로 나누었다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-js\">function solution(n, stations, w) {\n  let current = 1\n  let before = 1\n\n  let answer = 0\n  const area = w => w * 2 + 1\n\n  for (let i = 0; i &#x3C; stations.length; i++) {\n    current = stations[i] - w\n\n    const diff = current - before\n\n    if (diff > 0) {\n      answer += Math.ceil(diff / area(w))\n    }\n\n    before = stations[i] + w + 1\n  }\n\n  if (before &#x3C;= n) {\n    answer += Math.ceil((n - before + 1) / area(w))\n  }\n  return answer\n}\n</code></pre>","id":"2c04d398-b87f-5e70-ab21-36a7c645bfc8"},{"fields":{"slug":"/programming/함수형 자바스크립트/1장/"},"excerpt":"함수형 프로그래밍이란? 함수 사용을 강조하는 소프트웨어 개발 스타일이다. 단순히 함수를 사용하는 것이 아니라, 애플리케이션의 부수효과(side effect)를 방지하고 상태 변이(mutation of state)를 감소하기 위해 데이터의 제어 흐름과 연산을 추상하는 것이다. 함수형 프로그래밍을 이해하기 위해서는 다음의 4가지 개념을 이해해야 한다. 선언적 프로그래밍 순수 함수 참조 투명성 불변셩 1. 선언적 프로그래밍 내부적으로 코드를 어떻게…","frontmatter":{"date":"2022-10-12T00:00:00.000Z","description":"함수형으로 사고하기","title":"함수형 자바스크립트 1장"},"html":"<h1>함수형 프로그래밍이란?</h1>\n<p>함수 사용을 강조하는 소프트웨어 개발 스타일이다.</p>\n<p>단순히 함수를 사용하는 것이 아니라, <strong>애플리케이션의 부수효과(side effect)를 방지하고 상태 변이(mutation of state)를 감소하기 위해 데이터의 제어 흐름과 연산을 추상하는 것이다.</strong></p>\n<p>함수형 프로그래밍을 이해하기 위해서는 다음의 4가지 개념을 이해해야 한다.</p>\n<ol>\n<li>선언적 프로그래밍</li>\n<li>순수 함수</li>\n<li>참조 투명성</li>\n<li>불변셩</li>\n</ol>\n<h2>1. 선언적 프로그래밍</h2>\n<p>내부적으로 코드를 어떻게 구현했는지, 데이터는 어떻게 흘러가는지 밝히지 않은 채 연산을 표현하는 사상이다.</p>\n<p>배열의 모든 요소를 제곱수로 바꿔주는 예시로 명령형, 선언적 프로그래밍을 비교해본다.</p>\n<pre><code class=\"language-javascript\">//명령형\nconst arr = [1, 2, 3, 4, 5]\nfor (let i = 0; i &#x3C; arr.length; i++) {\n  array[i] = array[i] * array[i]\n}\n</code></pre>\n<pre><code class=\"language-javascript\">//선언적\nconst arr = [1, 2, 3, 4, 5]\narr.map(el => el * el)\n</code></pre>\n<p>위의 예시로 보았을 때 선언적 프로그래밍의 경우 코드가 매우 간결하다. 루프 카운터를 관리하고 배열 인덱스에 정확하게 접근하는 일을 개발자는 할 필요없이 루프 제어는 시스템에 맡겨버리기 때문이다.\n명령형 코드의 경우 루프를 제어하다가 오류가 날 수 있고 배열 자체를 건드리기 때문에 부수효과가 발생할 수 있다.</p>\n<h2>2. 순수 함수</h2>\n<p>순수 함수의 특성은 아래와 같다.</p>\n<ol>\n<li>주어진 입력에만 의존할 뿐, 평가 도중 또는 호출 간 변경될 수 있는 숨겨진 값이나 외부 상태와 무관하게 작동한다.</li>\n<li>전역 객체나 레퍼런스로 전달된 매개변수를 수정하는 등 함수 스코프 밖에서 어떠한 변경도 일으키지 않는다.</li>\n</ol>\n<p>위의 조건을 만족하지 않는 함수는 모두 불순하다고 할 수 있다.</p>\n<pre><code class=\"language-javascript\">let cnt = 0\nconst increment = () => {\n  counter++\n}\n</code></pre>\n<p>위의 함수의 경우는 불순하다. 전역 변수인 cnt를 직접적으로 변경시키기 때문이다.</p>\n<pre><code class=\"language-javascript\">const getToday = () => Date.now()\n</code></pre>\n<p>위 함수는 불순할까? 그렇다. 호출하는 시점에 따라서 다른 결과값을 낸다. 즉 일정한 결과값을 내지 않는다.</p>\n<p>부수효과가 발생하는 상황은 매우 다양한데 아래는 그 예시이다.</p>\n<ul>\n<li>전역 범위에서 변수,속성,자료구조를 변경</li>\n<li>함수의 원래 인수 값을 변경</li>\n<li>사용자 입력을 처리</li>\n<li>예외를 일으킨 해당 함수가 붙잡지 않고(catch) 그대로 예외를 던짐(throw)</li>\n<li>화면 또는 로그 파일에 출력</li>\n<li>HTML 문서, 브라우저 쿠키, DB에 질의</li>\n</ul>\n<p>위의 상황을 봤을 때 거의 모든 상황에서 부수효과가 발생하는 것처럼 보인다.\n함수형 프로그래밍은 모든 상태 변이를 근절하자는 것이 아니고 상태 변이를 줄이고 관리할 수 있는 프레임워크를 제공하여 순수/불순 함수를 구분하자는 것이다.</p>\n<p>실제 코드를 리팩토링 하는 과정을 통해서 어떻게 함수형으로 작성하는지 알아보도록 하자.</p>\n<pre><code class=\"language-javascript\">function showStudent(ssn) {\n  const student = db.find(ssn)\n  if (student !== null) {\n    document.querySelector(\n      `#${elementId}`\n    ).innerHTML = `${student.ssn}, ${student.firstname}, ${student.lastname}`\n  } else {\n    throw new Error(\"학생이 없습니다.\")\n  }\n}\n</code></pre>\n<p>위의 코드는 몇 가지 부수효과를 일으킨다.</p>\n<ol>\n<li>db 변수는 매개변수에 없으니 이는 외부 변수이다. 해당 변수가 변경되서 호출 단계마다 상이한 값을 가르키면 결과값이 완전히 달라진다.</li>\n<li>HTML 요소를 직접적으로 고친다. (DOM은 그 자체로 가변적인 전역 공유 자원이다.)</li>\n<li>학생 레코드를 찾지 못하면 예외를 던지면서 전체 프로그램 스택이 툭 풀리면서 종료된다.</li>\n</ol>\n<p>위 코드를 리팩토링 해보도록 한다. 긴 함수를 하나의 목적을 가진 짧은 함수로 분리하고, 인수를 모두 명시하여 부수효과를 없애보도록 한다.</p>\n<pre><code class=\"language-js\">const find = curry((db, id) => {\n  const obj = db.find(id)\n  if (obj === null) {\n    throw new Error(\"객체를 찾을 수 없습니다.\")\n  }\n  return obj\n})\n</code></pre>\n<p>db를 인수로 받음으로써 부수효과를 줄인다. 또한 예외를 내는 별도의 null 체크 분기문이 있어 일관된 반환값을 보장하도록 하여 전체 함수 결과를 예측 가능한 방향으로 유도한다.</p>\n<pre><code class=\"language-js\">const csv = student =>\n  `${student.ssn}, ${student.firstname}, ${student.lastname}`\n\nconst append = curry((selector, info) => {\n  document.querySelector(selector).innerHTML = info\n})\n</code></pre>\n<p><strong>HTML 객체와의 상호 작용을 자체 함수로 빼내어 불순한 로직을 순수함수에서 제거했다.</strong></p>\n<h2>3. 참조 투명성</h2>\n<p>참조 투명성이란 순수함수를 정의하는 좀 더 공식적인 방법이며, 순수성이란 함수의 인수와 결과값 사이의 순수한 매핑 관계를 의미한다. 즉 어떠한 함수가 동일한 입력을 받았을 때, 동일한 결과를 낸다면 참조 투명한 함수라고 한다.</p>\n<p>위에서 보았단 <code>increment</code>함수는 참조 투명하지 않다. 외부 변수에 접근하여 종속된 반환값을 내기 때문이다. 이를 참조 투명한 함수로 변경해주려면 외부 변수를 제거하고 함수 서명에 정규 매개변수로 명시해야한다.</p>\n<pre><code class=\"language-js\">const increment = counter => counter + 1\n</code></pre>\n<p>항상 동일한 입력값에 일관된 결과를 내기 때문에 테스트 하기도 쉽고 전체 로직을 파악하는데 용이하다.</p>\n<p>함수 인수를 전부 명확하게 정의하면 대부분의 경우 부수효과를 예방할 수 있지만, 객체를 레퍼런스로 넘길 때 실수로 객체에 변이를 일으키지 않도록 주의해야 한다. (객체는 참조형 값으로 인수로 넘기더라도 새롭게 정의되지 않는다.)</p>\n<h2>4. 불변성</h2>\n<p>불변 데이터는 한번 생성된 후 절대 바뀌지 않는다. 문자열, 숫자 등 기본형은 불변이지만, 배열 등의 객체는 불변이 아니다. 함수 인수로 전달해도 내용이 변경되어 부수효과가 발생할 수 있다.\n아래는 정렬 함수를 이용한 예시이다.</p>\n<pre><code class=\"language-js\">const arr = [1, 2, 3, 4, 5]\nconst sorted = arr => arr.sort((a, b) => b - a)\nconsole.log(arr)\n//arr = [5,4,3,2,1]\n</code></pre>\n<h1>함수형 프로그래밍의 좋은 점</h1>\n<ol>\n<li>간단한 함수들로 작업을 분해한다.</li>\n<li>흐름 체인으로 데이터를 처리한다.</li>\n<li>리액티브 패러다임을 실현하여 이벤트 중심 코드의 복잡성을 줄인다.</li>\n</ol>\n<h2>1. 간단한 함수들로 작업을 분해한다.</h2>\n<p>FP는 고수준에서 보면 사실 분해와 합성의 상호작용이라고 할 수 있다. 함수형 사고는 어떤 작업을 논리적 하위작업으로 분할하는 행위부터 시작된다. 나뉘어진 하위 작업을 더 단순한 순수함수로 분해해서 독립적인 작업 단위로 나타낼 수도 있다.</p>\n<p><code>run</code>이라는 함수는 합성이라는 기법을 구현한 함수로, 두 함수를 합성하면 첫 번쨰 함수의 결과값을 다음 함수에 밀어넣는 새로운 함수가 탄생한다. 첫 번째 함수의 반환값과 다음 함수의 인수 간에 느슨하고 형식 안전한 관계가 맺어진다. 두 함수를 섞어 쓰기 위해서는 당연히 인수 개수와 형식이 서로 맞아야한다.</p>\n<p><code>run</code>과 같은 함수 합성은 고수준의 추상화를 통해서 자세한 내막을 밝히지 않아도 코드가 수행하는 전 단계를 일목요연하게 나타낸다.</p>\n<h2>2. 흐름 체인으로 데이터를 처리한다.</h2>\n<p>부드럽게 흘러가는 모듈적인 코드를 작성하는 방법이 합성만 있는 것이 아니다. 체이닝을 통해서도 가능하다. 체인은 같은 객체를 반환하는 순차적인 함수 호출이다.</p>\n<p>복수 과목을 수강한 학생들의 평균 점수를 작성하는 프로그램을 통해서 체이닝의 장점을 알아보도록 하겠다.</p>\n<pre><code class=\"language-js\">//명령형\nconst enrollment = [\n  { enrolled: 2, grade: 100 },\n  { enrolled: 2, grade: 80 },\n  { enrolled: 1, grade: 89 },\n]\n\nlet totalGrade = 0\nlet totalStudentsCnt = 0\n\nfor (let i = 0; i &#x3C; enrollment.length; i++) {\n  const student = enrollment[i]\n  if (studment.enrolled > 1) {\n    totalGrade += grade\n    totalStudentsCnt += 1\n  }\n}\n\nconst average = totalGrade / totalStudentsCnt\n</code></pre>\n<pre><code class=\"language-js\">_.chain(enrollment)\n  .filter(student => student.enrolled > 1)\n  .pluck(\"grade\")\n  .average()\n  .value()\n</code></pre>\n<p>고수준 추상화를 통해서 함수가 어떠한 행동을 하는지 한눈에 파악할 수 있다.\n또한 함수 체인은 필요한 시점까지 실행을 미루는 느긋한 평가(lazy evaluation)을 수행한다. 다른 데에선 쓸 일이 없는 코드를 전부 실행하지 않아도 되니 CPU 부하가 줄어들어 성능이 좋아진다.</p>\n<h2>3.리액티브 패러다임을 실현하여 이벤트 중심 코드의 복잡성을 줄인다.</h2>\n<p>리액티브 프로그래밍은 서버는 물론 클라이언트 측에서 매일 씨름하는 비동기 코드, 이벤트 중심 코드의 복잡도를 현저하게 줄이는 데 큰 도움이 된다.</p>\n<p>더 높은 수준으로 코드를 추상하여 비동기, 이벤트 기반 프로그램을 설정하느라 반복되는 판박이 코드는 아에 잊고 비즈니스 로직에만 전념할 수 있도록 해준다. 또 함수를 체인으로 묶고 합성하는 FP의 능력을 최대한 이끌어낸다.</p>\n<p><em>리액티브 프로그래밍이란: 데이터 스트림과 변경 사항 전파를 중심으로하는 비동기 프로그래밍 패러다임이다.</em></p>\n<p>아래는 학생의 SSN을 읽고 올바른지 검증하는 프로그램이다.</p>\n<pre><code class=\"language-js\">Rx.Observable.fromEvent(\n  document\n    .querySelector(\"#student-ssn\", \"keyup\")\n    .pluck(\"srcElement\", \"value\")\n    .map(ssn => ssn.replace(/^\\s*/g, \"\"))\n    .filter(ssn => ssn !== null &#x26;&#x26; ssn.length === 9)\n    .subscribe(validSsn => {\n      console.log(`올바른 ssn ${validSsn}`)\n    })\n)\n</code></pre>\n<p>리액티브 패러다임은 옵저버블이라는 아주 중요한 장치를 매개로 움직인다. 옵저버블을 이용하면 데이터 스트림을 구독해서 원하는 연산을 우아하게 합성 및 체이닝하여 처리할 수 있다.</p>","id":"a22ee1b4-e7c4-529c-8f01-51d25bd95c7c"},{"fields":{"slug":"/programming/상속과 조합/"},"excerpt":"상속의 정의 조합의 정의 상속의 장단점 조합의 장단점 그래서 언제 상속을, 언제 조합을 사용하면 좋을까?","frontmatter":{"date":"2022-10-09T00:00:00.000Z","description":"언제 상속을, 언제 조합을 사용하면 좋을까","title":"상속과 조합"},"html":"<h1>상속의 정의</h1>\n<h1>조합의 정의</h1>\n<h1>상속의 장단점</h1>\n<h1>조합의 장단점</h1>\n<h1>그래서 언제 상속을, 언제 조합을 사용하면 좋을까?</h1>","id":"34ec3b75-65ac-5d44-a420-d82d79859b6d"},{"fields":{"slug":"/알고리즘/섬연결하기/"},"excerpt":"문제 링크 해결 전략 최소의 비용으로 모든 섬이 통행 가능하도록 만들 때, 필요한 최소 비용을 구하라는 문제이다.\n모든 섬이 통행 가능하도록 이란 의미는 신장 트리를 만족해야 하고, 최소 비용을 구해야 하기 때문에 최소 신장 트리 구조를 만족해야 한다. 크루스칼 알고리즘은 최소 신장트리를 만족하면서 최소 거리를 구할 수 있는 알고리즘이다. 정답 코드","frontmatter":{"date":"2022-10-09T00:00:00.000Z","description":"크루스칼 알고리즘","title":"섬 연결하기"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42861\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>최소의 비용으로 모든 섬이 통행 가능하도록 만들 때, 필요한 최소 비용을 구하라는 문제이다.\n모든 섬이 통행 가능하도록 이란 의미는 신장 트리를 만족해야 하고, 최소 비용을 구해야 하기 때문에 최소 신장 트리 구조를 만족해야 한다. 크루스칼 알고리즘은 최소 신장트리를 만족하면서 최소 거리를 구할 수 있는 알고리즘이다.</p>\n<h1>정답 코드</h1>\n<pre><code class=\"language-js\">function solution(n, costs) {\n  costs.sort((a, b) => a[2] - b[2])\n\n  const parent = Array(n + 1)\n    .fill()\n    .map((_, i) => i)\n\n  const findParent = (parent, x) => {\n    if (parent[x] !== x) {\n      parent[x] = findParent(parent, parent[x])\n    }\n    return parent[x]\n  }\n\n  const union = (parent, a, b) => {\n    a = findParent(parent, a)\n    b = findParent(parent, b)\n    if (a === b) return true\n    //사이클이 발생한다면 수행하지 않음.\n    if (a > b) {\n      parent[a] = b\n    } else {\n      parent[b] = a\n    }\n    return false\n  }\n\n  let sum = 0\n  costs.forEach(([st, end, cost]) => {\n    const cycle = union(parent, st, end)\n    if (!cycle) sum += cost\n  })\n  return sum\n}\n</code></pre>","id":"d5c0ab99-0888-5a21-a96e-d7923eb663bb"},{"fields":{"slug":"/programming/git/"},"excerpt":"merge 병합은 두 브랜치의 합집합을 구하는 것이다. 병합에는 3가지 종류가 있다. merge commit 서로 다른 변경된 부분이 있을 경우, 새롭게 저장한다. fast-forward 합친 결과물이 한 커밋의 결과물과 동일할 때 새로운 상태를 만들어 줄 필요없이 상태를 바꿔주면 된다. conflict 동일한 부분이 다를 경우 충돌이 일어나게 된다. pull request 정중하게 브랜치 병합을 요청하는 것이다. 풀 리퀘 제목: 동료 개발자…","frontmatter":{"date":"2022-10-06T00:00:00.000Z","description":"merge, pull request, fork, rebase..","title":"git 사용법"},"html":"<h1>merge</h1>\n<p>병합은 두 브랜치의 합집합을 구하는 것이다. 병합에는 3가지 종류가 있다.</p>\n<ol>\n<li>merge commit\n<ul>\n<li>서로 다른 변경된 부분이 있을 경우, 새롭게 저장한다.</li>\n</ul>\n</li>\n<li>fast-forward\n<ul>\n<li>합친 결과물이 한 커밋의 결과물과 동일할 때 새로운 상태를 만들어 줄 필요없이 상태를 바꿔주면 된다.</li>\n</ul>\n</li>\n<li>conflict\n<ul>\n<li>동일한 부분이 다를 경우 충돌이 일어나게 된다.</li>\n</ul>\n</li>\n</ol>\n<h1>pull request</h1>\n<p>정중하게 브랜치 병합을 요청하는 것이다.</p>\n<ul>\n<li>풀 리퀘 제목: 동료 개발자가 한 눈에 이해하기 쉬운 제목을 적어둔다.</li>\n<li>풀 리퀘 내용: 코드를 이해하는데 도움이 되는 설명을 적어준다. 스크린샷 혹은 테스트 방법</li>\n<li>reviewers: 콕 찝어서 풀 리퀘 검토 요청, 같은 팀원 혹은 해당 기능과 연관된 동료 선택</li>\n</ul>\n<h1>fork</h1>\n<p>타인의 원본저장소를 내 계정의 원격저장소로 복사해오는 명령어이다.\n브랜치를 포함한 원본저장소의 모든 커밋 이력을 통째로 복사한다.</p>\n<h3>오픈 소스 기여 방식</h3>\n<p>원본 저장소에는 지정된 collaborators만 코드를 푸쉬할 수 있다. 오픈소스 프로젝트에서 만일 collaborators가 너무 많아진다면 저장소를 관리하는데 어려워질 것이다. 하지만 동시에 많은 개발자들에게 의견을 받고 오픈소스를 개선하고 싶은 니즈가 있다. 이럴 때 개발자는 fork를 해서 원본 저장소를 복사하고, 이곳에 커밋을 올린 다음에 원본 저장소의 소유자에게 풀 리퀘를 요청하면 원본 저장소의 소유자는 개발자의 병합 요청을 검토해서 원본 저장소에 반영한다.</p>\n<h3>원본 저장소에 풀 리퀘 보내기</h3>\n<p>new pull request 버튼을 누르고 head repository, base repository가 뜬다면 성공이다.\n풀 리퀘에 대한 설명을 적고 요청을 보낸다. 만일 원본저장소에 컨트리뷰션 가이드가 있다면 읽고 준수하도록 한다. 보통 README.md에 존재한다.</p>\n<p>풀 리퀘를 승인하는 방법은, 좌측 카테고리에 fork 탭을 클릭하고 pull requests 탭을 클릭하면 요청된 풀 리퀘들을 확인할 수 있다. 댓글만 달고 싶다면 comment를, 댓글을 달고 코드가 좋아보여 바로 병합해도 되면 approve를, 수정을 요청하고 싶으면 request changes를 선택한다.</p>\n<h1>add remote</h1>\n<p>내 원격 저장소에서 원본 저장소의 히스토리도 같이 보고싶다면, add remote를 해주면 된다. 원격 이름에는 upstream을 넣어주고 원본 저장소 주소를 복사해서 넣어주면 된다. upstream은 원본 저장소를 지칭하는 관용적 닉네임이다.</p>\n<p><code>fetch</code>를 하게 되면 원본 저장소에 있는 커밋 히스토리를 받아올 수 있다. pull과는 다른 점은 커밋 이력만 받아오기 때문에 내 코드에는 아무 영향이 없다.</p>\n<h1>rebase</h1>","id":"6a5ee1a7-b8a6-5d22-8968-6a91a6171688"},{"fields":{"slug":"/알고리즘/여행경로/"},"excerpt":"문제 링크 해결 전략 우리는 주어진 항공권을 모두 이용해야한다. 즉 항공권을 모두 사용하는 케이스를 탐색해야한다.\n만일 가능한 경로가 2개 이상 있을 때, 알파벳 순서가 앞서는 경로를 리턴해야 하므로 BFS로 탐색하고 만족하는 값을 찾으면 탐색을 중지하도록 하겠다. 탐색하는 방법은 간단하다. 티켓 중에서 시작점이 마지막에 방문한 도시와 일치하는 티켓들을 찾고 알파벳 순서로 정렬 후 방문한다. 이 과정을 모든 티켓을 사용(방문)할 떄 까지 반복…","frontmatter":{"date":"2022-10-06T00:00:00.000Z","description":"DFS/BFS","title":"여행 경로"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/43164\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>우리는 주어진 항공권을 모두 이용해야한다. 즉 항공권을 모두 사용하는 케이스를 탐색해야한다.\n만일 가능한 경로가 2개 이상 있을 때, 알파벳 순서가 앞서는 경로를 리턴해야 하므로 BFS로 탐색하고 만족하는 값을 찾으면 탐색을 중지하도록 하겠다.</p>\n<p>탐색하는 방법은 간단하다. 티켓 중에서 시작점이 마지막에 방문한 도시와 일치하는 티켓들을 찾고 알파벳 순서로 정렬 후 방문한다. 이 과정을 모든 티켓을 사용(방문)할 떄 까지 반복한다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-javascript\">class Queue {\n  constructor() {\n    this.front = 0\n    this.rear = 0\n    this.queue = []\n  }\n\n  enqueue(data) {\n    this.queue[this.rear++] = data\n  }\n\n  dequeue() {\n    const value = this.queue[this.front]\n    delete this.queue[this.front]\n    this.front++\n    return value\n  }\n\n  size() {\n    return this.rear - this.front\n  }\n}\n\n//시작점이 마지막에 방문한 도시인 티켓들을 찾고, 알파벳 순서로 정렬하는 코드\nconst findMatchTickets = (start, tickets, visited) => {\n  const result = []\n  for (let i = 0; i &#x3C; tickets.length; i++) {\n    if (!visited[i] &#x26;&#x26; tickets[i][0] === start) {\n      result.push({ i, end: tickets[i][1] })\n    }\n  }\n  result.sort((a, b) => (a.end > b.end) - (a.end &#x3C; b.end))\n  return result\n}\n\nfunction solution(tickets) {\n  const visited = Array(tickets.length).fill(false)\n\n  const queue = new Queue()\n  queue.enqueue({ visited, path: [\"ICN\"] })\n\n  while (queue.size() > 0) {\n    const { visited, path } = queue.dequeue()\n    if (visited.every(v => v)) return path\n\n    const lastVisited = path[path.length - 1]\n    const matchedTickets = findMatchTickets(lastVisited, tickets, visited)\n\n    matchedTickets.forEach(({ i, end }) => {\n      const newVistied = [...visited]\n      newVistied[i] = true\n      queue.enqueue({ visited: newVistied, path: [...path, end] })\n    })\n  }\n}\n</code></pre>\n<h1>추가</h1>\n<p>BFS가 아닌, DFS를 이용해도 문제를 해결할 수 있다. 다만 우리는 알파벳 순서가 앞서는 경로를 리턴해야 하므로 BFS와 동일하게 알파벳 순서가 앞서는 경로를 먼저 넣어주고, 만일 모든 티켓을 방문했다면 즉 정답을 찾았다면 DFS 탐색을 중지한다.</p>\n<pre><code class=\"language-javascript\">const findMatchTickets = (start, tickets) => {\n  const result = []\n  for (let i = 0; i &#x3C; tickets.length; i++) {\n    if (tickets[i][0] === start) {\n      result.push({ i, end: tickets[i][1] })\n    }\n  }\n  result.sort((a, b) => (a.end > b.end) - (a.end &#x3C; b.end))\n  return result\n}\n\nfunction solution(tickets) {\n  let answer = null\n\n  function dfs(leftTickets, lastVisited, path) {\n    if (answer) return\n    if (leftTickets.length === 0) {\n      answer = path\n    }\n\n    findMatchTickets(lastVisited, leftTickets).forEach(({ i, end }) => {\n      dfs(\n        leftTickets.filter((_, index) => index !== i),\n        end,\n        [...path, end]\n      )\n    })\n  }\n  dfs(tickets, \"ICN\", [\"ICN\"])\n  return answer\n}\n</code></pre>","id":"777d548c-27fe-5a4a-af3b-62269fca7d6b"},{"fields":{"slug":"/알고리즘/이중우선순위큐/"},"excerpt":"문제 링크 해결 전략 이 문제의 operation은 최대 1,000,000이다. 따라서 최댓값, 최솟값을 제거해주기 위해서 굳이 힙을 사용하지 않고도 정렬을 사용해도 좋다. sort 메소드를 사용한다면 O(NlogN)으로 문제를 해결할 수 있다.\nshift 메소드의 경우 O(N)의 시간이 소모되므로, 매번 정렬을 수행하는 것보다 shift 메소드를 사용하는 것이 더 빠르다. 따라서 작성한 알고리즘은 아래와 같다. 전체 코드 추가 문제의 이름이…","frontmatter":{"date":"2022-10-06T00:00:00.000Z","description":"힙, 정렬","title":"이중우선순위큐"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42628\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>이 문제의 operation은 최대 1,000,000이다. 따라서 최댓값, 최솟값을 제거해주기 위해서 굳이 힙을 사용하지 않고도 정렬을 사용해도 좋다. sort 메소드를 사용한다면 O(NlogN)으로 문제를 해결할 수 있다.\nshift 메소드의 경우 O(N)의 시간이 소모되므로, 매번 정렬을 수행하는 것보다 shift 메소드를 사용하는 것이 더 빠르다. 따라서 작성한 알고리즘은 아래와 같다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-javascript\">function solution(operations) {\n  const arr = []\n  operations.forEach(v => {\n    const [command, strNum] = v.split(\" \")\n    const num = Number(strNum)\n    if (command === \"I\") {\n      arr.push(num)\n      arr.sort((a, b) => a - b)\n    }\n\n    if (command === \"D\") {\n      if (num === -1) {\n        arr.shift()\n      } else {\n        arr.pop()\n      }\n    }\n  })\n\n  return arr.length === 0 ? [0, 0] : [arr[arr.length - 1], arr[0]]\n}\n</code></pre>\n<h1>추가</h1>\n<p>문제의 이름이 이중우선순위큐인 만큼 한번 힙을 이용해서 문제를 해결해보도록 하겠다.</p>\n<p>새롭게 최대힙과 최소힙 기능을 하는 이중우선순위큐를 정의하는 것은 복잡하기에 최대힙, 최소힙 2개의 자료구조를 이용해서 문제를 해결하도록 한다.</p>\n<p>최대힙을 정의하고, 최소힙은 최대힙을 이용해서 구현한다. 최소힙의 경우 요소를 넣을 때 음의 형태로 변환해서 넣어준다.</p>\n<p>우리는 2개의 힙을 사용하지만, 하나의 배열로 생각할 수 있다. 그 이유는 최대힙은 최댓값을 배출하고, 최소힙은 최솟값을 배출하기 때문이다. 오름차순으로 배열이 정렬되어있다고 가정하면, 최대힙은 오른쪽에서부터 하나씩 제거되고 최소힙은 왼쪽에서부터 하나씩 제거해나간다고 할 수 있다. 따라서 우리가 고려해주어야 하는 시점은, 최대힙에서 배출하는 요소가, 최소힙에서 배출하는 요소와 동일할 때이다. 즉 하나의 배열이라고 생각했을 때 배열의 원소가 1개만 있을 때이다. 이 때의 경우 2개의 힙을 빈 배열로 초기화 시켜주면 된다. 초기화 시켜주지 않는다면 힙에 원소가 남게되고 이는 다른 결과를 초래할 수 있다. 배열의 원소가 1개 남았는지 파악하기 위해서 <code>heapCnt</code>라는 변수를 사용한다.</p>\n<p>구현한 코드는 아래와 같다.</p>\n<pre><code class=\"language-javascript\">class MaxHeap {\n  constructor() {\n    this.heap = []\n  }\n\n  swap(aIndex, bIndex) {\n    ;[this.heap[aIndex], this.heap[bIndex]] = [\n      this.heap[bIndex],\n      this.heap[aIndex],\n    ]\n  }\n\n  push(value) {\n    this.heap.push(value)\n    let currentIndex = this.heap.length - 1\n    let parentIndex = Math.floor((currentIndex - 1) / 2)\n\n    while (parentIndex >= 0 &#x26;&#x26; this.heap[parentIndex] &#x3C; value) {\n      this.swap(parentIndex, currentIndex)\n      currentIndex = parentIndex\n      parentIndex = Math.floor((currentIndex - 1) / 2)\n    }\n  }\n\n  pop() {\n    if (this.heap.length === 0) return undefined\n    if (this.heap.length === 1) return this.heap.pop()\n\n    const root = this.heap[0]\n    const end = this.heap.pop()\n    this.heap[0] = end\n\n    let currentIndex = 0\n    let leftIndex = 1\n    let rightIndex = 2\n\n    while (\n      this.heap[currentIndex] &#x3C; this.heap[leftIndex] ||\n      this.heap[currentIndex] &#x3C; this.heap[rightIndex]\n    ) {\n      if (this.heap[leftIndex] &#x3C; this.heap[rightIndex]) {\n        this.swap(currentIndex, rightIndex)\n        currentIndex = rightIndex\n      } else {\n        this.swap(currentIndex, leftIndex)\n        currentIndex = leftIndex\n      }\n      leftIndex = currentIndex * 2 + 1\n      rightIndex = currentIndex * 2 + 2\n    }\n    return root\n  }\n}\n\nfunction solution(operations) {\n  let heapCnt = 0\n  const maxHeap = new MaxHeap()\n  const minHeap = new MaxHeap()\n\n  operations.forEach(v => {\n    const [command, number] = v.split(\" \")\n    if (command === \"I\") {\n      maxHeap.push(Number(number))\n      minHeap.push(-Number(number))\n      heapCnt++\n    }\n\n    if (command === \"D\") {\n      if (heapCnt === 0) return\n      heapCnt--\n      if (Number(number) === -1) {\n        minHeap.pop()\n      } else {\n        maxHeap.pop()\n      }\n      if (heapCnt === 0) {\n        minHeap.heap = []\n        maxHeap.heap = []\n      }\n    }\n  })\n\n  if (heapCnt === 0) return [0, 0]\n  return [maxHeap.pop(), -minHeap.pop()]\n}\n</code></pre>","id":"72f660a2-4068-5add-8e8e-515c5ff3924a"},{"fields":{"slug":"/알고리즘/숫자게임/"},"excerpt":"문제 링크 해결 전략 우리는 B의 순서를 조정할 수 있다. 따라서 A의 순서를 바꿔도 상관없다. 순서가 변경된 A에 맞춰서 B의 순서를 변경하면 되기 때문이다. 우리는 근소한 차이로 이길 때, 최대한 많이 이길 수 있다. 예시로 1을 이기는데 9를 낼 필요는 없다는 것이다. 내가 2를 보유하고 있다면 2를 내는 것이 이득이다. 나중에 7과 같은 큰 수를 만나면 그 때 9를 내야한다. 위의 두 생각을 바탕으로 나는 A와 B를 내림차순으로 정렬하…","frontmatter":{"date":"2022-10-05T00:00:00.000Z","description":"그리디","title":"숫자 게임"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/12987\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<ol>\n<li>\n<p>우리는 B의 순서를 조정할 수 있다. 따라서 A의 순서를 바꿔도 상관없다. 순서가 변경된 A에 맞춰서 B의 순서를 변경하면 되기 때문이다.</p>\n</li>\n<li>\n<p>우리는 근소한 차이로 이길 때, 최대한 많이 이길 수 있다. 예시로 1을 이기는데 9를 낼 필요는 없다는 것이다. 내가 2를 보유하고 있다면 2를 내는 것이 이득이다. 나중에 7과 같은 큰 수를 만나면 그 때 9를 내야한다.</p>\n</li>\n</ol>\n<p>위의 두 생각을 바탕으로 나는 A와 B를 내림차순으로 정렬하였다. 내림차순으로 정렬한 이유는 순서대로 비교해보았을 때, 어떤 순서에서 B 요소가 A 요소보다 크다면 해당 순서의 B 요소는 다음 순서로 등장하는 A의 요소들 전부를 이길 수 있기 때문이다. 즉 가장 근소한 차이로 이길 수 있는 순서를 알 수 있다는 말이다.</p>\n<p>나의 초기 알고리즘은 배열을 순회하면서 동일한 순서에 대해서 A 요소와 B 요소의 크기를 비교하는 것이였다. 하지만 이 알고리즘의 경우 이길 수 있는 개수를 누락시킨 다는 문제가 있었다. 예시는 아래와 같다.</p>\n<p><code>A: [5,3,1]</code>, <code>B:[4,2,0]</code>의 경우 내가 초기 작성한 알고리즘은 0이라는 정답을 도출한다. 하지만 실제 정답은 2이다. [A,B] 형태로 표현할 때, [3,4], [1,2] 2개의 케이스가 존재하기 때문이다.</p>\n<p>누락되는 문제를 해결하기 위해서는 비교하는 방식을 변경해주면 된다. 동일한 순서에 대해서만 비교해주는 것이 아니라, 만일 A가 B보다 클 경우 B의 순서는 고정시켜 놓고 A의 순서만 움직인다. 만일 B가 A보다 클 경우에는 A와 B 순서 둘다 움직여주면 된다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-javascript\">function solution(A, B) {\n  A.sort((a, b) => b - a)\n  B.sort((a, b) => b - a)\n\n  let answer = 0\n  const len = A.length\n\n  for (let i = 0, j = 0; i &#x3C; len; i++) {\n    if (A[i] &#x3C; B[j]) {\n      j++\n      answer++\n    }\n  }\n  return answer\n}\n</code></pre>\n<h1>추가</h1>\n<p>추가로 내림차순으로 정렬을 하지 않고, 최대힙을 이용하는 방법도 있다.</p>\n<pre><code class=\"language-javascript\">class MaxHeap {\n  constructor() {\n    this.heap = []\n  }\n\n  swap(aIndex, bIndex) {\n    ;[this.heap[aIndex], this.heap[bIndex]] = [\n      this.heap[bIndex],\n      this.heap[aIndex],\n    ]\n  }\n\n  push(value) {\n    this.heap.push(value)\n    let currentIndex = this.heap.length - 1\n    let parentIndex = Math.floor((currentIndex - 1) / 2)\n\n    while (parentIndex >= 0 &#x26;&#x26; this.heap[parentIndex] &#x3C; value) {\n      this.swap(parentIndex, currentIndex)\n      currentIndex = parentIndex\n      parentIndex = Math.floor((currentIndex - 1) / 2)\n    }\n  }\n\n  pop() {\n    if (this.heap.length === 0) return undefined\n    if (this.heap.length === 1) return this.heap.pop()\n\n    const root = this.heap[0]\n    const end = this.heap.pop()\n    this.heap[0] = end\n\n    let currentIndex = 0\n    let leftIndex = 1\n    let rightIndex = 2\n\n    while (\n      this.heap[currentIndex] &#x3C; this.heap[leftIndex] ||\n      this.heap[currentIndex] &#x3C; this.heap[rightIndex]\n    ) {\n      if (this.heap[leftIndex] &#x3C; this.heap[rightIndex]) {\n        this.swap(currentIndex, rightIndex)\n        currentIndex = rightIndex\n      } else {\n        this.swap(currentIndex, leftIndex)\n        currentIndex = leftIndex\n      }\n      leftIndex = currentIndex * 2 + 1\n      rightIndex = currentIndex * 2 + 2\n    }\n    return root\n  }\n}\n\nfunction solution(A, B) {\n  const heap_A = new MaxHeap()\n  const heap_B = new MaxHeap()\n  const len = A.length\n\n  for (let i = 0; i &#x3C; len; i++) {\n    heap_A.push(A[i])\n    heap_B.push(B[i])\n  }\n  let answer = 0\n\n  let maxA = heap_A.pop()\n  let maxB = heap_B.pop()\n\n  while (maxA) {\n    if (maxA &#x3C; maxB) {\n      answer++\n      maxA = heap_A.pop()\n      maxB = heap_B.pop()\n    } else {\n      maxA = heap_A.pop()\n    }\n  }\n  return answer\n}\n</code></pre>","id":"7f14a095-e1f6-5567-bd76-936d59b7781f"},{"fields":{"slug":"/알고리즘/야근지수/"},"excerpt":"문제 링크 해결 전략 초기에는 완전 탐색으로 접근해보았다. 하지만 n을 works에 분배하는 과정에서 무조건 시간 초과가 발생할 수 밖에 없다. 따라서 문제의 특성을 이용한 다른 접근 방법이 필요하다.\n우리는 배열 내 요소의 제곱의 합의 최솟값을 구해야한다. 제곱의 그래프는 우측으로 이동할수록 급격히 증가하는 그래프 형태를 띄게 된다. 반대로 말하자면 좌측으로 이동할수록 급격히 감소한다는 의미이다. 우리는 최솟값을 구해야 하므로 감소하는 폭을…","frontmatter":{"date":"2022-10-04T00:00:00.000Z","description":"최대힙","title":"야근지수"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/12927\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>초기에는 완전 탐색으로 접근해보았다. 하지만 n을 works에 분배하는 과정에서 무조건 시간 초과가 발생할 수 밖에 없다.</p>\n<p>따라서 문제의 특성을 이용한 다른 접근 방법이 필요하다.\n우리는 배열 내 요소의 제곱의 합의 최솟값을 구해야한다. 제곱의 그래프는 우측으로 이동할수록 급격히 증가하는 그래프 형태를 띄게 된다.</p>\n<p>반대로 말하자면 좌측으로 이동할수록 급격히 감소한다는 의미이다. 우리는 최솟값을 구해야 하므로 감소하는 폭을 최대한 크게 만들어야 한다. 감소하는 폭을 최대한 크게 만들기 위해서는 배열 내에서 가장 큰 요소를 뽑아서 줄여주는 전략을 택하면 된다. 가장 큰 요소를 어떻게 줄여주느냐가 시간 복잡도에 큰 영향을 미친다.</p>\n<p>내가 작성한 초기 알고리즘은 최댓값을 구하고, 최댓값보다 바로 작은 숫자만큼 빼주는 방식이였다. 하지만 이렇게 작성할 경우 배열 내 모든 원소가 최댓값과 같은 경우를 고려해줘야 하기 때문에 알고리즘이 복잡해진다.</p>\n<p>최댓값을 구하고 최댓값과 n을 1씩 빼는 알고리즘을 사용한다면 간결하게 정답을 구할 수 있다. 하지만 n이 1,000,000이고 works 배열의 길이는 20,000이기 때문에 배열을 순회하면서 최댓값을 찾는 방식을 사용한다면 1,000,000 * 20,000 으로 시간 복잡도를 초과하게 된다. 최댓값을 구할 때 우리는 최대힙을 사용한다면 log(20,000) 시간으로 최댓값을 구할 수 있고 시간 복잡도를 초과하지 않게 된다.</p>\n<h1>교훈</h1>\n<p>시간 복잡도를 기반으로 방법을 생각해내는 것도 좋지만, 문제의 특성에 따라 방법을 생각하고 시간 복잡도를 줄이는 방안도 생각해봐야 한다. (이진탐색, 우선순위 큐 등)</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-javascript\">class MaxHeap {\n  constructor() {\n    this.heap = []\n  }\n\n  swap(aIndex, bIndex) {\n    ;[this.heap[aIndex], this.heap[bIndex]] = [\n      this.heap[bIndex],\n      this.heap[aIndex],\n    ]\n  }\n\n  push(value) {\n    this.heap.push(value)\n    let currentIndex = this.heap.length - 1\n    let parentIndex = Math.floor((currentIndex - 1) / 2)\n\n    while (parentIndex >= 0 &#x26;&#x26; this.heap[parentIndex] &#x3C; value) {\n      this.swap(parentIndex, currentIndex)\n      currentIndex = parentIndex\n      parentIndex = Math.floor((currentIndex - 1) / 2)\n    }\n  }\n\n  pop() {\n    if (this.heap.length === 0) return undefined\n    if (this.heap.length === 1) return this.heap.pop()\n\n    const root = this.heap[0]\n    const end = this.heap.pop()\n    this.heap[0] = end\n\n    let currentIndex = 0\n    let leftIndex = 1\n    let rightIndex = 2\n\n    while (\n      this.heap[currentIndex] &#x3C; this.heap[leftIndex] ||\n      this.heap[currentIndex] &#x3C; this.heap[rightIndex]\n    ) {\n      if (this.heap[leftIndex] &#x3C; this.heap[rightIndex]) {\n        this.swap(currentIndex, rightIndex)\n        currentIndex = rightIndex\n      } else {\n        this.swap(currentIndex, leftIndex)\n        currentIndex = leftIndex\n      }\n      leftIndex = currentIndex * 2 + 1\n      rightIndex = currentIndex * 2 + 2\n    }\n    return root\n  }\n}\n\nfunction solution(n, works) {\n  const heap = new MaxHeap()\n  works.forEach(v => heap.push(v))\n\n  while (n > 0) {\n    const max = heap.pop()\n    n -= 1\n    if (max === 0) return 0\n    //만일 최댓값이 0이라면 해야할 일이 없다는 뜻으로 0을 리턴하고 함수를 종료한다.\n    heap.push(max - 1)\n  }\n  return heap.heap.reduce((acc, cur) => acc + cur * cur, 0)\n}\n</code></pre>\n<h1>추가</h1>\n<p>재귀와 sort 메소드를 사용하는 방법을 생각해보았는데, sort 메소드의 경우 시간 복잡도가 NlogN이라서 효율성 테스트를 통과할 수 없었다. 코드는 아래와 같다.</p>\n<pre><code class=\"language-javascript\">function solution(n, works) {\n  function recursive(n, works) {\n    if (n === 0) return works.reduce((acc, cur) => acc + cur * cur, 0)\n\n    works.sort((a, b) => b - a)\n    if (works[0] === 0) return 0\n\n    works[0] -= 1\n    return recursive(n - 1, works)\n  }\n  return recursive(n, works)\n}\n</code></pre>","id":"e9ac13ba-e8ff-5c5d-ba3e-157a2da38f9a"},{"fields":{"slug":"/알고리즘/스티커모으기/"},"excerpt":"문제 링크 다이나믹 프로그래밍인 이유 문제의 해결 전략이 다이나믹 프로그래밍으로 도출되어야 하는 이유는 2가지이다. 시간 복잡도를 줄여야 한다. 작은 문제의 해답이 그것을 포함하는 큰 문제에서도 동일하다. 1. 시간 복잡도 스티커의 최대 길이는 100,000개이다. 만일 완전 탐색으로 어떤 스티커를 뜯었는지, 안뜯었는지 고려하여 구한다면 시간 복잡도는 최대 O(2^50000)으로 불가능하다. 2. 작은 문제의 해답이.. 스티커 전체 배열이 […","frontmatter":{"date":"2022-09-30T00:00:00.000Z","description":"다이나믹 프로그래밍","title":"스티커 모으기"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/12971\">문제 링크</a></p>\n<h1>다이나믹 프로그래밍인 이유</h1>\n<p>문제의 해결 전략이 다이나믹 프로그래밍으로 도출되어야 하는 이유는 2가지이다.</p>\n<ol>\n<li>시간 복잡도를 줄여야 한다.</li>\n<li>작은 문제의 해답이 그것을 포함하는 큰 문제에서도 동일하다.</li>\n</ol>\n<h3>1. 시간 복잡도</h3>\n<p>스티커의 최대 길이는 100,000개이다. 만일 완전 탐색으로 어떤 스티커를 뜯었는지, 안뜯었는지 고려하여 구한다면 시간 복잡도는 최대 O(2^50000)으로 불가능하다.</p>\n<h3>2. 작은 문제의 해답이..</h3>\n<p>스티커 전체 배열이 <code>[1,3,5,6,4]</code>라고 가정해보자. 부분 배열 <code>[1,3,5]</code>가 있다고 하였을 때, 뽑을 수 있는 가장 최댓값인 5이다. 부분 배열 <code>[1,3,5,6]</code>에서 <code>[1,3,5]</code>의 최댓값은 5로 만족한다. 하지만 5를 뽑는 경우 6을 뽑을 수 없다. 따라서 이 부분 배열의 경우 3과 6을 뽑아야 최댓값이다. 3의 경우는 부분 배열 <code>[1,3]</code>의 최댓값이라고 할 수 있다. 현재에 해당되는 스티커를 뗀다면, 2번 째 전 부분 배열의 최댓값과 현재의 스티커 점수를 더한 것이고 떼지 않는다면 1번 째 전 부분 배열의 최댓값과 동일하다.</p>\n<h1>해결 전략</h1>\n<p>다이나믹 프로그래밍이라는 사실도 알아냈고 규칙도 찾았으니 점화식을 세워보도록 한다.</p>\n<pre><code>d[i] = max(d[i-2]+i번째 스티커점수, d[i-1])\n(단, d[i]는 부분 배열 i까지의 최댓값을 의미한다.)\n</code></pre>\n<p>하지만 위 점화식은 맨 처음 스티커를 떼는 경우를 만족시키지 못한다. 맨 처음 스티커를 떼는 경우 맨 마지막 스티커도 제거 되어야 하기 때문이다. 따라서 맨 처음 스티커를 떼는 경우, 맨 처음 스티커를 떼지 않는 경우 2가지로 나눠서 문제를 풀어보도록 한다.</p>\n<pre><code class=\"language-javascript\">if (sticker.length &#x3C;= 2) return Math.max(...sticker)\n</code></pre>\n<p>만일 스티커의 개수가 2개 이하라면, 배열 내의 최댓값을 리턴하면 된다. 맨 처음 스티커를 떼지 않는 경우를 고려할 때 스티커 배열의 3번째 요소에 접근하기 때문에 위와 같이 처리해준다.</p>\n<pre><code class=\"language-javascript\">const len = sticker.length\nconst d = Array(len - 1).fill(0)\n\nd[0] = sticker[0]\nd[1] = d[0]\nfor (let i = 2; i &#x3C; d.length; i++) {\n  d[i] = Math.max(d[i - 2] + sticker[i], d[i - 1])\n}\n\nconst max_first = Math.max(...d)\n</code></pre>\n<p>첫 번째 스티커를 뜯어냈을 경우 코드는 위와 같다. <code>d[1] = d[0]</code>인 이유는 <code>d[1]</code>의 경우 스티커를 뜯어낼 수 없기 떄문에 <code>d[0]</code>의 값과 동일하게 넣어주어야 한다.</p>\n<pre><code class=\"language-javascript\">const d2 = Array(len - 1).fill(0)\nd2[0] = sticker[1]\nd2[1] = Math.max(d2[0], sticker[2])\n\nfor (let i = 2; i &#x3C; d.length; i++) {\n  d2[i] = Math.max(d2[i - 2] + sticker[i + 1], d2[i - 1])\n}\nconst max_second = Math.max(...d2)\n\nreturn Math.max(max_first, max_second)\n</code></pre>\n<p>첫 번째 스티커를 뜯어내지 않았을 경우 코드는 위와 같다. 첫 번째 스티커를 뜯지 않았기 때문에(제외시켰기 떄문에) 테이블은 스티커의 첫 번째 요소에서부터 시작하도록 한다. 그리고 <code>d2[1]</code>의 경우 만일 <code>sticker[2]</code>의 크기가 <code>d2[0]</code>의 크기보다 크다면, <code>sticker[2]</code>를 뜯는게 더 값이 크기 때문에 둘 중 큰 값을 가지도록 한다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-javascript\">function solution(sticker) {\n  if (sticker.length &#x3C;= 2) return Math.max(...sticker)\n\n  const len = sticker.length\n  const d = Array(len - 1).fill(0)\n\n  d[0] = sticker[0]\n  d[1] = d[0]\n  for (let i = 2; i &#x3C; d.length; i++) {\n    d[i] = Math.max(d[i - 2] + sticker[i], d[i - 1])\n  }\n  const max_first = Math.max(...d)\n\n  const d2 = Array(len - 1).fill(0)\n  d2[0] = sticker[1]\n  d2[1] = Math.max(d2[0], sticker[2])\n\n  for (let i = 2; i &#x3C; d.length; i++) {\n    d2[i] = Math.max(d2[i - 2] + sticker[i + 1], d2[i - 1])\n  }\n  const max_second = Math.max(...d2)\n\n  return Math.max(max_first, max_second)\n}\n</code></pre>","id":"e6a14e25-d9b2-5d3b-92e2-9ffc459ac905"}]}},"staticQueryHashes":["4031756233","4237942306"],"slicesMap":{}}