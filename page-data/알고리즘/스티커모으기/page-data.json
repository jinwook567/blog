{"componentChunkName":"component---src-templates-blog-post-js","path":"/알고리즘/스티커모으기/","result":{"data":{"site":{"siteMetadata":{"title":"jinwook567"}},"markdownRemark":{"id":"e6a14e25-d9b2-5d3b-92e2-9ffc459ac905","excerpt":"문제 링크 다이나믹 프로그래밍인 이유 문제의 해결 전략이 다이나믹 프로그래밍으로 도출되어야 하는 이유는 2가지이다. 시간 복잡도를 줄여야 한다. 작은 문제의 해답이 그것을 포함하는 큰 문제에서도 동일하다. 1. 시간 복잡도 스티커의 최대 길이는 100,00…","html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/12971\">문제 링크</a></p>\n<h1>다이나믹 프로그래밍인 이유</h1>\n<p>문제의 해결 전략이 다이나믹 프로그래밍으로 도출되어야 하는 이유는 2가지이다.</p>\n<ol>\n<li>시간 복잡도를 줄여야 한다.</li>\n<li>작은 문제의 해답이 그것을 포함하는 큰 문제에서도 동일하다.</li>\n</ol>\n<h3>1. 시간 복잡도</h3>\n<p>스티커의 최대 길이는 100,000개이다. 만일 완전 탐색으로 어떤 스티커를 뜯었는지, 안뜯었는지 고려하여 구한다면 시간 복잡도는 최대 O(2^50000)으로 불가능하다.</p>\n<h3>2. 작은 문제의 해답이..</h3>\n<p>스티커 전체 배열이 <code class=\"language-text\">[1,3,5,6,4]</code>라고 가정해보자. 부분 배열 <code class=\"language-text\">[1,3,5]</code>가 있다고 하였을 때, 뽑을 수 있는 가장 최댓값인 5이다. 부분 배열 <code class=\"language-text\">[1,3,5,6]</code>에서 <code class=\"language-text\">[1,3,5]</code>의 최댓값은 5로 만족한다. 하지만 5를 뽑는 경우 6을 뽑을 수 없다. 따라서 이 부분 배열의 경우 3과 6을 뽑아야 최댓값이다. 3의 경우는 부분 배열 <code class=\"language-text\">[1,3]</code>의 최댓값이라고 할 수 있다. 현재에 해당되는 스티커를 뗀다면, 2번 째 전 부분 배열의 최댓값과 현재의 스티커 점수를 더한 것이고 떼지 않는다면 1번 째 전 부분 배열의 최댓값과 동일하다.</p>\n<h1>해결 전략</h1>\n<p>다이나믹 프로그래밍이라는 사실도 알아냈고 규칙도 찾았으니 점화식을 세워보도록 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">d[i] = max(d[i-2]+i번째 스티커점수, d[i-1])\n(단, d[i]는 부분 배열 i까지의 최댓값을 의미한다.)</code></pre></div>\n<p>하지만 위 점화식은 맨 처음 스티커를 떼는 경우를 만족시키지 못한다. 맨 처음 스티커를 떼는 경우 맨 마지막 스티커도 제거 되어야 하기 때문이다. 따라서 맨 처음 스티커를 떼는 경우, 맨 처음 스티커를 떼지 않는 경우 2가지로 나눠서 문제를 풀어보도록 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if (sticker.length &lt;= 2) return Math.max(...sticker);</code></pre></div>\n<p>만일 스티커의 개수가 2개 이하라면, 배열 내의 최댓값을 리턴하면 된다. 맨 처음 스티커를 떼지 않는 경우를 고려할 때 스티커 배열의 3번째 요소에 접근하기 때문에 위와 같이 처리해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const len = sticker.length;\nconst d = Array(len - 1).fill(0);\n\nd[0] = sticker[0];\nd[1] = d[0];\nfor (let i = 2; i &lt; d.length; i++) {\n    d[i] = Math.max(d[i - 2] + sticker[i], d[i - 1]);\n}\n\nconst max_first = Math.max(...d);</code></pre></div>\n<p>첫 번째 스티커를 뜯어냈을 경우 코드는 위와 같다. <code class=\"language-text\">d[1] = d[0]</code>인 이유는 <code class=\"language-text\">d[1]</code>의 경우 스티커를 뜯어낼 수 없기 떄문에 <code class=\"language-text\">d[0]</code>의 값과 동일하게 넣어주어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  const d2 = Array(len - 1).fill(0);\n  d2[0] = sticker[1];\n  d2[1] = Math.max(d2[0], sticker[2]);\n\n  for (let i = 2; i &lt; d.length; i++) {\n    d2[i] = Math.max(d2[i - 2] + sticker[i + 1], d2[i - 1]);\n  }\n  const max_second = Math.max(...d2);\n\n  return Math.max(max_first, max_second);\n</code></pre></div>\n<p>첫 번째 스티커를 뜯어내지 않았을 경우 코드는 위와 같다. 첫 번째 스티커를 뜯지 않았기 때문에(제외시켰기 떄문에) 테이블은 스티커의 첫 번째 요소에서부터 시작하도록 한다. 그리고 <code class=\"language-text\">d2[1]</code>의 경우 만일 <code class=\"language-text\">sticker[2]</code>의 크기가 <code class=\"language-text\">d2[0]</code>의 크기보다 크다면, <code class=\"language-text\">sticker[2]</code>를 뜯는게 더 값이 크기 때문에 둘 중 큰 값을 가지도록 한다.</p>\n<h1>전체 코드</h1>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function solution(sticker) {\n  if (sticker.length &lt;= 2) return Math.max(...sticker);\n\n  const len = sticker.length;\n  const d = Array(len - 1).fill(0);\n\n  d[0] = sticker[0];\n  d[1] = d[0];\n  for (let i = 2; i &lt; d.length; i++) {\n    d[i] = Math.max(d[i - 2] + sticker[i], d[i - 1]);\n  }\n  const max_first = Math.max(...d);\n\n  const d2 = Array(len - 1).fill(0);\n  d2[0] = sticker[1];\n  d2[1] = Math.max(d2[0], sticker[2]);\n\n  for (let i = 2; i &lt; d.length; i++) {\n    d2[i] = Math.max(d2[i - 2] + sticker[i + 1], d2[i - 1]);\n  }\n  const max_second = Math.max(...d2);\n\n  return Math.max(max_first, max_second);\n}</code></pre></div>","frontmatter":{"title":"스티커 모으기","date":"September 30, 2022","description":"다이나믹 프로그래밍"}},"previous":null,"next":null},"pageContext":{"id":"e6a14e25-d9b2-5d3b-92e2-9ffc459ac905","previousPostId":null,"nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"]}