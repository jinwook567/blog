{"componentChunkName":"component---src-templates-post-template-tsx","path":"/알고리즘/기지국설치/","result":{"pageContext":{"node":{"fields":{"slug":"/알고리즘/기지국설치/"},"excerpt":"문제 링크 해결 전략 이 문제는 아이디어로 푸는 문제이다. 우리가 구하고자 하는 값은 추가적으로 설치된 기지국의 개수이다. 즉, 기지국이 어디에 설치되는지는 알 필요가 없다는 의미이다. 작은 예시를 통해서 설치해야 할 기지국 개수를 알아본다. 만일 기지국이 전혀 없는 4개의 아파트가 있다고 가정하고, 전파 도달 거리가 1이라면 몇 개의 기지국 설치가 필요할까? 1개의 기지국이 차지하는 영역은 본인의 자리 + 앞 뒤로 w 만큼이다. 즉 2*w+…","frontmatter":{"date":"2022-10-12T00:00:00.000Z","description":"투포인터","title":"기지국 설치"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/12979\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>이 문제는 아이디어로 푸는 문제이다.</p>\n<p><strong>우리가 구하고자 하는 값은 추가적으로 설치된 기지국의 개수이다.</strong> 즉, 기지국이 어디에 설치되는지는 알 필요가 없다는 의미이다.</p>\n<p>작은 예시를 통해서 설치해야 할 기지국 개수를 알아본다. 만일 기지국이 전혀 없는 4개의 아파트가 있다고 가정하고, 전파 도달 거리가 1이라면 몇 개의 기지국 설치가 필요할까?</p>\n<p>1개의 기지국이 차지하는 영역은 본인의 자리 + 앞 뒤로 w 만큼이다. 즉 <code>2*w+1</code>의 길이만큼 차지하게 된다. 위의 예시의 경우 총 2개의 기지국 설치가 필요하다. 기지국의 영역이 4를 넘어가기는 하지만, 전체 영역을 채워야 하기에 2개가 필요하다. <code>3 * 2 > 4</code></p>\n<p>문제에서는 기지국이 설치된 <code>stations</code> 배열이 주어진다. <strong>추가적으로 기지국을 설치해야 할 부분은 설치된 기지국들이 포함하지 못하는 기지국이 전혀 없는 영역이다.</strong></p>\n<p>우리는 방금 예시를 통해서 기지국이 전혀 없는 영역에서 몇개의 기지국을 설치해야 하는지 알게되었다. 그렇다면 이제 필요한 것은 기지국이 전혀 없는 영역을 구하는 것이다.</p>\n<p>기지국이 전혀 없는 영역을 구하기 위해서는 투포인터 알고리즘을 사용하면 된다.</p>\n<pre><code>before = 이전 기지국의 전파가 도달하지 않는 우측 위치.\ncurrent = 현재 기지국의 전파가 마지막으로 도달하는 좌측 위치.\n</code></pre>\n<p>또한 가장 중요한 부분은 포인터에 넣을 위치를 기지국이 마지막으로 포함하는 거리인지, 아니면 바로 못미치는 영역인지 정의해주어야 한다.</p>\n<p>나는 기지국이 처음 시작할 때의 환경을 고려하여 <code>before</code> 변수에는 기지국이 존재하지 않는 상태의 위치, <code>current</code> 변수에는 기지국이 마지막으로 포함하는 거리로 넣어주었다.</p>\n<pre><code class=\"language-js\">let current = 1\nlet before = 1\n\nlet answer = 0\nconst area = w => w * 2 + 1\n\nfor (let i = 0; i &#x3C; stations.length; i++) {\n  current = stations[i] - w\n\n  const diff = current - before\n\n  if (diff > 0) {\n    answer += Math.ceil(diff / area(w))\n  }\n\n  before = stations[i] + w + 1\n}\n</code></pre>\n<p>마지막 라인에 <code>before</code>변수를 <code>stations[i] + w + 1</code>로 초기화 시켜준 이유는 i번째 기지국이 이제 이전 기지국이 되었으며 <code>stations[i] + w + 1</code>이 전파가 도달하지 않는 우측 위치이다.</p>\n<pre><code class=\"language-js\">if (before &#x3C;= n) {\n  answer += Math.ceil((n - before + 1) / area(w))\n}\n</code></pre>\n<p>마지막으로 위의 코드가 필요하다. 왜냐면 마지막 기지국이 n까지 전파가 닿지 않는다면 해당 부분을 채워주어야 하기 때문이다. 여기서 n은 기지국이 설치되어 있지 않는 상태이기 때문에 <code>before &#x3C;=n</code>으로 작성했으며 <code>n-before+1</code>을 한 값을 <code>area(w)</code>로 나누었다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-js\">function solution(n, stations, w) {\n  let current = 1\n  let before = 1\n\n  let answer = 0\n  const area = w => w * 2 + 1\n\n  for (let i = 0; i &#x3C; stations.length; i++) {\n    current = stations[i] - w\n\n    const diff = current - before\n\n    if (diff > 0) {\n      answer += Math.ceil(diff / area(w))\n    }\n\n    before = stations[i] + w + 1\n  }\n\n  if (before &#x3C;= n) {\n    answer += Math.ceil((n - before + 1) / area(w))\n  }\n  return answer\n}\n</code></pre>","id":"2c04d398-b87f-5e70-ab21-36a7c645bfc8"},"previous":{"fields":{"slug":"/programming/함수형 자바스크립트/1장/"},"excerpt":"함수형 프로그래밍이란? 함수 사용을 강조하는 소프트웨어 개발 스타일이다. 단순히 함수를 사용하는 것이 아니라, 애플리케이션의 부수효과(side effect)를 방지하고 상태 변이(mutation of state)를 감소하기 위해 데이터의 제어 흐름과 연산을 추상하는 것이다. 함수형 프로그래밍을 이해하기 위해서는 다음의 4가지 개념을 이해해야 한다. 선언적 프로그래밍 순수 함수 참조 투명성 불변셩 1. 선언적 프로그래밍 내부적으로 코드를 어떻게…","frontmatter":{"date":"2022-10-12T00:00:00.000Z","description":"함수형으로 사고하기","title":"함수형 자바스크립트 1장"},"html":"<h1>함수형 프로그래밍이란?</h1>\n<p>함수 사용을 강조하는 소프트웨어 개발 스타일이다.</p>\n<p>단순히 함수를 사용하는 것이 아니라, <strong>애플리케이션의 부수효과(side effect)를 방지하고 상태 변이(mutation of state)를 감소하기 위해 데이터의 제어 흐름과 연산을 추상하는 것이다.</strong></p>\n<p>함수형 프로그래밍을 이해하기 위해서는 다음의 4가지 개념을 이해해야 한다.</p>\n<ol>\n<li>선언적 프로그래밍</li>\n<li>순수 함수</li>\n<li>참조 투명성</li>\n<li>불변셩</li>\n</ol>\n<h2>1. 선언적 프로그래밍</h2>\n<p>내부적으로 코드를 어떻게 구현했는지, 데이터는 어떻게 흘러가는지 밝히지 않은 채 연산을 표현하는 사상이다.</p>\n<p>배열의 모든 요소를 제곱수로 바꿔주는 예시로 명령형, 선언적 프로그래밍을 비교해본다.</p>\n<pre><code class=\"language-javascript\">//명령형\nconst arr = [1, 2, 3, 4, 5]\nfor (let i = 0; i &#x3C; arr.length; i++) {\n  array[i] = array[i] * array[i]\n}\n</code></pre>\n<pre><code class=\"language-javascript\">//선언적\nconst arr = [1, 2, 3, 4, 5]\narr.map(el => el * el)\n</code></pre>\n<p>위의 예시로 보았을 때 선언적 프로그래밍의 경우 코드가 매우 간결하다. 루프 카운터를 관리하고 배열 인덱스에 정확하게 접근하는 일을 개발자는 할 필요없이 루프 제어는 시스템에 맡겨버리기 때문이다.\n명령형 코드의 경우 루프를 제어하다가 오류가 날 수 있고 배열 자체를 건드리기 때문에 부수효과가 발생할 수 있다.</p>\n<h2>2. 순수 함수</h2>\n<p>순수 함수의 특성은 아래와 같다.</p>\n<ol>\n<li>주어진 입력에만 의존할 뿐, 평가 도중 또는 호출 간 변경될 수 있는 숨겨진 값이나 외부 상태와 무관하게 작동한다.</li>\n<li>전역 객체나 레퍼런스로 전달된 매개변수를 수정하는 등 함수 스코프 밖에서 어떠한 변경도 일으키지 않는다.</li>\n</ol>\n<p>위의 조건을 만족하지 않는 함수는 모두 불순하다고 할 수 있다.</p>\n<pre><code class=\"language-javascript\">let cnt = 0\nconst increment = () => {\n  counter++\n}\n</code></pre>\n<p>위의 함수의 경우는 불순하다. 전역 변수인 cnt를 직접적으로 변경시키기 때문이다.</p>\n<pre><code class=\"language-javascript\">const getToday = () => Date.now()\n</code></pre>\n<p>위 함수는 불순할까? 그렇다. 호출하는 시점에 따라서 다른 결과값을 낸다. 즉 일정한 결과값을 내지 않는다.</p>\n<p>부수효과가 발생하는 상황은 매우 다양한데 아래는 그 예시이다.</p>\n<ul>\n<li>전역 범위에서 변수,속성,자료구조를 변경</li>\n<li>함수의 원래 인수 값을 변경</li>\n<li>사용자 입력을 처리</li>\n<li>예외를 일으킨 해당 함수가 붙잡지 않고(catch) 그대로 예외를 던짐(throw)</li>\n<li>화면 또는 로그 파일에 출력</li>\n<li>HTML 문서, 브라우저 쿠키, DB에 질의</li>\n</ul>\n<p>위의 상황을 봤을 때 거의 모든 상황에서 부수효과가 발생하는 것처럼 보인다.\n함수형 프로그래밍은 모든 상태 변이를 근절하자는 것이 아니고 상태 변이를 줄이고 관리할 수 있는 프레임워크를 제공하여 순수/불순 함수를 구분하자는 것이다.</p>\n<p>실제 코드를 리팩토링 하는 과정을 통해서 어떻게 함수형으로 작성하는지 알아보도록 하자.</p>\n<pre><code class=\"language-javascript\">function showStudent(ssn) {\n  const student = db.find(ssn)\n  if (student !== null) {\n    document.querySelector(\n      `#${elementId}`\n    ).innerHTML = `${student.ssn}, ${student.firstname}, ${student.lastname}`\n  } else {\n    throw new Error(\"학생이 없습니다.\")\n  }\n}\n</code></pre>\n<p>위의 코드는 몇 가지 부수효과를 일으킨다.</p>\n<ol>\n<li>db 변수는 매개변수에 없으니 이는 외부 변수이다. 해당 변수가 변경되서 호출 단계마다 상이한 값을 가르키면 결과값이 완전히 달라진다.</li>\n<li>HTML 요소를 직접적으로 고친다. (DOM은 그 자체로 가변적인 전역 공유 자원이다.)</li>\n<li>학생 레코드를 찾지 못하면 예외를 던지면서 전체 프로그램 스택이 툭 풀리면서 종료된다.</li>\n</ol>\n<p>위 코드를 리팩토링 해보도록 한다. 긴 함수를 하나의 목적을 가진 짧은 함수로 분리하고, 인수를 모두 명시하여 부수효과를 없애보도록 한다.</p>\n<pre><code class=\"language-js\">const find = curry((db, id) => {\n  const obj = db.find(id)\n  if (obj === null) {\n    throw new Error(\"객체를 찾을 수 없습니다.\")\n  }\n  return obj\n})\n</code></pre>\n<p>db를 인수로 받음으로써 부수효과를 줄인다. 또한 예외를 내는 별도의 null 체크 분기문이 있어 일관된 반환값을 보장하도록 하여 전체 함수 결과를 예측 가능한 방향으로 유도한다.</p>\n<pre><code class=\"language-js\">const csv = student =>\n  `${student.ssn}, ${student.firstname}, ${student.lastname}`\n\nconst append = curry((selector, info) => {\n  document.querySelector(selector).innerHTML = info\n})\n</code></pre>\n<p><strong>HTML 객체와의 상호 작용을 자체 함수로 빼내어 불순한 로직을 순수함수에서 제거했다.</strong></p>\n<h2>3. 참조 투명성</h2>\n<p>참조 투명성이란 순수함수를 정의하는 좀 더 공식적인 방법이며, 순수성이란 함수의 인수와 결과값 사이의 순수한 매핑 관계를 의미한다. 즉 어떠한 함수가 동일한 입력을 받았을 때, 동일한 결과를 낸다면 참조 투명한 함수라고 한다.</p>\n<p>위에서 보았단 <code>increment</code>함수는 참조 투명하지 않다. 외부 변수에 접근하여 종속된 반환값을 내기 때문이다. 이를 참조 투명한 함수로 변경해주려면 외부 변수를 제거하고 함수 서명에 정규 매개변수로 명시해야한다.</p>\n<pre><code class=\"language-js\">const increment = counter => counter + 1\n</code></pre>\n<p>항상 동일한 입력값에 일관된 결과를 내기 때문에 테스트 하기도 쉽고 전체 로직을 파악하는데 용이하다.</p>\n<p>함수 인수를 전부 명확하게 정의하면 대부분의 경우 부수효과를 예방할 수 있지만, 객체를 레퍼런스로 넘길 때 실수로 객체에 변이를 일으키지 않도록 주의해야 한다. (객체는 참조형 값으로 인수로 넘기더라도 새롭게 정의되지 않는다.)</p>\n<h2>4. 불변성</h2>\n<p>불변 데이터는 한번 생성된 후 절대 바뀌지 않는다. 문자열, 숫자 등 기본형은 불변이지만, 배열 등의 객체는 불변이 아니다. 함수 인수로 전달해도 내용이 변경되어 부수효과가 발생할 수 있다.\n아래는 정렬 함수를 이용한 예시이다.</p>\n<pre><code class=\"language-js\">const arr = [1, 2, 3, 4, 5]\nconst sorted = arr => arr.sort((a, b) => b - a)\nconsole.log(arr)\n//arr = [5,4,3,2,1]\n</code></pre>\n<h1>함수형 프로그래밍의 좋은 점</h1>\n<ol>\n<li>간단한 함수들로 작업을 분해한다.</li>\n<li>흐름 체인으로 데이터를 처리한다.</li>\n<li>리액티브 패러다임을 실현하여 이벤트 중심 코드의 복잡성을 줄인다.</li>\n</ol>\n<h2>1. 간단한 함수들로 작업을 분해한다.</h2>\n<p>FP는 고수준에서 보면 사실 분해와 합성의 상호작용이라고 할 수 있다. 함수형 사고는 어떤 작업을 논리적 하위작업으로 분할하는 행위부터 시작된다. 나뉘어진 하위 작업을 더 단순한 순수함수로 분해해서 독립적인 작업 단위로 나타낼 수도 있다.</p>\n<p><code>run</code>이라는 함수는 합성이라는 기법을 구현한 함수로, 두 함수를 합성하면 첫 번쨰 함수의 결과값을 다음 함수에 밀어넣는 새로운 함수가 탄생한다. 첫 번째 함수의 반환값과 다음 함수의 인수 간에 느슨하고 형식 안전한 관계가 맺어진다. 두 함수를 섞어 쓰기 위해서는 당연히 인수 개수와 형식이 서로 맞아야한다.</p>\n<p><code>run</code>과 같은 함수 합성은 고수준의 추상화를 통해서 자세한 내막을 밝히지 않아도 코드가 수행하는 전 단계를 일목요연하게 나타낸다.</p>\n<h2>2. 흐름 체인으로 데이터를 처리한다.</h2>\n<p>부드럽게 흘러가는 모듈적인 코드를 작성하는 방법이 합성만 있는 것이 아니다. 체이닝을 통해서도 가능하다. 체인은 같은 객체를 반환하는 순차적인 함수 호출이다.</p>\n<p>복수 과목을 수강한 학생들의 평균 점수를 작성하는 프로그램을 통해서 체이닝의 장점을 알아보도록 하겠다.</p>\n<pre><code class=\"language-js\">//명령형\nconst enrollment = [\n  { enrolled: 2, grade: 100 },\n  { enrolled: 2, grade: 80 },\n  { enrolled: 1, grade: 89 },\n]\n\nlet totalGrade = 0\nlet totalStudentsCnt = 0\n\nfor (let i = 0; i &#x3C; enrollment.length; i++) {\n  const student = enrollment[i]\n  if (studment.enrolled > 1) {\n    totalGrade += grade\n    totalStudentsCnt += 1\n  }\n}\n\nconst average = totalGrade / totalStudentsCnt\n</code></pre>\n<pre><code class=\"language-js\">_.chain(enrollment)\n  .filter(student => student.enrolled > 1)\n  .pluck(\"grade\")\n  .average()\n  .value()\n</code></pre>\n<p>고수준 추상화를 통해서 함수가 어떠한 행동을 하는지 한눈에 파악할 수 있다.\n또한 함수 체인은 필요한 시점까지 실행을 미루는 느긋한 평가(lazy evaluation)을 수행한다. 다른 데에선 쓸 일이 없는 코드를 전부 실행하지 않아도 되니 CPU 부하가 줄어들어 성능이 좋아진다.</p>\n<h2>3.리액티브 패러다임을 실현하여 이벤트 중심 코드의 복잡성을 줄인다.</h2>\n<p>리액티브 프로그래밍은 서버는 물론 클라이언트 측에서 매일 씨름하는 비동기 코드, 이벤트 중심 코드의 복잡도를 현저하게 줄이는 데 큰 도움이 된다.</p>\n<p>더 높은 수준으로 코드를 추상하여 비동기, 이벤트 기반 프로그램을 설정하느라 반복되는 판박이 코드는 아에 잊고 비즈니스 로직에만 전념할 수 있도록 해준다. 또 함수를 체인으로 묶고 합성하는 FP의 능력을 최대한 이끌어낸다.</p>\n<p><em>리액티브 프로그래밍이란: 데이터 스트림과 변경 사항 전파를 중심으로하는 비동기 프로그래밍 패러다임이다.</em></p>\n<p>아래는 학생의 SSN을 읽고 올바른지 검증하는 프로그램이다.</p>\n<pre><code class=\"language-js\">Rx.Observable.fromEvent(\n  document\n    .querySelector(\"#student-ssn\", \"keyup\")\n    .pluck(\"srcElement\", \"value\")\n    .map(ssn => ssn.replace(/^\\s*/g, \"\"))\n    .filter(ssn => ssn !== null &#x26;&#x26; ssn.length === 9)\n    .subscribe(validSsn => {\n      console.log(`올바른 ssn ${validSsn}`)\n    })\n)\n</code></pre>\n<p>리액티브 패러다임은 옵저버블이라는 아주 중요한 장치를 매개로 움직인다. 옵저버블을 이용하면 데이터 스트림을 구독해서 원하는 연산을 우아하게 합성 및 체이닝하여 처리할 수 있다.</p>","id":"a22ee1b4-e7c4-529c-8f01-51d25bd95c7c"},"next":{"fields":{"slug":"/programming/함수형 자바스크립트/2장/"},"excerpt":"함수형 대 객체지향 프로그래밍 객체지향은 잘게 나뉜 기능을 구현하기위해 상속을 통하여 특수한 자료형을 생성한다.\n예시로 학습 관리 시스템의 Student 객체를 모형화 해보면 해당 클래스는 Person 클래스의 하위형이다. 만일 대학교를 다니는 학생이라면, ColleageStudent 같은 형식을 만들어서 붙인다.\nOOP는 새로운 파생 객체를 생성하여 코드를 재사용한다. 하지만 이러한 방식은 모든 하위형에 적용할 필요가 없는 기능을 기존 객체…","frontmatter":{"date":"2022-10-13T00:00:00.000Z","description":"고계 자바스크립트","title":"함수형 자바스크립트 2장"},"html":"<h1>함수형 대 객체지향 프로그래밍</h1>\n<p>객체지향은 잘게 나뉜 기능을 구현하기위해 상속을 통하여 특수한 자료형을 생성한다.\n예시로 학습 관리 시스템의 <code>Student</code> 객체를 모형화 해보면 해당 클래스는 <code>Person</code> 클래스의 하위형이다. 만일 대학교를 다니는 학생이라면, <code>ColleageStudent</code> 같은 형식을 만들어서 붙인다.\n<strong>OOP는 새로운 파생 객체를 생성하여 코드를 재사용한다.</strong></p>\n<p>하지만 이러한 방식은 모든 하위형에 적용할 필요가 없는 기능을 기존 객체에 추가할 때 문제가 발생한다. 예를 들면 <code>Person</code>에 <code>workAddress</code>라는 속성이 있다고 가정해보자. 이는 <code>Student</code>, <code>ColleageStudent</code> 객체에서 전혀 쓸모가 없다.</p>\n<p>명령형 코드인 OOP는 인스턴스 메소드를 통해 가변 상태를 노출하고 조작하는데 이를 위해서 캡슐화에 지나치게 의존하여 무결성을 유지한다. 데이터와 기능이 단단히 응집된다.</p>\n<p>반면에 함수형은 호출자로부터 데이터를 숨길 필요 없이 소규모의, 아주 단순한 자료형만을 대상으로 움직인다. 즉 데이터와 기능이 느슨하게 결합되어 있다.</p>\n<p>FP와 OOP를 적절히 조합하면 최고의 생산성으로 코드를 짤 수 있다. 그러기 위해서는 객체를 불변 개체나 불변 값으로 바라보고 기능을 함수로 분리하여 객체 내에서 작동되게끔 해야한다. <code>Person</code> 객체를 통해서 예시를 들어보자.</p>\n<pre><code class=\"language-js\">//oop\nget fullname(){\n    return [this._firstname, this._lastname].join('')\n}\n\n//함수로 분리\nconst fullname = (person) => [person._firstname, person._lastname].join('')\n</code></pre>\n<p>기반형을 레퍼런스를 사용하는 함수라면 파생형 객체에서도 문제없이 작동한다. (<code>Student</code>나 <code>ColleageStudent</code>에도 <code>Person</code>의 <code>_firstname</code>, <code>_lastname</code>을 상속받기 때문.)\n독립형 함수로 분리함으로써 객체 데이터를 this로 접근할 이유가 사라진다. this를 사용한다는 것이 메소드에 범위의 벗어나 인스턴스 수준의 데이터에 접근한다는 것으로 부수효과를 발생한다. 또한 범용성이 높아졌다.</p>\n<h1>JS 객체의 상태 관리</h1>\n<p>프로그램의 상태란 어느 한 시점에 찍은 모든 객체에 저장된 데이터의 스냅샷이다. JS는 객체 상태를 보호하는 측면에서 최악의 언어 중 하나이기에 함수형 프로그래밍을 하기 위해서는 객체의 상태 관리에 유의해야 한다. 불변성 관리를 위한 지침과 패턴을 소개하도록 한다.</p>\n<ol>\n<li>객체를 값으로 취급</li>\n<li>가동부를 깊이 동결</li>\n<li>객체 그래프를 렌즈로 탐색 수정</li>\n</ol>\n<h2>1. 객체를 값으로 취급</h2>\n<p>숫자와, 문자열 같은 자료형은 불변값이다. FP에서는 이러한 불변값을 값(value)이라고 한다.</p>\n<p>객체 구조가 단순하다면 값-객체 패턴도 괜찮은 방안이다. 값 객체는 객체의 동등성이 항등성이나 레퍼런스가 아닌 오직 값에 따라 좌우되는 객체이다. 일단 값 객체를 선언한 이후엔 그 상태는 절대 변하지 않는다. 예시로 클로저를 사용하고 내부 상태 변화를 일으키지 않는 메소드만을 제공한다면, 외부에서 접근하여 값을 변경할 수 없다. 동일한 모형의 값이 다른 객체가 필요한 경우 사본을 만들어서 리턴한다.</p>\n<h2>2. 가동부를 깊이 동결</h2>\n<p>실무에서 모든 객체를 값-객체 패턴으로 만들 수 없다. 또한 Student-Person과 같은 계층적 데이터를 처리하는 코드가 필요할 때가 있다.\nwritable처럼 숨겨진 메타속성을 제어하면 내부 조작이 가능하다. Object.freeze() 함수는 writable 속성을 전부 false로 세팅하여 객체 상태를 못 바꾸도록 동결한다. 하지만 객체 내부의 객체와 같은 중첩 객체의 경우에는 동결되지 않는 얕은 동결이기에 만일 객체 내부의 모든 값을 동결시키기를 원한다면 재귀함수를 이용하여 구현해줘야 한다.</p>\n<p>하지만 상태를 전혀 바꿀 수 없는 애플리케이션이란 현실적이지 않다. 원본 객체에서 새 객체를 만드는 엄격한 정책을 적용하면 도움이 된다.</p>\n<h2>3. 객체 그래프를 렌즈로 탐색/수정</h2>\n<p>해당 방식은 원본 객체에서, 새 객체를 만드는 방식이다. 다만 내부 저장소 컴포넌트를 이용하기에 한번 등록 시켜놓으면 매번 새로운 객체를 만드는 행위를 할 필요가 없다. 람다JS라는 라이브러리가 해당 기능을 제공한다. R.set 함수는 원래 상태는 그대로 유지한 채 새로운 값이 포함된 객체 사본을 새로 만들어 반환한다. 중첩 객체까지 지원한다.</p>\n<h1>함수</h1>\n<h2>함수를 일급 시민으로</h2>\n<p>JS의 함수는 실제로 객체이기 때문에 일급이다.</p>\n<p><em>일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 뜻한다. 3가지 원칙을 만족해야한다. 1. 변수에 담을 수 있다. 2. 인자로 전달할 수 있다. 3. 반환값으로 전달할 수 있다.</em></p>\n<p><em>함수를 다른 변수와 동일하게 다루는 언어는 일급 함수를 가졌다라고 표현한다. 함수를 다른 함수의 인수로 제공하거나 함수가 함수를 반환할 수 있고, 변수에도 할당할 수 있다. 자바스크립트는 일급 함수를 가졌다.</em></p>\n<h2>고계 함수</h2>\n<p>함수를 함수 인수로 전달하거나 함수를 반환받을 수 있다. 이러한 함수를 고계함수(higher-order-function)이라고 한다. 예시로 Array.sort()의 comparator 함수도 고계함수이다.</p>\n<p>JS에서 함수는 일급+고계여서 여느 값이나 다름이 없다. 즉 자신이 받은 입력값을 기반으로 정의된 언제가는 실행될 값에 지나지 않는다.</p>\n<p>고계함수를 사용하면 아주 장황했을 프로그램이 매우 단순해진다. 미국 거주자 명단을 출력하는 프로그램 예시를 통해서 알아보도록 한다.</p>\n<pre><code class=\"language-js\">//명령형\nfunction printPeopleInUs(people) {\n  for (let person of people) {\n    if (person.address.country === \"US\") {\n      console.log(person)\n    }\n  }\n}\n</code></pre>\n<pre><code class=\"language-js\">//고계함수 이용\nfunction printPeople(people, action) {\n  for (let person of people) {\n    action(person)\n  }\n}\n\nfunction action(person) {\n  if (person.address.county === \"US\") {\n    console.log(person)\n  }\n}\n</code></pre>\n<pre><code class=\"language-js\">//범용성을 위한 리팩토링\nfunction printPeople(people, selector, printer) {\n  people.forEach(person => {\n    if (selector(person)) {\n      printer(person)\n    }\n  })\n}\n\nconst selector = person => person.address.country === \"US\"\nconst printer = somthing => console.log(somthing)\nprintPeople(people, selector, printer)\n</code></pre>\n<p>리팩토링을 통해서 데이터를 고르는 기준을 변경할 수 있고 출력 대상을 바꾸는 일도 자유롭다.</p>\n<h2>함수 호출 유형</h2>\n<ol>\n<li>전역 함수로 호출\n<ul>\n<li>this 레퍼런스는 전역 객체, 엄격 모드일 경우에는 undefined를 가르킨다.</li>\n</ul>\n</li>\n<li>메소드로 호출\n<ul>\n<li>this 레퍼런스는 해당 메서드를 소유한 객체이다.</li>\n</ul>\n</li>\n<li>new를 붙여 생성자로 호출\n<ul>\n<li>새로 만든 객체의 레퍼런스를 암시적으로 반환한다.</li>\n</ul>\n</li>\n</ol>\n<h2>함수 메서드</h2>\n<p>apply, call, map, filter와 같은 메소드가 있다.</p>\n<h1>클로저</h1>\n<p><a href=\"https://ko.javascript.info/closure\">클로저 상세 설명 링크</a></p>\n<p>클로저는 다음과 같이 응용될 수 있다.</p>\n<ol>\n<li>프라이빗 변수를 모방</li>\n<li>서버 측 비동기 호출</li>\n<li>가상의 블록 스코프 변수 생성</li>\n</ol>\n<h2>프라이빗 변수 모방</h2>\n<p>다른 프로그래밍 언어는 private 접근자로 객체 내부 속성을 세팅할 수 있으나 JS는 불가능하다. 클로저를 활용하면 프라이빗 변수를 모방할 수 있다.</p>\n<p>자바스크립트 라이브러리나 모듈 개발자는 전체 모듈의 프라이빗 메서드와 데이터를 숨길 때 클로저를 적극 활용한다. 이를 모듈 패턴이라고 한다. 전역 레퍼런스 개수를 줄이기 위해서 즉시 실행 함수를 사용한다.</p>\n<pre><code class=\"language-js\">var myModule = (function myModule(export){\n    //에러 발생 시 스택을 보며 추적할 수 있도록 함수에 이름을 붙인다.\n    let privateVar;\n\n    export.method1 = function () {\n        //작업 수행\n    }\n\n    export.method2 = function () {\n        //작업 수행\n    }\n    return export\n})(myModule || {})\n</code></pre>\n<h3>전역 스코프의 문제점</h3>\n<p>전역 스코프는 가장 단순하면서 나쁜 스코프이다. JS의 함수는 스코프 체인을 따라서 변수를 확인하기 떄문에 전역 스코프를 사용하는 것이 관찰 가능한 어떤 변화를 함수에 전파하는 것과 동일하다. 또한 전역 데이터는 변수 상태가 언제 어떻게 바뀌는지 디버깅하기 어렵다.</p>\n<h2>서버 측 비동기 호출</h2>\n<p>콜백 함수(고계 함수)를 사용하여 비동기 처리를 할 수 있다.</p>\n<h2>가상의 블록 스코프 변수 생성</h2>\n<p>루프 카운터 문제 역시 클로저로 해결할 수 있다. let을 쓴다면 기존 루프 체제 문제는 해결이 되지만, 클로저와 함수 스코프를 활용한 forEach가 정답이다. 루프 카운터와 다른 변수들을 스코프 내부에 묶느라 고민하지 않아도 루프문에 함수 스코프 블록이 존재하는 것처럼 루프 본체를 효과적으로 감쌀 수 있다.</p>\n<pre><code class=\"language-js\">const arr = [1, 2, 3, 4]\narr.forEach(el => {\n  let blockScopeVar = \"hi\"\n})\n</code></pre>","id":"8b6ed648-4502-5ab2-94ea-7b151bb8595d"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}