{"componentChunkName":"component---src-templates-post-template-tsx","path":"/알고리즘/여행경로/","result":{"pageContext":{"node":{"fields":{"slug":"/알고리즘/여행경로/"},"excerpt":"문제 링크 해결 전략 우리는 주어진 항공권을 모두 이용해야한다. 즉 항공권을 모두 사용하는 케이스를 탐색해야한다.\n만일 가능한 경로가 2개 이상 있을 때, 알파벳 순서가 앞서는 경로를 리턴해야 하므로 BFS로 탐색하고 만족하는 값을 찾으면 탐색을 중지하도록 하겠다. 탐색하는 방법은 간단하다. 티켓 중에서 시작점이 마지막에 방문한 도시와 일치하는 티켓들을 찾고 알파벳 순서로 정렬 후 방문한다. 이 과정을 모든 티켓을 사용(방문)할 떄 까지 반복…","frontmatter":{"date":"2022-10-06T00:00:00.000Z","description":"DFS/BFS","title":"여행 경로"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/43164\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>우리는 주어진 항공권을 모두 이용해야한다. 즉 항공권을 모두 사용하는 케이스를 탐색해야한다.\n만일 가능한 경로가 2개 이상 있을 때, 알파벳 순서가 앞서는 경로를 리턴해야 하므로 BFS로 탐색하고 만족하는 값을 찾으면 탐색을 중지하도록 하겠다.</p>\n<p>탐색하는 방법은 간단하다. 티켓 중에서 시작점이 마지막에 방문한 도시와 일치하는 티켓들을 찾고 알파벳 순서로 정렬 후 방문한다. 이 과정을 모든 티켓을 사용(방문)할 떄 까지 반복한다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-javascript\">class Queue {\n  constructor() {\n    this.front = 0\n    this.rear = 0\n    this.queue = []\n  }\n\n  enqueue(data) {\n    this.queue[this.rear++] = data\n  }\n\n  dequeue() {\n    const value = this.queue[this.front]\n    delete this.queue[this.front]\n    this.front++\n    return value\n  }\n\n  size() {\n    return this.rear - this.front\n  }\n}\n\n//시작점이 마지막에 방문한 도시인 티켓들을 찾고, 알파벳 순서로 정렬하는 코드\nconst findMatchTickets = (start, tickets, visited) => {\n  const result = []\n  for (let i = 0; i &#x3C; tickets.length; i++) {\n    if (!visited[i] &#x26;&#x26; tickets[i][0] === start) {\n      result.push({ i, end: tickets[i][1] })\n    }\n  }\n  result.sort((a, b) => (a.end > b.end) - (a.end &#x3C; b.end))\n  return result\n}\n\nfunction solution(tickets) {\n  const visited = Array(tickets.length).fill(false)\n\n  const queue = new Queue()\n  queue.enqueue({ visited, path: [\"ICN\"] })\n\n  while (queue.size() > 0) {\n    const { visited, path } = queue.dequeue()\n    if (visited.every(v => v)) return path\n\n    const lastVisited = path[path.length - 1]\n    const matchedTickets = findMatchTickets(lastVisited, tickets, visited)\n\n    matchedTickets.forEach(({ i, end }) => {\n      const newVistied = [...visited]\n      newVistied[i] = true\n      queue.enqueue({ visited: newVistied, path: [...path, end] })\n    })\n  }\n}\n</code></pre>\n<h1>추가</h1>\n<p>BFS가 아닌, DFS를 이용해도 문제를 해결할 수 있다. 다만 우리는 알파벳 순서가 앞서는 경로를 리턴해야 하므로 BFS와 동일하게 알파벳 순서가 앞서는 경로를 먼저 넣어주고, 만일 모든 티켓을 방문했다면 즉 정답을 찾았다면 DFS 탐색을 중지한다.</p>\n<pre><code class=\"language-javascript\">const findMatchTickets = (start, tickets) => {\n  const result = []\n  for (let i = 0; i &#x3C; tickets.length; i++) {\n    if (tickets[i][0] === start) {\n      result.push({ i, end: tickets[i][1] })\n    }\n  }\n  result.sort((a, b) => (a.end > b.end) - (a.end &#x3C; b.end))\n  return result\n}\n\nfunction solution(tickets) {\n  let answer = null\n\n  function dfs(leftTickets, lastVisited, path) {\n    if (answer) return\n    if (leftTickets.length === 0) {\n      answer = path\n    }\n\n    findMatchTickets(lastVisited, leftTickets).forEach(({ i, end }) => {\n      dfs(\n        leftTickets.filter((_, index) => index !== i),\n        end,\n        [...path, end]\n      )\n    })\n  }\n  dfs(tickets, \"ICN\", [\"ICN\"])\n  return answer\n}\n</code></pre>","id":"777d548c-27fe-5a4a-af3b-62269fca7d6b"},"previous":{"fields":{"slug":"/알고리즘/이중우선순위큐/"},"excerpt":"문제 링크 해결 전략 이 문제의 operation은 최대 1,000,000이다. 따라서 최댓값, 최솟값을 제거해주기 위해서 굳이 힙을 사용하지 않고도 정렬을 사용해도 좋다. sort 메소드를 사용한다면 O(NlogN)으로 문제를 해결할 수 있다.\nshift 메소드의 경우 O(N)의 시간이 소모되므로, 매번 정렬을 수행하는 것보다 shift 메소드를 사용하는 것이 더 빠르다. 따라서 작성한 알고리즘은 아래와 같다. 전체 코드 추가 문제의 이름이…","frontmatter":{"date":"2022-10-06T00:00:00.000Z","description":"힙, 정렬","title":"이중우선순위큐"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42628\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>이 문제의 operation은 최대 1,000,000이다. 따라서 최댓값, 최솟값을 제거해주기 위해서 굳이 힙을 사용하지 않고도 정렬을 사용해도 좋다. sort 메소드를 사용한다면 O(NlogN)으로 문제를 해결할 수 있다.\nshift 메소드의 경우 O(N)의 시간이 소모되므로, 매번 정렬을 수행하는 것보다 shift 메소드를 사용하는 것이 더 빠르다. 따라서 작성한 알고리즘은 아래와 같다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-javascript\">function solution(operations) {\n  const arr = []\n  operations.forEach(v => {\n    const [command, strNum] = v.split(\" \")\n    const num = Number(strNum)\n    if (command === \"I\") {\n      arr.push(num)\n      arr.sort((a, b) => a - b)\n    }\n\n    if (command === \"D\") {\n      if (num === -1) {\n        arr.shift()\n      } else {\n        arr.pop()\n      }\n    }\n  })\n\n  return arr.length === 0 ? [0, 0] : [arr[arr.length - 1], arr[0]]\n}\n</code></pre>\n<h1>추가</h1>\n<p>문제의 이름이 이중우선순위큐인 만큼 한번 힙을 이용해서 문제를 해결해보도록 하겠다.</p>\n<p>새롭게 최대힙과 최소힙 기능을 하는 이중우선순위큐를 정의하는 것은 복잡하기에 최대힙, 최소힙 2개의 자료구조를 이용해서 문제를 해결하도록 한다.</p>\n<p>최대힙을 정의하고, 최소힙은 최대힙을 이용해서 구현한다. 최소힙의 경우 요소를 넣을 때 음의 형태로 변환해서 넣어준다.</p>\n<p>우리는 2개의 힙을 사용하지만, 하나의 배열로 생각할 수 있다. 그 이유는 최대힙은 최댓값을 배출하고, 최소힙은 최솟값을 배출하기 때문이다. 오름차순으로 배열이 정렬되어있다고 가정하면, 최대힙은 오른쪽에서부터 하나씩 제거되고 최소힙은 왼쪽에서부터 하나씩 제거해나간다고 할 수 있다. 따라서 우리가 고려해주어야 하는 시점은, 최대힙에서 배출하는 요소가, 최소힙에서 배출하는 요소와 동일할 때이다. 즉 하나의 배열이라고 생각했을 때 배열의 원소가 1개만 있을 때이다. 이 때의 경우 2개의 힙을 빈 배열로 초기화 시켜주면 된다. 초기화 시켜주지 않는다면 힙에 원소가 남게되고 이는 다른 결과를 초래할 수 있다. 배열의 원소가 1개 남았는지 파악하기 위해서 <code>heapCnt</code>라는 변수를 사용한다.</p>\n<p>구현한 코드는 아래와 같다.</p>\n<pre><code class=\"language-javascript\">class MaxHeap {\n  constructor() {\n    this.heap = []\n  }\n\n  swap(aIndex, bIndex) {\n    ;[this.heap[aIndex], this.heap[bIndex]] = [\n      this.heap[bIndex],\n      this.heap[aIndex],\n    ]\n  }\n\n  push(value) {\n    this.heap.push(value)\n    let currentIndex = this.heap.length - 1\n    let parentIndex = Math.floor((currentIndex - 1) / 2)\n\n    while (parentIndex >= 0 &#x26;&#x26; this.heap[parentIndex] &#x3C; value) {\n      this.swap(parentIndex, currentIndex)\n      currentIndex = parentIndex\n      parentIndex = Math.floor((currentIndex - 1) / 2)\n    }\n  }\n\n  pop() {\n    if (this.heap.length === 0) return undefined\n    if (this.heap.length === 1) return this.heap.pop()\n\n    const root = this.heap[0]\n    const end = this.heap.pop()\n    this.heap[0] = end\n\n    let currentIndex = 0\n    let leftIndex = 1\n    let rightIndex = 2\n\n    while (\n      this.heap[currentIndex] &#x3C; this.heap[leftIndex] ||\n      this.heap[currentIndex] &#x3C; this.heap[rightIndex]\n    ) {\n      if (this.heap[leftIndex] &#x3C; this.heap[rightIndex]) {\n        this.swap(currentIndex, rightIndex)\n        currentIndex = rightIndex\n      } else {\n        this.swap(currentIndex, leftIndex)\n        currentIndex = leftIndex\n      }\n      leftIndex = currentIndex * 2 + 1\n      rightIndex = currentIndex * 2 + 2\n    }\n    return root\n  }\n}\n\nfunction solution(operations) {\n  let heapCnt = 0\n  const maxHeap = new MaxHeap()\n  const minHeap = new MaxHeap()\n\n  operations.forEach(v => {\n    const [command, number] = v.split(\" \")\n    if (command === \"I\") {\n      maxHeap.push(Number(number))\n      minHeap.push(-Number(number))\n      heapCnt++\n    }\n\n    if (command === \"D\") {\n      if (heapCnt === 0) return\n      heapCnt--\n      if (Number(number) === -1) {\n        minHeap.pop()\n      } else {\n        maxHeap.pop()\n      }\n      if (heapCnt === 0) {\n        minHeap.heap = []\n        maxHeap.heap = []\n      }\n    }\n  })\n\n  if (heapCnt === 0) return [0, 0]\n  return [maxHeap.pop(), -minHeap.pop()]\n}\n</code></pre>","id":"72f660a2-4068-5add-8e8e-515c5ff3924a"},"next":{"fields":{"slug":"/programming/git/"},"excerpt":"merge 병합은 두 브랜치의 합집합을 구하는 것이다. 병합에는 3가지 종류가 있다. merge commit 서로 다른 변경된 부분이 있을 경우, 새롭게 저장한다. fast-forward 합친 결과물이 한 커밋의 결과물과 동일할 때 새로운 상태를 만들어 줄 필요없이 상태를 바꿔주면 된다. conflict 동일한 부분이 다를 경우 충돌이 일어나게 된다. pull request 정중하게 브랜치 병합을 요청하는 것이다. 풀 리퀘 제목: 동료 개발자…","frontmatter":{"date":"2022-10-06T00:00:00.000Z","description":"merge, pull request, fork, rebase..","title":"git 사용법"},"html":"<h1>merge</h1>\n<p>병합은 두 브랜치의 합집합을 구하는 것이다. 병합에는 3가지 종류가 있다.</p>\n<ol>\n<li>merge commit\n<ul>\n<li>서로 다른 변경된 부분이 있을 경우, 새롭게 저장한다.</li>\n</ul>\n</li>\n<li>fast-forward\n<ul>\n<li>합친 결과물이 한 커밋의 결과물과 동일할 때 새로운 상태를 만들어 줄 필요없이 상태를 바꿔주면 된다.</li>\n</ul>\n</li>\n<li>conflict\n<ul>\n<li>동일한 부분이 다를 경우 충돌이 일어나게 된다.</li>\n</ul>\n</li>\n</ol>\n<h1>pull request</h1>\n<p>정중하게 브랜치 병합을 요청하는 것이다.</p>\n<ul>\n<li>풀 리퀘 제목: 동료 개발자가 한 눈에 이해하기 쉬운 제목을 적어둔다.</li>\n<li>풀 리퀘 내용: 코드를 이해하는데 도움이 되는 설명을 적어준다. 스크린샷 혹은 테스트 방법</li>\n<li>reviewers: 콕 찝어서 풀 리퀘 검토 요청, 같은 팀원 혹은 해당 기능과 연관된 동료 선택</li>\n</ul>\n<h1>fork</h1>\n<p>타인의 원본저장소를 내 계정의 원격저장소로 복사해오는 명령어이다.\n브랜치를 포함한 원본저장소의 모든 커밋 이력을 통째로 복사한다.</p>\n<h3>오픈 소스 기여 방식</h3>\n<p>원본 저장소에는 지정된 collaborators만 코드를 푸쉬할 수 있다. 오픈소스 프로젝트에서 만일 collaborators가 너무 많아진다면 저장소를 관리하는데 어려워질 것이다. 하지만 동시에 많은 개발자들에게 의견을 받고 오픈소스를 개선하고 싶은 니즈가 있다. 이럴 때 개발자는 fork를 해서 원본 저장소를 복사하고, 이곳에 커밋을 올린 다음에 원본 저장소의 소유자에게 풀 리퀘를 요청하면 원본 저장소의 소유자는 개발자의 병합 요청을 검토해서 원본 저장소에 반영한다.</p>\n<h3>원본 저장소에 풀 리퀘 보내기</h3>\n<p>new pull request 버튼을 누르고 head repository, base repository가 뜬다면 성공이다.\n풀 리퀘에 대한 설명을 적고 요청을 보낸다. 만일 원본저장소에 컨트리뷰션 가이드가 있다면 읽고 준수하도록 한다. 보통 README.md에 존재한다.</p>\n<p>풀 리퀘를 승인하는 방법은, 좌측 카테고리에 fork 탭을 클릭하고 pull requests 탭을 클릭하면 요청된 풀 리퀘들을 확인할 수 있다. 댓글만 달고 싶다면 comment를, 댓글을 달고 코드가 좋아보여 바로 병합해도 되면 approve를, 수정을 요청하고 싶으면 request changes를 선택한다.</p>\n<h1>add remote</h1>\n<p>내 원격 저장소에서 원본 저장소의 히스토리도 같이 보고싶다면, add remote를 해주면 된다. 원격 이름에는 upstream을 넣어주고 원본 저장소 주소를 복사해서 넣어주면 된다. upstream은 원본 저장소를 지칭하는 관용적 닉네임이다.</p>\n<p><code>fetch</code>를 하게 되면 원본 저장소에 있는 커밋 히스토리를 받아올 수 있다. pull과는 다른 점은 커밋 이력만 받아오기 때문에 내 코드에는 아무 영향이 없다.</p>\n<h1>rebase</h1>","id":"6a5ee1a7-b8a6-5d22-8968-6a91a6171688"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}