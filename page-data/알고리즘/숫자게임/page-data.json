{"componentChunkName":"component---src-templates-post-template-tsx","path":"/알고리즘/숫자게임/","result":{"pageContext":{"node":{"fields":{"slug":"/알고리즘/숫자게임/"},"excerpt":"문제 링크 해결 전략 우리는 B의 순서를 조정할 수 있다. 따라서 A의 순서를 바꿔도 상관없다. 순서가 변경된 A에 맞춰서 B의 순서를 변경하면 되기 때문이다. 우리는 근소한 차이로 이길 때, 최대한 많이 이길 수 있다. 예시로 1을 이기는데 9를 낼 필요는 없다는 것이다. 내가 2를 보유하고 있다면 2를 내는 것이 이득이다. 나중에 7과 같은 큰 수를 만나면 그 때 9를 내야한다. 위의 두 생각을 바탕으로 나는 A와 B를 내림차순으로 정렬하…","frontmatter":{"date":"2022-10-05T00:00:00.000Z","description":"그리디","title":"숫자 게임"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/12987\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<ol>\n<li>\n<p>우리는 B의 순서를 조정할 수 있다. 따라서 A의 순서를 바꿔도 상관없다. 순서가 변경된 A에 맞춰서 B의 순서를 변경하면 되기 때문이다.</p>\n</li>\n<li>\n<p>우리는 근소한 차이로 이길 때, 최대한 많이 이길 수 있다. 예시로 1을 이기는데 9를 낼 필요는 없다는 것이다. 내가 2를 보유하고 있다면 2를 내는 것이 이득이다. 나중에 7과 같은 큰 수를 만나면 그 때 9를 내야한다.</p>\n</li>\n</ol>\n<p>위의 두 생각을 바탕으로 나는 A와 B를 내림차순으로 정렬하였다. 내림차순으로 정렬한 이유는 순서대로 비교해보았을 때, 어떤 순서에서 B 요소가 A 요소보다 크다면 해당 순서의 B 요소는 다음 순서로 등장하는 A의 요소들 전부를 이길 수 있기 때문이다. 즉 가장 근소한 차이로 이길 수 있는 순서를 알 수 있다는 말이다.</p>\n<p>나의 초기 알고리즘은 배열을 순회하면서 동일한 순서에 대해서 A 요소와 B 요소의 크기를 비교하는 것이였다. 하지만 이 알고리즘의 경우 이길 수 있는 개수를 누락시킨 다는 문제가 있었다. 예시는 아래와 같다.</p>\n<p><code>A: [5,3,1]</code>, <code>B:[4,2,0]</code>의 경우 내가 초기 작성한 알고리즘은 0이라는 정답을 도출한다. 하지만 실제 정답은 2이다. [A,B] 형태로 표현할 때, [3,4], [1,2] 2개의 케이스가 존재하기 때문이다.</p>\n<p>누락되는 문제를 해결하기 위해서는 비교하는 방식을 변경해주면 된다. 동일한 순서에 대해서만 비교해주는 것이 아니라, 만일 A가 B보다 클 경우 B의 순서는 고정시켜 놓고 A의 순서만 움직인다. 만일 B가 A보다 클 경우에는 A와 B 순서 둘다 움직여주면 된다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-javascript\">function solution(A, B) {\n  A.sort((a, b) => b - a)\n  B.sort((a, b) => b - a)\n\n  let answer = 0\n  const len = A.length\n\n  for (let i = 0, j = 0; i &#x3C; len; i++) {\n    if (A[i] &#x3C; B[j]) {\n      j++\n      answer++\n    }\n  }\n  return answer\n}\n</code></pre>\n<h1>추가</h1>\n<p>추가로 내림차순으로 정렬을 하지 않고, 최대힙을 이용하는 방법도 있다.</p>\n<pre><code class=\"language-javascript\">class MaxHeap {\n  constructor() {\n    this.heap = []\n  }\n\n  swap(aIndex, bIndex) {\n    ;[this.heap[aIndex], this.heap[bIndex]] = [\n      this.heap[bIndex],\n      this.heap[aIndex],\n    ]\n  }\n\n  push(value) {\n    this.heap.push(value)\n    let currentIndex = this.heap.length - 1\n    let parentIndex = Math.floor((currentIndex - 1) / 2)\n\n    while (parentIndex >= 0 &#x26;&#x26; this.heap[parentIndex] &#x3C; value) {\n      this.swap(parentIndex, currentIndex)\n      currentIndex = parentIndex\n      parentIndex = Math.floor((currentIndex - 1) / 2)\n    }\n  }\n\n  pop() {\n    if (this.heap.length === 0) return undefined\n    if (this.heap.length === 1) return this.heap.pop()\n\n    const root = this.heap[0]\n    const end = this.heap.pop()\n    this.heap[0] = end\n\n    let currentIndex = 0\n    let leftIndex = 1\n    let rightIndex = 2\n\n    while (\n      this.heap[currentIndex] &#x3C; this.heap[leftIndex] ||\n      this.heap[currentIndex] &#x3C; this.heap[rightIndex]\n    ) {\n      if (this.heap[leftIndex] &#x3C; this.heap[rightIndex]) {\n        this.swap(currentIndex, rightIndex)\n        currentIndex = rightIndex\n      } else {\n        this.swap(currentIndex, leftIndex)\n        currentIndex = leftIndex\n      }\n      leftIndex = currentIndex * 2 + 1\n      rightIndex = currentIndex * 2 + 2\n    }\n    return root\n  }\n}\n\nfunction solution(A, B) {\n  const heap_A = new MaxHeap()\n  const heap_B = new MaxHeap()\n  const len = A.length\n\n  for (let i = 0; i &#x3C; len; i++) {\n    heap_A.push(A[i])\n    heap_B.push(B[i])\n  }\n  let answer = 0\n\n  let maxA = heap_A.pop()\n  let maxB = heap_B.pop()\n\n  while (maxA) {\n    if (maxA &#x3C; maxB) {\n      answer++\n      maxA = heap_A.pop()\n      maxB = heap_B.pop()\n    } else {\n      maxA = heap_A.pop()\n    }\n  }\n  return answer\n}\n</code></pre>","id":"7f14a095-e1f6-5567-bd76-936d59b7781f"},"previous":{"fields":{"slug":"/알고리즘/야근지수/"},"excerpt":"문제 링크 해결 전략 초기에는 완전 탐색으로 접근해보았다. 하지만 n을 works에 분배하는 과정에서 무조건 시간 초과가 발생할 수 밖에 없다. 따라서 문제의 특성을 이용한 다른 접근 방법이 필요하다.\n우리는 배열 내 요소의 제곱의 합의 최솟값을 구해야한다. 제곱의 그래프는 우측으로 이동할수록 급격히 증가하는 그래프 형태를 띄게 된다. 반대로 말하자면 좌측으로 이동할수록 급격히 감소한다는 의미이다. 우리는 최솟값을 구해야 하므로 감소하는 폭을…","frontmatter":{"date":"2022-10-04T00:00:00.000Z","description":"최대힙","title":"야근지수"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/12927\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>초기에는 완전 탐색으로 접근해보았다. 하지만 n을 works에 분배하는 과정에서 무조건 시간 초과가 발생할 수 밖에 없다.</p>\n<p>따라서 문제의 특성을 이용한 다른 접근 방법이 필요하다.\n우리는 배열 내 요소의 제곱의 합의 최솟값을 구해야한다. 제곱의 그래프는 우측으로 이동할수록 급격히 증가하는 그래프 형태를 띄게 된다.</p>\n<p>반대로 말하자면 좌측으로 이동할수록 급격히 감소한다는 의미이다. 우리는 최솟값을 구해야 하므로 감소하는 폭을 최대한 크게 만들어야 한다. 감소하는 폭을 최대한 크게 만들기 위해서는 배열 내에서 가장 큰 요소를 뽑아서 줄여주는 전략을 택하면 된다. 가장 큰 요소를 어떻게 줄여주느냐가 시간 복잡도에 큰 영향을 미친다.</p>\n<p>내가 작성한 초기 알고리즘은 최댓값을 구하고, 최댓값보다 바로 작은 숫자만큼 빼주는 방식이였다. 하지만 이렇게 작성할 경우 배열 내 모든 원소가 최댓값과 같은 경우를 고려해줘야 하기 때문에 알고리즘이 복잡해진다.</p>\n<p>최댓값을 구하고 최댓값과 n을 1씩 빼는 알고리즘을 사용한다면 간결하게 정답을 구할 수 있다. 하지만 n이 1,000,000이고 works 배열의 길이는 20,000이기 때문에 배열을 순회하면서 최댓값을 찾는 방식을 사용한다면 1,000,000 * 20,000 으로 시간 복잡도를 초과하게 된다. 최댓값을 구할 때 우리는 최대힙을 사용한다면 log(20,000) 시간으로 최댓값을 구할 수 있고 시간 복잡도를 초과하지 않게 된다.</p>\n<h1>교훈</h1>\n<p>시간 복잡도를 기반으로 방법을 생각해내는 것도 좋지만, 문제의 특성에 따라 방법을 생각하고 시간 복잡도를 줄이는 방안도 생각해봐야 한다. (이진탐색, 우선순위 큐 등)</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-javascript\">class MaxHeap {\n  constructor() {\n    this.heap = []\n  }\n\n  swap(aIndex, bIndex) {\n    ;[this.heap[aIndex], this.heap[bIndex]] = [\n      this.heap[bIndex],\n      this.heap[aIndex],\n    ]\n  }\n\n  push(value) {\n    this.heap.push(value)\n    let currentIndex = this.heap.length - 1\n    let parentIndex = Math.floor((currentIndex - 1) / 2)\n\n    while (parentIndex >= 0 &#x26;&#x26; this.heap[parentIndex] &#x3C; value) {\n      this.swap(parentIndex, currentIndex)\n      currentIndex = parentIndex\n      parentIndex = Math.floor((currentIndex - 1) / 2)\n    }\n  }\n\n  pop() {\n    if (this.heap.length === 0) return undefined\n    if (this.heap.length === 1) return this.heap.pop()\n\n    const root = this.heap[0]\n    const end = this.heap.pop()\n    this.heap[0] = end\n\n    let currentIndex = 0\n    let leftIndex = 1\n    let rightIndex = 2\n\n    while (\n      this.heap[currentIndex] &#x3C; this.heap[leftIndex] ||\n      this.heap[currentIndex] &#x3C; this.heap[rightIndex]\n    ) {\n      if (this.heap[leftIndex] &#x3C; this.heap[rightIndex]) {\n        this.swap(currentIndex, rightIndex)\n        currentIndex = rightIndex\n      } else {\n        this.swap(currentIndex, leftIndex)\n        currentIndex = leftIndex\n      }\n      leftIndex = currentIndex * 2 + 1\n      rightIndex = currentIndex * 2 + 2\n    }\n    return root\n  }\n}\n\nfunction solution(n, works) {\n  const heap = new MaxHeap()\n  works.forEach(v => heap.push(v))\n\n  while (n > 0) {\n    const max = heap.pop()\n    n -= 1\n    if (max === 0) return 0\n    //만일 최댓값이 0이라면 해야할 일이 없다는 뜻으로 0을 리턴하고 함수를 종료한다.\n    heap.push(max - 1)\n  }\n  return heap.heap.reduce((acc, cur) => acc + cur * cur, 0)\n}\n</code></pre>\n<h1>추가</h1>\n<p>재귀와 sort 메소드를 사용하는 방법을 생각해보았는데, sort 메소드의 경우 시간 복잡도가 NlogN이라서 효율성 테스트를 통과할 수 없었다. 코드는 아래와 같다.</p>\n<pre><code class=\"language-javascript\">function solution(n, works) {\n  function recursive(n, works) {\n    if (n === 0) return works.reduce((acc, cur) => acc + cur * cur, 0)\n\n    works.sort((a, b) => b - a)\n    if (works[0] === 0) return 0\n\n    works[0] -= 1\n    return recursive(n - 1, works)\n  }\n  return recursive(n, works)\n}\n</code></pre>","id":"e9ac13ba-e8ff-5c5d-ba3e-157a2da38f9a"},"next":{"fields":{"slug":"/알고리즘/이중우선순위큐/"},"excerpt":"문제 링크 해결 전략 이 문제의 operation은 최대 1,000,000이다. 따라서 최댓값, 최솟값을 제거해주기 위해서 굳이 힙을 사용하지 않고도 정렬을 사용해도 좋다. sort 메소드를 사용한다면 O(NlogN)으로 문제를 해결할 수 있다.\nshift 메소드의 경우 O(N)의 시간이 소모되므로, 매번 정렬을 수행하는 것보다 shift 메소드를 사용하는 것이 더 빠르다. 따라서 작성한 알고리즘은 아래와 같다. 전체 코드 추가 문제의 이름이…","frontmatter":{"date":"2022-10-06T00:00:00.000Z","description":"힙, 정렬","title":"이중우선순위큐"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42628\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>이 문제의 operation은 최대 1,000,000이다. 따라서 최댓값, 최솟값을 제거해주기 위해서 굳이 힙을 사용하지 않고도 정렬을 사용해도 좋다. sort 메소드를 사용한다면 O(NlogN)으로 문제를 해결할 수 있다.\nshift 메소드의 경우 O(N)의 시간이 소모되므로, 매번 정렬을 수행하는 것보다 shift 메소드를 사용하는 것이 더 빠르다. 따라서 작성한 알고리즘은 아래와 같다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-javascript\">function solution(operations) {\n  const arr = []\n  operations.forEach(v => {\n    const [command, strNum] = v.split(\" \")\n    const num = Number(strNum)\n    if (command === \"I\") {\n      arr.push(num)\n      arr.sort((a, b) => a - b)\n    }\n\n    if (command === \"D\") {\n      if (num === -1) {\n        arr.shift()\n      } else {\n        arr.pop()\n      }\n    }\n  })\n\n  return arr.length === 0 ? [0, 0] : [arr[arr.length - 1], arr[0]]\n}\n</code></pre>\n<h1>추가</h1>\n<p>문제의 이름이 이중우선순위큐인 만큼 한번 힙을 이용해서 문제를 해결해보도록 하겠다.</p>\n<p>새롭게 최대힙과 최소힙 기능을 하는 이중우선순위큐를 정의하는 것은 복잡하기에 최대힙, 최소힙 2개의 자료구조를 이용해서 문제를 해결하도록 한다.</p>\n<p>최대힙을 정의하고, 최소힙은 최대힙을 이용해서 구현한다. 최소힙의 경우 요소를 넣을 때 음의 형태로 변환해서 넣어준다.</p>\n<p>우리는 2개의 힙을 사용하지만, 하나의 배열로 생각할 수 있다. 그 이유는 최대힙은 최댓값을 배출하고, 최소힙은 최솟값을 배출하기 때문이다. 오름차순으로 배열이 정렬되어있다고 가정하면, 최대힙은 오른쪽에서부터 하나씩 제거되고 최소힙은 왼쪽에서부터 하나씩 제거해나간다고 할 수 있다. 따라서 우리가 고려해주어야 하는 시점은, 최대힙에서 배출하는 요소가, 최소힙에서 배출하는 요소와 동일할 때이다. 즉 하나의 배열이라고 생각했을 때 배열의 원소가 1개만 있을 때이다. 이 때의 경우 2개의 힙을 빈 배열로 초기화 시켜주면 된다. 초기화 시켜주지 않는다면 힙에 원소가 남게되고 이는 다른 결과를 초래할 수 있다. 배열의 원소가 1개 남았는지 파악하기 위해서 <code>heapCnt</code>라는 변수를 사용한다.</p>\n<p>구현한 코드는 아래와 같다.</p>\n<pre><code class=\"language-javascript\">class MaxHeap {\n  constructor() {\n    this.heap = []\n  }\n\n  swap(aIndex, bIndex) {\n    ;[this.heap[aIndex], this.heap[bIndex]] = [\n      this.heap[bIndex],\n      this.heap[aIndex],\n    ]\n  }\n\n  push(value) {\n    this.heap.push(value)\n    let currentIndex = this.heap.length - 1\n    let parentIndex = Math.floor((currentIndex - 1) / 2)\n\n    while (parentIndex >= 0 &#x26;&#x26; this.heap[parentIndex] &#x3C; value) {\n      this.swap(parentIndex, currentIndex)\n      currentIndex = parentIndex\n      parentIndex = Math.floor((currentIndex - 1) / 2)\n    }\n  }\n\n  pop() {\n    if (this.heap.length === 0) return undefined\n    if (this.heap.length === 1) return this.heap.pop()\n\n    const root = this.heap[0]\n    const end = this.heap.pop()\n    this.heap[0] = end\n\n    let currentIndex = 0\n    let leftIndex = 1\n    let rightIndex = 2\n\n    while (\n      this.heap[currentIndex] &#x3C; this.heap[leftIndex] ||\n      this.heap[currentIndex] &#x3C; this.heap[rightIndex]\n    ) {\n      if (this.heap[leftIndex] &#x3C; this.heap[rightIndex]) {\n        this.swap(currentIndex, rightIndex)\n        currentIndex = rightIndex\n      } else {\n        this.swap(currentIndex, leftIndex)\n        currentIndex = leftIndex\n      }\n      leftIndex = currentIndex * 2 + 1\n      rightIndex = currentIndex * 2 + 2\n    }\n    return root\n  }\n}\n\nfunction solution(operations) {\n  let heapCnt = 0\n  const maxHeap = new MaxHeap()\n  const minHeap = new MaxHeap()\n\n  operations.forEach(v => {\n    const [command, number] = v.split(\" \")\n    if (command === \"I\") {\n      maxHeap.push(Number(number))\n      minHeap.push(-Number(number))\n      heapCnt++\n    }\n\n    if (command === \"D\") {\n      if (heapCnt === 0) return\n      heapCnt--\n      if (Number(number) === -1) {\n        minHeap.pop()\n      } else {\n        maxHeap.pop()\n      }\n      if (heapCnt === 0) {\n        minHeap.heap = []\n        maxHeap.heap = []\n      }\n    }\n  })\n\n  if (heapCnt === 0) return [0, 0]\n  return [maxHeap.pop(), -minHeap.pop()]\n}\n</code></pre>","id":"72f660a2-4068-5add-8e8e-515c5ff3924a"}}},"staticQueryHashes":["4031756233","4237942306"],"slicesMap":{}}