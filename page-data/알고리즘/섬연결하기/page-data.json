{"componentChunkName":"component---src-templates-post-template-tsx","path":"/알고리즘/섬연결하기/","result":{"pageContext":{"node":{"fields":{"slug":"/알고리즘/섬연결하기/"},"excerpt":"문제 링크 해결 전략 최소의 비용으로 모든 섬이 통행 가능하도록 만들 때, 필요한 최소 비용을 구하라는 문제이다.\n모든 섬이 통행 가능하도록 이란 의미는 신장 트리를 만족해야 하고, 최소 비용을 구해야 하기 때문에 최소 신장 트리 구조를 만족해야 한다. 크루스칼 알고리즘은 최소 신장트리를 만족하면서 최소 거리를 구할 수 있는 알고리즘이다. 정답 코드","frontmatter":{"date":"2022-10-09T00:00:00.000Z","description":"크루스칼 알고리즘","title":"섬 연결하기"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42861\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>최소의 비용으로 모든 섬이 통행 가능하도록 만들 때, 필요한 최소 비용을 구하라는 문제이다.\n모든 섬이 통행 가능하도록 이란 의미는 신장 트리를 만족해야 하고, 최소 비용을 구해야 하기 때문에 최소 신장 트리 구조를 만족해야 한다. 크루스칼 알고리즘은 최소 신장트리를 만족하면서 최소 거리를 구할 수 있는 알고리즘이다.</p>\n<h1>정답 코드</h1>\n<pre><code class=\"language-js\">function solution(n, costs) {\n  costs.sort((a, b) => a[2] - b[2])\n\n  const parent = Array(n + 1)\n    .fill()\n    .map((_, i) => i)\n\n  const findParent = (parent, x) => {\n    if (parent[x] !== x) {\n      parent[x] = findParent(parent, parent[x])\n    }\n    return parent[x]\n  }\n\n  const union = (parent, a, b) => {\n    a = findParent(parent, a)\n    b = findParent(parent, b)\n    if (a === b) return true\n    //사이클이 발생한다면 수행하지 않음.\n    if (a > b) {\n      parent[a] = b\n    } else {\n      parent[b] = a\n    }\n    return false\n  }\n\n  let sum = 0\n  costs.forEach(([st, end, cost]) => {\n    const cycle = union(parent, st, end)\n    if (!cycle) sum += cost\n  })\n  return sum\n}\n</code></pre>","id":"d5c0ab99-0888-5a21-a96e-d7923eb663bb"},"previous":{"fields":{"slug":"/programming/git/"},"excerpt":"merge 병합은 두 브랜치의 합집합을 구하는 것이다. 병합에는 3가지 종류가 있다. merge commit 서로 다른 변경된 부분이 있을 경우, 새롭게 저장한다. fast-forward 합친 결과물이 한 커밋의 결과물과 동일할 때 새로운 상태를 만들어 줄 필요없이 상태를 바꿔주면 된다. conflict 동일한 부분이 다를 경우 충돌이 일어나게 된다. pull request 정중하게 브랜치 병합을 요청하는 것이다. 풀 리퀘 제목: 동료 개발자…","frontmatter":{"date":"2022-10-06T00:00:00.000Z","description":"merge, pull request, fork, rebase..","title":"git 사용법"},"html":"<h1>merge</h1>\n<p>병합은 두 브랜치의 합집합을 구하는 것이다. 병합에는 3가지 종류가 있다.</p>\n<ol>\n<li>merge commit\n<ul>\n<li>서로 다른 변경된 부분이 있을 경우, 새롭게 저장한다.</li>\n</ul>\n</li>\n<li>fast-forward\n<ul>\n<li>합친 결과물이 한 커밋의 결과물과 동일할 때 새로운 상태를 만들어 줄 필요없이 상태를 바꿔주면 된다.</li>\n</ul>\n</li>\n<li>conflict\n<ul>\n<li>동일한 부분이 다를 경우 충돌이 일어나게 된다.</li>\n</ul>\n</li>\n</ol>\n<h1>pull request</h1>\n<p>정중하게 브랜치 병합을 요청하는 것이다.</p>\n<ul>\n<li>풀 리퀘 제목: 동료 개발자가 한 눈에 이해하기 쉬운 제목을 적어둔다.</li>\n<li>풀 리퀘 내용: 코드를 이해하는데 도움이 되는 설명을 적어준다. 스크린샷 혹은 테스트 방법</li>\n<li>reviewers: 콕 찝어서 풀 리퀘 검토 요청, 같은 팀원 혹은 해당 기능과 연관된 동료 선택</li>\n</ul>\n<h1>fork</h1>\n<p>타인의 원본저장소를 내 계정의 원격저장소로 복사해오는 명령어이다.\n브랜치를 포함한 원본저장소의 모든 커밋 이력을 통째로 복사한다.</p>\n<h3>오픈 소스 기여 방식</h3>\n<p>원본 저장소에는 지정된 collaborators만 코드를 푸쉬할 수 있다. 오픈소스 프로젝트에서 만일 collaborators가 너무 많아진다면 저장소를 관리하는데 어려워질 것이다. 하지만 동시에 많은 개발자들에게 의견을 받고 오픈소스를 개선하고 싶은 니즈가 있다. 이럴 때 개발자는 fork를 해서 원본 저장소를 복사하고, 이곳에 커밋을 올린 다음에 원본 저장소의 소유자에게 풀 리퀘를 요청하면 원본 저장소의 소유자는 개발자의 병합 요청을 검토해서 원본 저장소에 반영한다.</p>\n<h3>원본 저장소에 풀 리퀘 보내기</h3>\n<p>new pull request 버튼을 누르고 head repository, base repository가 뜬다면 성공이다.\n풀 리퀘에 대한 설명을 적고 요청을 보낸다. 만일 원본저장소에 컨트리뷰션 가이드가 있다면 읽고 준수하도록 한다. 보통 README.md에 존재한다.</p>\n<p>풀 리퀘를 승인하는 방법은, 좌측 카테고리에 fork 탭을 클릭하고 pull requests 탭을 클릭하면 요청된 풀 리퀘들을 확인할 수 있다. 댓글만 달고 싶다면 comment를, 댓글을 달고 코드가 좋아보여 바로 병합해도 되면 approve를, 수정을 요청하고 싶으면 request changes를 선택한다.</p>\n<h1>add remote</h1>\n<p>내 원격 저장소에서 원본 저장소의 히스토리도 같이 보고싶다면, add remote를 해주면 된다. 원격 이름에는 upstream을 넣어주고 원본 저장소 주소를 복사해서 넣어주면 된다. upstream은 원본 저장소를 지칭하는 관용적 닉네임이다.</p>\n<p><code>fetch</code>를 하게 되면 원본 저장소에 있는 커밋 히스토리를 받아올 수 있다. pull과는 다른 점은 커밋 이력만 받아오기 때문에 내 코드에는 아무 영향이 없다.</p>\n<h1>rebase</h1>","id":"6a5ee1a7-b8a6-5d22-8968-6a91a6171688"},"next":{"fields":{"slug":"/programming/상속과 조합/"},"excerpt":"상속의 정의 조합의 정의 상속의 장단점 조합의 장단점 그래서 언제 상속을, 언제 조합을 사용하면 좋을까?","frontmatter":{"date":"2022-10-09T00:00:00.000Z","description":"언제 상속을, 언제 조합을 사용하면 좋을까","title":"상속과 조합"},"html":"<h1>상속의 정의</h1>\n<h1>조합의 정의</h1>\n<h1>상속의 장단점</h1>\n<h1>조합의 장단점</h1>\n<h1>그래서 언제 상속을, 언제 조합을 사용하면 좋을까?</h1>","id":"34ec3b75-65ac-5d44-a420-d82d79859b6d"}}},"staticQueryHashes":["4031756233","4237942306"],"slicesMap":{}}