{"componentChunkName":"component---src-templates-post-template-tsx","path":"/programming/상속과 조합/","result":{"pageContext":{"node":{"fields":{"slug":"/programming/상속과 조합/"},"excerpt":"상속의 정의 조합의 정의 상속의 장단점 조합의 장단점 그래서 언제 상속을, 언제 조합을 사용하면 좋을까?","frontmatter":{"date":"2022-10-09T00:00:00.000Z","description":"언제 상속을, 언제 조합을 사용하면 좋을까","title":"상속과 조합"},"html":"<h1>상속의 정의</h1>\n<h1>조합의 정의</h1>\n<h1>상속의 장단점</h1>\n<h1>조합의 장단점</h1>\n<h1>그래서 언제 상속을, 언제 조합을 사용하면 좋을까?</h1>","id":"34ec3b75-65ac-5d44-a420-d82d79859b6d"},"previous":{"fields":{"slug":"/알고리즘/여행경로/"},"excerpt":"문제 링크 해결 전략 우리는 주어진 항공권을 모두 이용해야한다. 즉 항공권을 모두 사용하는 케이스를 탐색해야한다.\n만일 가능한 경로가 2개 이상 있을 때, 알파벳 순서가 앞서는 경로를 리턴해야 하므로 BFS로 탐색하고 만족하는 값을 찾으면 탐색을 중지하도록 하겠다. 탐색하는 방법은 간단하다. 티켓 중에서 시작점이 마지막에 방문한 도시와 일치하는 티켓들을 찾고 알파벳 순서로 정렬 후 방문한다. 이 과정을 모든 티켓을 사용(방문)할 떄 까지 반복…","frontmatter":{"date":"2022-10-06T00:00:00.000Z","description":"DFS/BFS","title":"여행 경로"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/43164\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>우리는 주어진 항공권을 모두 이용해야한다. 즉 항공권을 모두 사용하는 케이스를 탐색해야한다.\n만일 가능한 경로가 2개 이상 있을 때, 알파벳 순서가 앞서는 경로를 리턴해야 하므로 BFS로 탐색하고 만족하는 값을 찾으면 탐색을 중지하도록 하겠다.</p>\n<p>탐색하는 방법은 간단하다. 티켓 중에서 시작점이 마지막에 방문한 도시와 일치하는 티켓들을 찾고 알파벳 순서로 정렬 후 방문한다. 이 과정을 모든 티켓을 사용(방문)할 떄 까지 반복한다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-javascript\">class Queue {\n  constructor() {\n    this.front = 0\n    this.rear = 0\n    this.queue = []\n  }\n\n  enqueue(data) {\n    this.queue[this.rear++] = data\n  }\n\n  dequeue() {\n    const value = this.queue[this.front]\n    delete this.queue[this.front]\n    this.front++\n    return value\n  }\n\n  size() {\n    return this.rear - this.front\n  }\n}\n\n//시작점이 마지막에 방문한 도시인 티켓들을 찾고, 알파벳 순서로 정렬하는 코드\nconst findMatchTickets = (start, tickets, visited) => {\n  const result = []\n  for (let i = 0; i &#x3C; tickets.length; i++) {\n    if (!visited[i] &#x26;&#x26; tickets[i][0] === start) {\n      result.push({ i, end: tickets[i][1] })\n    }\n  }\n  result.sort((a, b) => (a.end > b.end) - (a.end &#x3C; b.end))\n  return result\n}\n\nfunction solution(tickets) {\n  const visited = Array(tickets.length).fill(false)\n\n  const queue = new Queue()\n  queue.enqueue({ visited, path: [\"ICN\"] })\n\n  while (queue.size() > 0) {\n    const { visited, path } = queue.dequeue()\n    if (visited.every(v => v)) return path\n\n    const lastVisited = path[path.length - 1]\n    const matchedTickets = findMatchTickets(lastVisited, tickets, visited)\n\n    matchedTickets.forEach(({ i, end }) => {\n      const newVistied = [...visited]\n      newVistied[i] = true\n      queue.enqueue({ visited: newVistied, path: [...path, end] })\n    })\n  }\n}\n</code></pre>\n<h1>추가</h1>\n<p>BFS가 아닌, DFS를 이용해도 문제를 해결할 수 있다. 다만 우리는 알파벳 순서가 앞서는 경로를 리턴해야 하므로 BFS와 동일하게 알파벳 순서가 앞서는 경로를 먼저 넣어주고, 만일 모든 티켓을 방문했다면 즉 정답을 찾았다면 DFS 탐색을 중지한다.</p>\n<pre><code class=\"language-javascript\">const findMatchTickets = (start, tickets) => {\n  const result = []\n  for (let i = 0; i &#x3C; tickets.length; i++) {\n    if (tickets[i][0] === start) {\n      result.push({ i, end: tickets[i][1] })\n    }\n  }\n  result.sort((a, b) => (a.end > b.end) - (a.end &#x3C; b.end))\n  return result\n}\n\nfunction solution(tickets) {\n  let answer = null\n\n  function dfs(leftTickets, lastVisited, path) {\n    if (answer) return\n    if (leftTickets.length === 0) {\n      answer = path\n    }\n\n    findMatchTickets(lastVisited, leftTickets).forEach(({ i, end }) => {\n      dfs(\n        leftTickets.filter((_, index) => index !== i),\n        end,\n        [...path, end]\n      )\n    })\n  }\n  dfs(tickets, \"ICN\", [\"ICN\"])\n  return answer\n}\n</code></pre>","id":"777d548c-27fe-5a4a-af3b-62269fca7d6b"},"next":{"fields":{"slug":"/알고리즘/섬연결하기/"},"excerpt":"문제 링크 해결 전략 최소의 비용으로 모든 섬이 통행 가능하도록 만들 때, 필요한 최소 비용을 구하라는 문제이다.\n모든 섬이 통행 가능하도록 이란 의미는 신장 트리를 만족해야 하고, 최소 비용을 구해야 하기 때문에 최소 신장 트리 구조를 만족해야 한다. 크루스칼 알고리즘은 최소 신장트리를 만족하면서 최소 거리를 구할 수 있는 알고리즘이다. 정답 코드","frontmatter":{"date":"2022-10-09T00:00:00.000Z","description":"크루스칼 알고리즘","title":"섬 연결하기"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42861\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>최소의 비용으로 모든 섬이 통행 가능하도록 만들 때, 필요한 최소 비용을 구하라는 문제이다.\n모든 섬이 통행 가능하도록 이란 의미는 신장 트리를 만족해야 하고, 최소 비용을 구해야 하기 때문에 최소 신장 트리 구조를 만족해야 한다. 크루스칼 알고리즘은 최소 신장트리를 만족하면서 최소 거리를 구할 수 있는 알고리즘이다.</p>\n<h1>정답 코드</h1>\n<pre><code class=\"language-js\">function solution(n, costs) {\n  costs.sort((a, b) => a[2] - b[2])\n\n  const parent = Array(n + 1)\n    .fill()\n    .map((_, i) => i)\n\n  const findParent = (parent, x) => {\n    if (parent[x] !== x) {\n      parent[x] = findParent(parent, parent[x])\n    }\n    return parent[x]\n  }\n\n  const union = (parent, a, b) => {\n    a = findParent(parent, a)\n    b = findParent(parent, b)\n    if (a === b) return true\n    //사이클이 발생한다면 수행하지 않음.\n    if (a > b) {\n      parent[a] = b\n    } else {\n      parent[b] = a\n    }\n    return false\n  }\n\n  let sum = 0\n  costs.forEach(([st, end, cost]) => {\n    const cycle = union(parent, st, end)\n    if (!cycle) sum += cost\n  })\n  return sum\n}\n</code></pre>","id":"d5c0ab99-0888-5a21-a96e-d7923eb663bb"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}