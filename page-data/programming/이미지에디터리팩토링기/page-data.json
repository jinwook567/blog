{"componentChunkName":"component---src-templates-post-template-tsx","path":"/programming/이미지에디터리팩토링기/","result":{"pageContext":{"node":{"fields":{"slug":"/programming/이미지에디터리팩토링기/"},"excerpt":"프로젝트 설명 canvas api를 사용하여 웹 브라우저에서 이미지 편집 등 간단한 포토샵 기능을 사용할 수 있는 프로젝트이다.\n 이전에 위투디 프로젝트를 했을 때 구현 했었지만, 기술적으로 어려웠고 코드가 깔끔하지 않아서 언젠가 다시 만들어봐야 겠다고 생각했다. 약 1년이 지나 다시 만들어보면서 느낀 점을 기록한 글이다. 프로젝트 목표 깊게 고민하고 코드 작성하기. 키보드에 손을 올리기 전에, 검색하기 전에 깊게 고민해야한다. 이 프로젝트의…","frontmatter":{"date":"2023-01-26T00:00:00.000Z","description":"리팩토링을 하면서 나는 무엇을 느꼈는가","title":"이미지 에디터 리팩토링기"},"html":"<h1>프로젝트 설명</h1>\n<p>canvas api를 사용하여 웹 브라우저에서 이미지 편집 등 간단한 포토샵 기능을 사용할 수 있는 프로젝트이다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3b2df7da7ca8186f419f0d6e63c03c14/49832/editor.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 69.71428571428572%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAC4jAAAuIwF4pT92AAADfUlEQVR42o2SzW8bRRiHR+FSblyCEEdO5RBQb7RCQgghhHqgUiQ49A/ggMS1IkBTKlWAkDgFKkqJkagclTSfLXVJUtLEsdM0jW3F3mRnZz+c+Cter9e76894vPNDu0Q5M9Kj0e99R4/mHQ3JaRWyqxgkLbOhPaN+NqfW3sjQ0khaLo3ssspIVj0K2ctbI5JRO83hGVo6ydU3Jb362uOdIiGFqjN0WG2SfMU7V7VsbjnuwG32uNfucdtt87rTCjmyGtysu6fZbfW41wrP9G23hSPLKz/fL71EKpY3VAiF7gWv1QL8YwjfB+d9+P4AQvjw+8doOg46zSbEYHBaD3tBHnA0vLa7mSu8HArdmkusiv3WgdsBbTiiWrd8Q9eFrutC03WxbxhCCtA0QXVdGIYR9oLd8zxfCAHH69gbGWOYmE5nCAA5Bi7oeha/pbewWa6JPFPAKMUOpfh4fg6jf97FR4sLuJFIQGcMlFIoCoPTqPsD3ofT7P4nZEbhhSxrkqcKztHUNKZjN8UzrSwOdBWaomBHVfHu7xGc/2kC56NRjD1ZRV7TQBUFjDE0Gg0/GN1tde31lDZMbt+6RcbHr76+vLScmJqbQfzJktAkSWiGEQq3ZRmjD//C5YU5XJqZwtV4HHlVPRXatu3z4x7cZseOBze888cd8s21a++3Wk3A9wXvc6EwBk3XoZ8IP3n0CF/+E8PnsSmMbyRhnAhVVYVpWX6324bjtu1ErjBMfp6YIF9cuXK2WCzyoudBL5fFXi4XSoO3ek4pLi7M471oFG9Ho/h6fS0cWVGUkE636wOA1z62V7eVYfLL9evk1+++f3VlPd4dnZ3Bj4kNkU2lRE6ShKGqYluWxcUH98UH96bFO9N3xVfx9bBOKRWqqgrTNP1azYRZdxppVnuF3Pz2BxKspbW1w8sPFjH2eMnfebYt9vdlrmk6l5nKlySJ/52TeCyX4wlZ5pqqccZUbuTzXFW1fiqVQqFsmgDOkA5w5t7iyofJp1tGJJvFAlP62awkqFGBUarDKFoolWxUKo2Qw1IdetE6oYai6eLIbiNfaWArd3CJAHgxOr/86b6s1CAEBr0eFKYOVhKZya1dbTKZViLrOzSSzLBIIsMi8RSNJNPK5GaGhSRSNOB2Mh30tRvhuMHHjsUejsU3NlZnZmcj9xcXPwtq/5ceQKotkIxqkX8B3heHXwq3SPgAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"project image\"\n        title=\"project image\"\n        src=\"/static/3b2df7da7ca8186f419f0d6e63c03c14/8c557/editor.png\"\n        srcset=\"/static/3b2df7da7ca8186f419f0d6e63c03c14/4edbd/editor.png 175w,\n/static/3b2df7da7ca8186f419f0d6e63c03c14/13ae7/editor.png 350w,\n/static/3b2df7da7ca8186f419f0d6e63c03c14/8c557/editor.png 700w,\n/static/3b2df7da7ca8186f419f0d6e63c03c14/e996b/editor.png 1050w,\n/static/3b2df7da7ca8186f419f0d6e63c03c14/2cefc/editor.png 1400w,\n/static/3b2df7da7ca8186f419f0d6e63c03c14/49832/editor.png 2374w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이전에 위투디 프로젝트를 했을 때 구현 했었지만, 기술적으로 어려웠고 코드가 깔끔하지 않아서 언젠가 다시 만들어봐야 겠다고 생각했다.</p>\n<p>약 1년이 지나 다시 만들어보면서 느낀 점을 기록한 글이다.</p>\n<h1>프로젝트 목표</h1>\n<ol>\n<li>\n<p>깊게 고민하고 코드 작성하기.</p>\n<p>키보드에 손을 올리기 전에, 검색하기 전에 깊게 고민해야한다. 이 프로젝트의 목표는 단순히 구현이 아니라, 정교한 설계 및 깔끔한 코드를 작성하는 방법을 연습하기 위함이다.</p>\n</li>\n<li>\n<p>테스트 코드 작성하기.</p>\n<p>코드가 정상적으로 동작하는지 확인하기 위해서, 코드 변경이나 리팩토링 시에 사이드 이펙트를 줄이기 위해서 등 테스트 코드를 작성해야 하는 이유는 많지만 지금까지 작성하지 않았다.</p>\n<p>고객에게 테스트해보고 빠르게 요구에 맞게 변경해야해서 코드의 생존기간이 길지 않았고 무엇보다 테스트 코드를 작성하는 것이 귀찮다고 생각했다. 테스트 코드를 작성해보면서 필요성과 장점을 느껴봐야한다.</p>\n</li>\n<li>\n<p>소프트웨어 비즈니스.</p>\n<p>프로젝트의 첫 번째 목표는 개발 실력 향상이지만, 프로젝트를 활용하여 간단한 비즈니스를 할 수 있어보인다.</p>\n<p>프로젝트와 유사한 소프트웨어를 인쇄업계에 제공하는 업체가 있는데 구독 가격이 월 16만 5천원이다. 에디터의 수준도 그리 높지 않아보이고 무엇보다 인쇄업체 사장님들에게는 너무 비싸다. 또한 해당 업체의 연 매출은 약 20억으로, 잘하면 어느 정도의 고정 수입을 만들 수 있어보인다.</p>\n</li>\n</ol>\n<h1>고민했던 순간들</h1>\n<h2>컴포넌트의 props</h2>\n<p>컴포넌트에서 props가 정의되는 이유는 2가지라고 생각한다.</p>\n<ol>\n<li>\n<p>재사용성을 위해서</p>\n<p>특정 로직에 의존할수록 재사용성은 떨어진다. 컴포넌트의 재사용성을 높이기 위해서 컴포넌트 내부에 상태나 특정한 로직이 존재하지 않고, props를 통해서 주입받는다.</p>\n</li>\n<li>\n<p>관심사의 분리를 위해서</p>\n<p>컴포넌트가 비대할 경우 우리는 컴포넌트를 쪼갠다. 추상화 수준을 높이고 관심사를 분리하기 위해서이다. (하나의 컴포넌트는 하나의 관심사만 가지거나, 이들의 조합으로 이루어져야 한다)</p>\n<p>이 경우 props는 상태를 공유받기 위해서 사용된다. 쪼개진 컴포넌트는 부모 컴포넌트에 종속되며 거의 다른 컴포넌트에서 재사용되지 않는다.</p>\n</li>\n</ol>\n<p>컴포넌트에서 props를 정의할 때, 의식적으로 어떤 이유로 props가 정의되었는지 생각해야 올바르게 컴포넌트를 설계할 수 있다고 생각한다.</p>\n<p>다음 예시는 프로젝트 내에서 사용된 Stage 컴포넌트이다. Stage 컴포넌트를 통해서 왜 이런 props를 정의했는지 살펴보도록 하겠다.</p>\n<pre><code class=\"language-tsx\">import { Stage as ReactKonvaStage } from 'react-konva';\n\ntype Props = {\n  children: React.ReactNode;\n  onDownload: (ref: RefObject&#x3C;Konva.Stage>) => void;\n};\n\nfunction Stage({ children, onDownload }: Props) {\n  const { width, height } = useRecoilValue(stageSizeState);\n  const isTriggeredDownload = useRecoilValue(isTriggeredDownloadState);\n  const { deselect } = useSelect();\n  const stageRef = useRef&#x3C;Konva.Stage>(null);\n\n  useEffect(() => {\n    if (isTriggeredDownload) onDownload(stageRef);\n  }, [isTriggeredDownload]);\n\n  return (\n    &#x3C;ReactKonvaStage\n      width={width}\n      height={height}\n      onTouchStart={e => e.target === e.target.getStage() &#x26;&#x26; deselect()}\n      onMouseDown={e => e.target === e.target.getStage() &#x26;&#x26; deselect()}\n      ref={stageRef}\n    >\n      {children}\n    &#x3C;/ReactKonvaStage>\n  );\n}\n</code></pre>\n<p>Stage 컴포넌트는 ReactKonvaStage라는 컴포넌트에 필요한 상태와 이벤트 핸들러를 결합시켜주는 역할을 수행한다. ReactKonvaStage는 react-konva 라이브러리로부터 받아온 컴포넌트이며, canvas 태그를 만드는 역할을 수행한다.</p>\n<ol>\n<li>\n<p>children props를 왜 정의했는가?</p>\n<p>Stage 컴포넌트는 재사용 가능한 컴포넌트에 특정 로직이 결합된 상태인데 이 상태로 재사용 될 가능성이 있다고 생각했다.\n재사용 과정에서 Stage 컴포넌트 내부는 다양한 컴포넌트의 조합으로 이루어질 수 있기 때문에, children props를 정의함으로써 컴포넌트 사용부에서 내부 요소를 삽입해줄 수 있도록 하였다.</p>\n<p>또한 children props로 정의함에 따라서 불필요한 리렌더링도 방지할 수 있다. 만약 children props가 아닌 Stage 컴포넌트 내부에 자식 컴포넌트로 정의하면 Stage 컴포넌트의 상태 변화에 따라서 자식 컴포넌트도 리렌더링된다. 하지만 children props로 정의되어 있기에 Stage에 한정된 상태 변화라면 리렌더링이 발생하지 않는다.</p>\n</li>\n<li>\n<p>width, height, isTriggeredDownload, deselect는 왜 props로 정의하지 않았는가?</p>\n<p>해당 props를 지닌 형태의 컴포넌트가 재사용되지 않을 것이라고 생각했다. 재사용되지 않기에 props로 상태나 로직을 주입받을 필요가 없다. 재사용 가능성이 매우 낮음에도 불구하고, 재사용 가능한 컴포넌트로 제작하기 위해서 위의 값들을 props로 받는다면 섣부른 최적화라고 생각한다.</p>\n<p>또한 위 props들은 상태를 공유받기 위해서 props를 사용할 필요도 없다. recoil을 이용하여 상태에 직접 접근할 수 있기 때문이다.</p>\n<p>따라서 props를 통해 주입받는 것이 아닌, 컴포넌트 내부에 상태나 로직을 직접 정의하였다.</p>\n</li>\n<li>\n<p>onDownload props를 왜 정의했는가?</p>\n<p>onDownload props는 함수로 Stage에 직접 접근한 값인 stageRef를 받아서 다운로드를 수행한다. props로 받은 이유는 상태 공유의 단순화를 위해서이다.</p>\n<p>추후에 지원할 압축 파일로 다운로드 등의 기능을 지원하기 위해서는 많은 상태를 상위 컴포넌트로부터 props로 받아와야해서 상위 컴포넌트와 해당 컴포넌트의 복잡도가 전부 증가할 것이라고 생각했다.</p>\n<p>컴포넌트의 관심사 입장에서 보았을 때, 하나의 함수를 만들기 위해서 알 필요없는 여러가지 값들을 공유받을 필요가 있을까?, 상위 컴포넌트에서 함수를 만드는 것이 상위 컴포넌트 본인의 관심사가 아닐수도 있지만, 해당 컴포넌트의 관심사가 아닌 불필요한 상태를 공유해주는 것보다 낫다고 생각했다.</p>\n</li>\n</ol>\n<p>정리를 해보면</p>\n<ol>\n<li>\n<p>상태를 공유받기 위해서 props가 정의되었을 때, 꼭 props를 통해 받아와야 하는지 생각해봐야한다. 상태 관리를 통해서 직접 접근할수도 있고, 컴포넌트를 제공하는 커스텀훅을 사용하여 처리할수도 있다.</p>\n<p>커스텀훅을 사용하여 처리하는 방식은 다음과 같다.</p>\n<p>커스텀 훅 내부에 상태를 정의하고, 자식 컴포넌트로 들어갈 내용도 커스텀 훅 내부에 위치시키고 상태를 이용한다. 그리고 커스텀훅은 상태와 컴포넌트를 반환한다.</p>\n<p>부모 컴포넌트는 본인의 주요 관심사가 아닌 상태를 정의할 필요 없으며 커스텀 훅을 통해서 상태를 받아 이용할 수 있다. 또한 컴포넌트도 반환받기에 렌더링 시키고 싶은 부분에 위치시켜주면 된다.</p>\n</li>\n<li>\n<p>컴포넌트가 재사용되어 중복을 줄이기 위해 컴포넌트가 생성되었다면 props를 통해서 상태나 로직을 주입받아야한다.</p>\n</li>\n</ol>\n<h2>라이브러리의 타입 제어하기.</h2>\n<p>Canvas를 다루기 위해 Konva라는 라이브러리를 사용하였다. 해당 라이브러리는 Canvas 내 삽입될 수 있는 다양한 요소를 컴포넌트 형태로 제공한다.</p>\n<p>라이브러리를 활용하여 Canvas 내 요소를 다루는 방법은 2가지이다.</p>\n<ol>\n<li>라이브러리에서 제공하는 컴포넌트의 속성을(props) 변형시키는 방법. 속성이 변경되면 리렌더링 되면서 변경 사항이 적용된다</li>\n<li>useRef 훅을 사용하여 요소에 직접 접근하여 명시적으로 변형시키는 방법</li>\n</ol>\n<p>선언적인 1번 방식이 리액트스럽다 생각했다. 또한 상태를 보유함으로써 변형된 요소의 형태를 기억할 수 있고 이는 히스토리, 추후에 지원할 임시 저장 등의 기능을 손쉽게 구현 가능토록 할 것 이다.</p>\n<p>따라서 컴포넌트의 속성을 제어할 수 있도록 상태를 정의하고 요소의 변형이 필요하다면 상태를 변경시킨다.</p>\n<p>상태만 잘 다루면 된다. Canvas가 하나만 존재한다는 가정으로 생각해보겠다.\nCanvas 내부에 들어갈 수 있는 요소의 종류는 여러개이며(Image,Text,Group 등), 여러개의 요소가 들어갈 수 있다.</p>\n<p>상태의 타입을 생각해보자. 요소의 종류는 여러개이므로 유니온 타입이며 여러개의 요소가 들어갈 수 있으므로 배열 형태이다. 즉 유니온 타입이 배열의 엘리먼트로 존재하는 상황이다.</p>\n<p>유니온 타입은 라이브러리에서 제공하는 컴포넌트 타입들에 기반하여 구성되며, 각각의 타입은 라이브러리에서 제공하는 컴포넌트에 대한 타입과 거의 유사하나 일부 차이점이 있다.</p>\n<p>컴포넌트 종류에 따라서 분기를 해주어야 하기에 컴포넌트 종류에 대한 정보를 담고 있어야하며, 요소가 추가될 때 초기 위치를 구하기 위해서 라이브러리에서 제공하는 타입에서는 optional로 적용된 일부 속성을 필수로 변경시켜야 했다. 또한 일부 속성은 제거되어야 했다.</p>\n<p>유니온 타입을 구성할 때 라이브러리의 컴포넌트에 대한 타입을 최대한 이용하기로 했다. 그 이유는 당장 사용되는 속성만을 정의하는 방식은 기능 확장에 유리하지 않을 것이라고 생각했다. 이 경우에는 기능을 확장할 때, 해당 기능이 사용하는 속성에 대한 타입을 추가해줘야 한다. 하지만 기존 타입을 최대한 활용하면 기능 확장을 할 때, 필요한 타입 정보를 추가하지 않아도 된다.</p>\n<p>아래는 캔버스 내 요소가 Image일 때의 타입 예시이다.</p>\n<pre><code class=\"language-ts\">import Konva from 'konva';\n\ntype RequiredNodeConfig = Required&#x3C;\n  Pick&#x3C;Konva.NodeConfig, 'id' | 'x' | 'y' | 'scaleX' | 'scaleY'>\n>;\n\ntype RequiredImageConfig = Required&#x3C;\n  Pick&#x3C;Konva.ImageConfig, 'width' | 'height'>\n>;\n\nexport type KonvaImageConfig = RequiredNodeConfig &#x26;\n  RequiredImageConfig &#x26;\n  Omit&#x3C;RemoveIndex&#x3C;Konva.ImageConfig>, 'image'> &#x26; {\n    type: 'image';\n    url: string;\n  };\n</code></pre>\n<p>(Konva.ImageConfig는 Konva.NodeConfig를 상속받는다.)</p>\n<p>Required라는 타입 유틸리티를 사용하여 optional로 정의된 타입을 필수로 존재하도록 변경하였다.</p>\n<p>또한 DOM에 직접 접근한 정보인 image라는 속성 대신 이미지 경로인 url이라는 속성이 필요하여 Omit 유틸리티를 활용하여 타입에서 image 속성을 제거해주었다. 이 과정에서 RemoveIndex라는 타입을 정의하였는데 그 이유는 인덱스 시그니처가 라이브러리 타입에 존재하여 Omit 유틸리티가 내가 원하는대로 동작하지 않았기 때문이다. 이에 대한 내용은 트러블슈팅 파트에서 기술하겠다.</p>\n<p>마지막으로 type 속성을 추가하여 태그된 유니온 방식으로 컴포넌트의 종류를 분기할 수 있도록 하였다.</p>\n<p>아래는 최종으로 완성된 상태의 타입이다. 상태는 KonvaStage라는 타입을 지니게 된다. 배열을 순회하며 type에 따라 적절한 컴포넌트를 매칭시켜준다.</p>\n<pre><code class=\"language-ts\">export type KonvaNodeConfig =\n  | KonvaImageConfig\n  | KonvaTextConfig\n  | KonvaGroupConfig;\n\nexport type KonvaStage = KonvaNodeConfig[];\n</code></pre>\n<h2>테스트 어떻게 하면 좋을까?</h2>\n<p>테스트는 jest와 react-test-library를 이용하기로 하였다. jest는 zero-config라는 장점 때문에, react-test-library는 실제 브라우저 DOM을 기준으로 테스트를 하기에 사용자 입장을 가장 잘 반영한 테스트라고 생각되어 선택하였다.</p>\n<p>최대한 효율적으로 테스트를 하고 싶었다.\n단순히 컴포넌트에 특정 요소가 존재하는지 확인하는 테스트는 하고 싶지 않았다.</p>\n<p>테스트를 하는 가장 큰 목적은 코드 수정 시 예측하지 못한 사이드 이펙트를 확인할 수 있는 것이라고 생각하는데, 단순히 UI와 관련되어 컴포넌트에서 특정 요소를 지우거나 수정하는 것은 개발자가 충분히 예측 가능한 변화라고 생각하기 때문이다. 물론 이벤트 핸들러를 할당받은, 기능과 관련된 요소의 삭제는 전체적인 기능의 동작에 문제를 일으킬 수 있기 때문에, 존재 유무를 테스트 해야 한다고 생각한다.</p>\n<p>따라서 테스트는 내가 의도한대로 기능이 정상적으로 동작하는지를 중점으로 테스트하였고, canvas 부분은 konva 라이브러리 자체적으로 테스트가 되어있기에 canvas 내에서 사용되는 state에 대해서만 테스트를 수행했다.</p>\n<p>canvas 내의 state는 recoil로 관리되고 recoil 상태를 관리하는 로직은 hook을 사용하여 관리하였기에 따로 hooks 폴더로 추출하였다. canvas와 관련된 테스트는 hooks 폴더 내부에 존재하고, 이 외 테스트는 컴포넌트 폴더 내부에 위치시켰다.</p>\n<p>canvas 관련 테스트 코드의 효율적인 작성을 위해 hooks를 모아둔 useEditor라는 hook을 정의하였고 이를 활용하여 테스트 환경을 setup하는 함수를 정의하여 활용하였다.</p>\n<pre><code class=\"language-tsx\">function setupRenderUseEditorHook() {\n  const wrapper = ({ children }: { children: React.ReactNode }) => (\n    &#x3C;RecoilRoot>{children}&#x3C;/RecoilRoot>\n  );\n\n  const { result } = renderHook(() => useEditor(), {\n    wrapper,\n  });\n\n  act(() => {\n    result.current.setStageSize({ width: 1000, height: 1000 });\n  });\n\n  return result;\n}\n</code></pre>\n<p>컴포넌트 관련 테스트는 NHN에서 작성한 <a href=\"https://ui.toast.com/weekly-pick/ko_20210630\">React Testing Library를 이용한 선언적이고 확장 가능한 테스트</a>의 글을 참고하여 작성하였다.</p>\n<p>보통의 테스트 코드는 명령형으로 작성되는데, 위의 글을 참고하여 선언형으로 작성하면 확장이 쉬우며 가독성이 크게 상승한다.</p>\n<h1>트러블 슈팅</h1>\n<h2>인덱스 시그니처가 정의된 타입에서 Omit 유틸리티 타입을 사용하면?</h2>\n<pre><code class=\"language-ts\">type TypeWithIndexSignature = {\n  a: number;\n  b: number;\n  c: number;\n  [index: string]: number;\n};\n\ntype Omitted = Omit&#x3C;TypeWithIndexSignature, 'c'>;\n</code></pre>\n<p><code>TypeWithIndexSignature</code>에서 c라는 속성을 제거하고 싶어 Omit 유틸리티를 사용했을 때 원하는 타입을 얻을 수 있을까?</p>\n<p>내가 원하는 타입의 형태는 아래와 같다.</p>\n<pre><code class=\"language-ts\">type Omitted = {\n  a: number;\n  b: number;\n  [index: string]: number;\n};\n</code></pre>\n<p>하지만 아래와 같이 엉뚱한 타입을 얻게된다.</p>\n<pre><code class=\"language-ts\">type Omitted = {\n  [x: string]: number;\n  [x: number]: number;\n};\n</code></pre>\n<p>왜 그럴까? Exclude, Omit 유틸리티 타입에 대해서 이해해야 한다.</p>\n<pre><code class=\"language-ts\">type Exclude&#x3C;T, U> = T extends U ? never : T;\ntype Omit&#x3C;T, K extends string | number | symbol> = {\n  [P in Exclude&#x3C;keyof T, K>]: T[P];\n};\n</code></pre>\n<p>Exclude 타입에 대해서 먼저 이해해보자. Exclude는 조건부 타입으로 이루어져있다. T가 U에 할당 가능하다면, (T가 U보다 작은 범위라면) never, 아니라면 T를 반환한다. 근데 분산 조건부 타입이라는 것이 있는데 T에 유니온 태그가 할당되었고 naked type parameter라면, 모든 유니온에 대해서 조건부 타입에 대한 검증을 수행하여 타입을 반환한다.</p>\n<pre><code class=\"language-ts\">type Excluded = Exclude&#x3C;'monkey' | 'lion' | 'tiger', 'lion'>;\ntype Excluded =\n  | Exclude&#x3C;'monkey', 'lion'>\n  | Exclude&#x3C;'lion', 'lion'>\n  | Exclude&#x3C;'tiger', 'lion'>;\ntype Excluded = 'monkey' | never | 'tiger';\ntype Excluded = 'monkey' | 'tiger';\n</code></pre>\n<p>never 타입이 유니온 타입에 존재하는 것은 의미가 전혀 없기에 타입스크립트에서 해당 타입을 제거한다.</p>\n<p>Omit 타입에 대해서 이해해보자. Mapped Type에 대해서 먼저 이해해야한다. Mapped Type은 다른 타입을 바탕으로 새로운 타입을 생성할 수 있다.\nMapped Type을 활용하여 Alphabet 타입의 속성을 가지되, 속성의 타입이 모두 <code>string | number</code>인 타입을 생성해보도록 하겠다.</p>\n<pre><code class=\"language-ts\">type Alphabet = {\n  a: string;\n  b: string;\n  c: string;\n};\n\ntype Mapped = {\n  [P in keyof Alphabet]: string | number;\n};\n\ntype Mapped = {\n  a: string | number;\n  b: string | number;\n  c: string | number;\n};\n</code></pre>\n<p>Mapped Type은 키를 통해 타입을 순회하며 타입을 생성한다. <code>TypeWithIndexSignature</code>의 key 타입을 구해보자.</p>\n<pre><code class=\"language-ts\">type Key = keyof TypeWithIndexSignature;\ntype Key = 'a' | 'b' | 'c' | string | number;\ntype Key = string | number;\n</code></pre>\n<p><code>'a' | 'b' | 'c'</code>는 string이라는 타입에 포함되기 때문에 string으로 합쳐진다. 그런데 number라는 타입은 왜 갑자기 생긴걸까?</p>\n<pre><code class=\"language-ts\">type Obj = {\n  '1': string;\n  '2': string;\n};\n\nconst obj: Obj = {\n  '1': '1',\n  '2': '2',\n};\n\nobj['1']; // '1'\nobj[1]; // '1'\n</code></pre>\n<p>javascript에서 객체의 속성에 접근할 때 숫자라면 암묵적으로 문자로 형변환이 일어난다. 이는 타입스크립트에서도 동일하게 동작한다. 따라서 인덱스 시그니처에 키의 타입으로 <code>string</code>이 할당되었다면 사실은 <code>string | number</code>인 것이다.</p>\n<pre><code class=\"language-ts\">type IndexSignature = {\n  [key: string]: number;\n};\ntype IndexSignature = {\n  [key: string | number]: number;\n};\n</code></pre>\n<p>Omit 타입 유틸리티의 도출 과정을 정리해보면 아래와 같다.</p>\n<pre><code class=\"language-ts\">type TypeWithIndexSignature = {\n  a: number;\n  b: number;\n  c: number;\n  [index: string | number]: number;\n};\n\ntype Key = string | number;\ntype Excluded = Exclude&#x3C;Key, 'c'>;\n// string은 c에 할당될 수 없기에 string, number 또한 c에 할당될 수 없기에 number\ntype Excluded = string | number;\n\ntype Omitted = {\n  [P in string | number]: TypeWithIndexSignature[P];\n};\n\ntype Omitted = {\n  [x: string]: number;\n  [x: number]: number;\n};\n</code></pre>\n<p>부끄럽지만 타입 유틸리티를 사용하면서 내부 구조에 대해서 자세히 알지 못했다.\nKonva 라이브러리에서 제공하는 타입을 여러번 읽고나서야 인덱스 시그니처가 정의되있는걸 발견했고 이것 때문에 문제가 발생했나? 생각하며 실험해보았다. 실험을 통해 결국 문제를 해결했지만, 만약 내가 내부 구조를 잘 파악하고 있었다면 오류의 원인을 파악하는데 오랜 시간을 들이지 않았을 것이다.</p>\n<h1>앞으로 추가할 기능</h1>\n<ul>\n<li>모바일 환경 지원</li>\n<li>텍스트 관련 기능(폰트, 글자 크기, 색상 등)</li>\n<li>이미지 자르기</li>\n<li>이미지 수정(밝기, 필터 등)</li>\n<li>레이어 관련 기능(zIndex 변경)</li>\n<li>drag &#x26; select</li>\n<li>레이아웃 가이드라인 기능</li>\n</ul>","id":"9f269aa4-6732-59d0-af12-558fffd2072b"},"previous":{"fields":{"slug":"/tech/cdn/"},"excerpt":"cdn이란? cdn이란 content delivery network의 약어로 빠른 콘텐츠 전달을 목적으로 고안되었다.\n엔드 유저와 서버 사이의 물리적인 거리를 줄여서 콘텐츠 로딩에 소요되는 시간을 최소화한다. 전세계에 캐시 서버를 분산 배치하여 엔드 유저의 요청에 오리진 서버가 아닌 엔드 유저에 근접한 캐시 서버가 콘텐츠를 전송한다. 거리가 먼 오리진 서버가 아닌, 가까운 캐시 서버에서 콘텐츠를 받아오기 때문에 로딩에 소요되는 시간을 획기적으…","frontmatter":{"date":"2022-12-16T00:00:00.000Z","description":"cdn의 개념과 원리","title":"cdn"},"html":"<h1>cdn이란?</h1>\n<p>cdn이란 content delivery network의 약어로 빠른 콘텐츠 전달을 목적으로 고안되었다.\n엔드 유저와 서버 사이의 물리적인 거리를 줄여서 콘텐츠 로딩에 소요되는 시간을 최소화한다.</p>\n<p>전세계에 캐시 서버를 분산 배치하여 엔드 유저의 요청에 <strong>오리진 서버가 아닌 엔드 유저에 근접한 캐시 서버가 콘텐츠를 전송한다.</strong> 거리가 먼 오리진 서버가 아닌, 가까운 캐시 서버에서 콘텐츠를 받아오기 때문에 로딩에 소요되는 시간을 획기적으로 줄일 수 있는 것이다.</p>\n<p>예시로 캐나다에 있는 유저가 한국에 있는 서비스에 접근하다면, 캐나다에 위치한 캐시 서버에서 캐싱된 콘텐츠를 전송하여 빠르게 콘텐츠를 받아올 수 있다.</p>\n<h1>cdn 적용 유무에 따른 속도 차이</h1>\n<p>속도 차이가 얼마나 나는지 궁금해서 직접 실험을 해봤다.\nAWS EC2 인스턴스를 각각 서울, 미국 버지니아 북부 지역에 생성하였고 서울에 위치하는 S3 버킷의 동영상을 다운로드 받아봤다. CDN은 AWS Cloudfront 서비스를 이용했다.</p>\n<p>서울에 위치하는 EC2에서 실험을 해봤을 때 cdn 적용 유무에 따라 차이가 없었다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2351b1f16beacc9b83348cc7abefdafe/a71c9/seoul.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 9.714285714285714%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAUUlEQVR42o3LzQZAIRRF4ZNUND4a9UNE0fu/3ro0SMM7+Fg2W/bejDFYazHnpPdOa41SCjlnYoyIyH+1VlJKqOo5G2Pw3l8hhOPdXs6529ZaPsQnLUzWlYKqAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"서울 리전 s3,cdn\"\n        title=\"서울 리전 s3,cdn\"\n        src=\"/static/2351b1f16beacc9b83348cc7abefdafe/8c557/seoul.png\"\n        srcset=\"/static/2351b1f16beacc9b83348cc7abefdafe/4edbd/seoul.png 175w,\n/static/2351b1f16beacc9b83348cc7abefdafe/13ae7/seoul.png 350w,\n/static/2351b1f16beacc9b83348cc7abefdafe/8c557/seoul.png 700w,\n/static/2351b1f16beacc9b83348cc7abefdafe/e996b/seoul.png 1050w,\n/static/2351b1f16beacc9b83348cc7abefdafe/2cefc/seoul.png 1400w,\n/static/2351b1f16beacc9b83348cc7abefdafe/a71c9/seoul.png 3480w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\ncdn이 적용되었을 때와 적용되지 않았을 때 0.7s로 동일하였다. 위의 예시는 cdn을 적용하였을 때 다운로드 속도이다.</p>\n<p>미국 버지니아 북부 지역에서 실험을 해봤을 때는 cdn 적용 유무에 따라 유의미한 차이가 있었다.</p>\n<ol>\n<li>\n<p>버지니아 리전에서 cdn이 아닌 S3(오리진 서버)로 직접 접속하여 다운 받았을 떄\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1a4da759948b10a591da3d63c12399c5/c7b13/us_s3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 9.714285714285714%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAXklEQVR42m2NOwoAIRBDB/yitYKVyqAieP/rZdkBi4UtHi+BQOicgzEG9t5Ya2HOidYaeu8CM0svpSDGCK01lFIgon9qrcg5I6WEEIKMnXPw3n988+3GGFhrxTe/Rw9way7GCavXkwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"버지니아 리전 s3\"\n        title=\"버지니아 리전 s3\"\n        src=\"/static/1a4da759948b10a591da3d63c12399c5/8c557/us_s3.png\"\n        srcset=\"/static/1a4da759948b10a591da3d63c12399c5/4edbd/us_s3.png 175w,\n/static/1a4da759948b10a591da3d63c12399c5/13ae7/us_s3.png 350w,\n/static/1a4da759948b10a591da3d63c12399c5/8c557/us_s3.png 700w,\n/static/1a4da759948b10a591da3d63c12399c5/e996b/us_s3.png 1050w,\n/static/1a4da759948b10a591da3d63c12399c5/2cefc/us_s3.png 1400w,\n/static/1a4da759948b10a591da3d63c12399c5/c7b13/us_s3.png 3468w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n17초가 걸렸다.</p>\n</li>\n<li>\n<p>버지니아 리전에서 cdn을 적용하여 처음 다운로드 받았을 때\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4d8436a685f58963b4aee2e2b409e058/f9b4f/us_cdn.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 9.714285714285714%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAUElEQVR42o2LMQoAIRDEFlzF1kpBEBcU/f8Hc5xgeXBFmBQZmXOy1mLvzRgDM6P3TmuNnDOqioj8p9ZKKYWU0jl774kxEkI4e/2Lt7/unOMBoCEtCkYfB3UAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"버지니아 리전 cdn 초기\"\n        title=\"버지니아 리전 cdn 초기\"\n        src=\"/static/4d8436a685f58963b4aee2e2b409e058/8c557/us_cdn.png\"\n        srcset=\"/static/4d8436a685f58963b4aee2e2b409e058/4edbd/us_cdn.png 175w,\n/static/4d8436a685f58963b4aee2e2b409e058/13ae7/us_cdn.png 350w,\n/static/4d8436a685f58963b4aee2e2b409e058/8c557/us_cdn.png 700w,\n/static/4d8436a685f58963b4aee2e2b409e058/e996b/us_cdn.png 1050w,\n/static/4d8436a685f58963b4aee2e2b409e058/2cefc/us_cdn.png 1400w,\n/static/4d8436a685f58963b4aee2e2b409e058/f9b4f/us_cdn.png 3470w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n4.4초가 걸렸다.</p>\n</li>\n<li>\n<p>버지니아 리전에서 cdn을 적용하여 두번 째 다운로드 받았을 때(캐싱된 상태)\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9ed44162e21f1f2b6bf14f0f06b52e17/8b833/us_cdn_cached.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 13.142857142857142%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAYklEQVR42pXMuwrAIBQD0Cv4GhQHUVHBwcXB//++FC+0Y2mHAyGEUIwRKSWUUtBaY2MM9N7hvYcQAkT03VoLe2/MOVFr5eOcM3POQUr57zCEAGvtU2itoZRiJx/GmFf37rgAtp9CChu8zbcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"버지니아 리전 cdn cached\"\n        title=\"버지니아 리전 cdn cached\"\n        src=\"/static/9ed44162e21f1f2b6bf14f0f06b52e17/8c557/us_cdn_cached.png\"\n        srcset=\"/static/9ed44162e21f1f2b6bf14f0f06b52e17/4edbd/us_cdn_cached.png 175w,\n/static/9ed44162e21f1f2b6bf14f0f06b52e17/13ae7/us_cdn_cached.png 350w,\n/static/9ed44162e21f1f2b6bf14f0f06b52e17/8c557/us_cdn_cached.png 700w,\n/static/9ed44162e21f1f2b6bf14f0f06b52e17/e996b/us_cdn_cached.png 1050w,\n/static/9ed44162e21f1f2b6bf14f0f06b52e17/2cefc/us_cdn_cached.png 1400w,\n/static/9ed44162e21f1f2b6bf14f0f06b52e17/8b833/us_cdn_cached.png 3476w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n0.5초가 걸렸다.</p>\n</li>\n</ol>\n<p>우선 서울에서 서울에 위치하는 오리진 서버로부터 다운로드 받았을 때와 미국에서 서울에 위치하는 오리진 서버로부터 다운로드 받았을 때의 차이를 비교해본다.</p>\n<p>17초와 0.7초로 매우 많이 차이가 난다는 것을 알 수 있다. 서버와의 물리적인 거리가 멀어질수록 전송 속도가 느려진다는 것을 파악했다.</p>\n<p>이번에는 미국에서 오리진 서버로부터 다운로드 받았을 떄와 cdn을 적용했을 때 차이를 비교해본다.</p>\n<ol>\n<li>\n<p>1번 케이스 vs 3번 케이스</p>\n<p>왜 cdn을 적용해야 하는지 보여준다. 17초와 0.5초로 속도 차이가 매우 큰 것을 알 수 있다. 전세계를 대상으로 하는 서비스라면 cdn을 적용하는게 훨씬 좋은 사용자 경험을 제공할 것이다.</p>\n</li>\n<li>\n<p>2번 케이스 vs 3번 케이스</p>\n<p>캐시 서버에 콘텐츠가 캐싱이 되어 있지 않을 때와 캐싱이 되어 있을 때 비교이다. 2번 케이스의 경우 캐시 서버에 콘텐츠가 없어서 오리진 서버로부터 콘텐츠를 가져와서 캐싱 후 요청에 응답한다. 이를 cache miss라고 한다. 3번 케이스의 경우 캐싱이 된 상태이므로 오리진 서버로부터 콘텐츠를 요청하지 않고 바로 캐시 서버에서 응답한다. 이를 cache hit라고 한다. cache hit의 경우 오리진 서버를 거치지 않기 때문에 속도가 더 빠르다.</p>\n</li>\n<li>\n<p>1번 케이스 vs 2번 케이스</p>\n<p>1번 케이스와 2번 케이스 모두 오리진 서버로부터 데이터를 요청한다. 하지만 cdn을 이용하는 2번 케이스의 경우 1번 케이스 대비 약 13초나 빠르게 콘텐츠를 다운로드 하였다. 이번 비교를 통해서 캐싱된 콘텐츠를 반환하는 것이 아닌 매번 오리진을 거쳐야 하는 동적인 콘텐츠를 전달할 때도 cdn을 사용하면 좋다는 것을 알 수 있다. 어떻게 이런 일이 가능한 것일까?</p>\n<p>우리가 잘아는 KT와 같은 ISP(Internet Service Provider)들 간의 연결(ISP-ISP)은 경제적인 논리에 의해서 이루어져 있다. 따라서 항상 최적화된 라우팅 경로를 제공하는 것은 아니다.\n하지만 전세계에 깔린 cdn 서버들은 많은 네트워크 통신을 하다보니 많은 데이터가 쌓이게 되었고 최적화된 라우팅 경로를 파악하여 제공할 수 있게 되었다. cdn은 라우팅을 최적화하여 다운로드 시간을 단축시킨다.</p>\n<p>AWS의 Cloudfront의 경우에는 원본과의 지속적인 유지, gzip 압축을 사용함으로써 시간을 추가적으로 단축한다고 한다. 원본과의 지속적인 유지란, connectionless라는 HTTP의 특징과 반하는 개념으로 콘텐츠를 다운로드 받고도 지속적으로 연결을 유지하는 것을 의미한다. IP 기반의 네트워크를 통해서 TCP/IP 연결을 하기 위해서는 3 way handshake 과정을 거쳐야 하는데 이 과정에 필요한 패킷 사이즈는 크지 않아서 사실 큰 오버헤드는 아니다. 하지만 거리가 멀어질수록 round-trip time이 길어짐으로써 큰 오버헤드가 될 수 있다. 원본과의 유지를 지속함으로써 초기 연결에 필요한 시간을 세이브 할 수 있다. 초당 요청 건수가 많을수록 큰 효과를 누릴 수 있다.</p>\n<p>gzip은 전송되는 데이터 크기를 줄여서 트래픽을 줄일 수 있다. 데이터를 더 짧은 시간안에 전송할 뿐만 아니라 데이터 전송 비용도 절감할 수 있다.</p>\n</li>\n</ol>\n<h1>cdn의 속도 이외의 기능</h1>\n<p>cdn을 활용하면 콘텐츠를 빠르게 전달한다는 장점 이외에도 요청을 여러개의 서버로 분산시킬 수 있으므로 대역폭 소비를 줄이며 안정적인 서비스 제공이 가능하다.</p>\n<p>극단적인 예시로는 DDOS 공격에 대한 방어인데, DDOS 공격이란 좀비 pc를 사용하여 특정 서비스에 엄청난 트래픽을 발생시켜서 서비스를 무력화 시키는 것을 말한다.</p>\n<p>CDN이 요청을 분산하여 오리진 서버에 미치는 영향을 줄임으로써 트래픽 급증에 대처할 수 있다. 만일 한국 캐시 서버의 요청이 너무 많다면, 옆에 도쿄로 분산시키고, 도쿄도 많다면 홍콩으로 분산시키고.. 이러한 방식으로 전세계에 배치된 캐시 서버를 활용하여 요청을 분산시킨다. 또한 사용자 위치에 따라 접근을 제어하거나 너무 빠르거나 느린 요청을 차단함으로써 요청을 줄인다고 한다.</p>\n<h1>캐싱 관리</h1>\n<h2>캐싱 만료 주기</h2>\n<p>CDN 서비스를 이용할 때 기본적으로 캐싱의 만료 주기(TTL)를 설정할 수 있다.</p>\n<p>요청을 받았을 때, 캐시 서버에 저장된 콘텐츠가 만료되었다면 캐시 서버는 원본 서버에 데이터가 변경되었는지 유효성을 검증한다. 변경되지 않았다면 HTTP 304(not modified) 응답을 받게되고 캐싱으로 저장된 콘텐츠를 수정하지 않고 TTL만 갱신하여 요청에 응답한다. 이를 Cache Refresh Hit이라고 한다. 만일 변경되었다는 HTTP 200 응답을 받게되면 오리진 서버로부터 콘텐츠를 다운로드받고 해당 콘텐츠로 캐싱을 갱신하여 요청에 응답한다. 이를 Cache Refresh Miss라고 한다.</p>\n<h2>캐싱의 만료 주기가 끝나기 전에 콘텐츠 수정이 일어난다면?</h2>\n<p>캐싱의 만료 주기가 끝나기 전에, 콘텐츠의 수정이 일어나게 된다면 캐시 서버는 변경되기 전의 콘텐츠를 제공할 것이다.</p>\n<p>위와 같은 문제는 2가지 전략으로 해결할 수 있다.</p>\n<ol>\n<li>\n<p>캐시 서버에 캐싱된 콘텐츠를 강제로 삭제한다.</p>\n<p>캐싱된 콘텐츠를 강제로 삭제함으로써 캐시 서버는 오리진 서버에 새롭게 콘텐츠를 요청하여 받아온다. 만일 캐싱된 콘텐츠가 사용령이 많다면 순간적으로 오리진 서버에 부하가 올 수 있으므로 사용에 유의해야 한다. 또한 사용자 단의(브라우저 등) 로컬 캐시된 콘텐츠의 갱신을 보장하지 않는다.</p>\n</li>\n<li>\n<p>콘텐츠를 다른 이름으로 저장한다.</p>\n<p>이 방식은 사용자 단의 콘텐츠의 최신성을 보장해줄 수 있다. AWS에서는 파일을 버전관리 함으로써 이 전략을 수행하도록 권장한다.</p>\n<p>캐싱의 기준은 콘텐츠가 아닌 URL 기반이기 때문에 쿼리스트링이 추가될 수 있다. 동일 콘텐츠임에도 불구하고 쿼리스트링이 달라짐으로써 캐싱이 안될수도 있으니 잘 설정해주어야 한다.</p>\n</li>\n</ol>\n<h1>어떻게 가까운 곳을 찾아서 전달할 수 있을까?</h1>\n<p>CDN은 엔드 유저의 요청에서 가장 가까운 캐시 서버의 캐싱된 콘텐츠를 반환함으로써 빠른 다운로드 속도를 제공한다고 했다. 그렇다면 어떻게 엔드 유저와 가까운 캐시 서버를 알 수 있을까? 이는 라우팅의 원리를 알아야한다.</p>\n<h2>라우팅 테이블</h2>\n<p>라우팅은 네트워크에서 경로를 선택하는 프로세스이다. 쉽게 말하면 라우터에서 라우터로 이동하면서 목적지 주소를 찾는 과정을 말한다. 목적지 주소가 라우터와 동일한 네트워크에 있을 경우 패킷을 직접 전달하는 것으로 마무리된다.</p>\n<p>라우터에서 라우터로 이동할 때 라우팅 테이블이라는 표를 보고 움직이게 된다. 라우팅 테이블에는 최적의 경로로 도달할 수 있는 다음 라우터의 네트워크 주소만 명시되어있다.</p>\n<p>동일한 네트워크에 연결된 컴퓨터 하나하나 모두 명시하는게 아니라 네트워크 주소만 명시하는 이유는 테이블의 크기를 줄이기 위함이다. 테이블 크기를 줄임으로써 검색도 빨라지고 메모리 낭비도 줄일 수 있다.</p>\n<p>라우팅 테이블에는 모든 경로에 대한 네트워크 주소가 들어가있는게 아니고 다음 라우터에 대한 네트워크 주소만 들어가있다. 그 이유는 다음 라우터 네트워크 주소만 들어가 있어도 차례대로 이동하면서 목적지에 도착할 수 있기 때문이다. 굳이 모든 경로에 대한 네트워크 주소를 명시함으로써 메모리 낭비를 할 필요가 없다.</p>\n<h3>그렇다면 라우팅 테이블은 어떻게 구성되는 것일까?</h3>\n<p>라우팅 테이블을 구성하는 방법은 2가지이다.</p>\n<ol>\n<li>\n<p>정적 라우팅 테이블</p>\n<p>직접 사용자가 라우팅 테이블을 입력해준다.\n네트워크에 붙어 있는 마지막 컴퓨터들이 정적 라우팅을 하는 경우가 대부분이다. 혹은 보안적으로 어떤 목적이 있거나.</p>\n</li>\n<li>\n<p>동적 라우팅 테이블</p>\n<p>라우팅 프로토콜에 의해서 동적으로 구성된다.</p>\n<p>유니캐스트 라우팅 프로토콜: 일대일 통신을 말한다. 보내는 사람도 하나, 받는 사람도 하나</p>\n<p>머맅캐스트 라우팅 프로토콜: 보내는 사람은 하나인데 받는 사람 여려명</p>\n</li>\n</ol>\n<h2>라우팅 프로토콜</h2>\n<p>최적화된 라우팅 테이블을 만드는데 라우팅 프로토콜이 사용된다.</p>\n<p>라우팅 프로토콜은 내부 게이트웨이 프로토콜과 외부 게이트웨이 프로토콜로 나누어진다. 나누는 기준은 AS이며 AS(Autonomous System)는 독립적인 네트워크로 라우팅 정보를 주고 받을 수 있는 영역이며 2가지 특징을 가진다.</p>\n<ol>\n<li>AS 내의 라우터들은 서로 동일한 라우팅 프로토콜을 사용한다.</li>\n<li>AS 내의 라우터들은 한 조직에 의해 관리된다.</li>\n</ol>\n<h3>내부 프로토콜</h3>\n<p>내부 프로토콜에는 Distance Vector 알고리즘, Link State 알고리즘이 사용된다.</p>\n<ol>\n<li>\n<p>Distance Vector 알고리즘</p>\n<p>최소 경로를 계산하기 위해서 벨만 포드 알고리즘을 사용한다.\n벨만 포드 알고리즘을 사용하는 이유는 음의 간선이 존재해서가 아니라 본인이 가진 네트워크 정보를 이웃하고만 교환하는 방식이기 떄문이라고 생각한다.</p>\n</li>\n<li>\n<p>Link State 알고리즘</p>\n<p>본인으로부터 모든 목적지까지 가는 최단 경로를 구한다. 다익스트라 알고리즘을 사용한다.\n다익스트라 알고리즘을 사용하는 이유는 이웃 이외에도 모든 노드와 네트워크 정보를 교환하기 때문이다. 모든 정보를 알고있다면 다익스트라 알고리즘이 시간복잡도에서 효율적이다.</p>\n</li>\n</ol>\n<h3>외부 프로토콜</h3>\n<p>외부 프로토콜은 경로 벡터 라우팅이라는 방식에 의해서 수행된다.</p>\n<p>경로 벡터 라우팅에는 목적지 네트워크, 다음 라우터, 경로명이 명시된다. Distance Vector 알고리즘 기반으로 작동하고 looping 되는 경로를 방지하기 위해 모든 path를 명시한다.</p>","id":"adb2021c-4b9f-509c-b3ad-0a32b7ca123f"},"next":{"fields":{"slug":"/algorithm/택배배달과수거하기/"},"excerpt":"문제 링크 해결 전략 우리가 구해야 하는 것은 트럭의 최소 이동 거리이다.\n트럭이 최소의 거리로 모든 상자를 배달하고 수거하기 위해서는, 출발지로부터 가장 거리가 먼 집부터 처리해야한다. 출발지로부터 가장 거리가 먼 집부터 처리하는 이유는, 짧은 거리는 긴 거리에 포함이 되기 때문에 짧은 거리에 있는 집을 먼저 처리해도 긴 거리에 있는 집을 가기 위해서는 동일한 루트를 반복해서 가야한다.\n하지만 긴 거리에 있는 집부터 처리하면 반복해서 가야하…","frontmatter":{"date":"2023-02-09T00:00:00.000Z","description":"그리디","title":"택배 배달과 수거하기"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/150369\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>우리가 구해야 하는 것은 트럭의 최소 이동 거리이다.\n트럭이 최소의 거리로 모든 상자를 배달하고 수거하기 위해서는, 출발지로부터 가장 거리가 먼 집부터 처리해야한다.</p>\n<p>출발지로부터 가장 거리가 먼 집부터 처리하는 이유는, 짧은 거리는 긴 거리에 포함이 되기 때문에 짧은 거리에 있는 집을 먼저 처리해도 긴 거리에 있는 집을 가기 위해서는 동일한 루트를 반복해서 가야한다.\n하지만 긴 거리에 있는 집부터 처리하면 반복해서 가야하는 루트를 줄일 수 있다.</p>\n<p>그리고 배달과 수거는 병렬적으로 생각해도 좋다. 배달이든 수거든 가장 먼 도착지까지 갈 때, 배달을 완료하고 출발지로 돌아올 때 수거를 완료하면 된다.</p>\n<p>배달과 수거를 가장 거리가 먼 집부터 완료하는 알고리즘을 설계하면 된다.</p>\n<ol>\n<li>배달이든 수거든 관계없이 해야할 가장 먼 집을 찾고, 해당 집까지의 거리*2를 누적 거리에 더해준다.</li>\n<li>배열의 마지막 요소부터 cap의 한도 내에서 물건의 개수를 줄여준다. 배달과 수거 각각 수행한다.</li>\n<li>배열의 모든 요소가 0(더이상 배달과 수거를 할 필요가 없을 때)일 때까지 반복한다.</li>\n</ol>\n<p>시간 복잡도를 생각해봐야 한다.</p>\n<p>배열의 모든 요소를 순회하며 요소가 0인지 확인해보는 알고리즘은 최대 <code>100,000 * 100 * 100,000</code> 번 연산을 수행해야한다. (cap=1, n=100,000, delivers 모든 원소 50, pickups 모든 원소 50)</p>\n<p>문제의 특성을 살펴보면, 가장 거리가 먼 집을 우선으로 방문함으로써 반복해서 가야하는 루트를 줄일 수 있다고 하였다.\n그렇다면 가장 마지막 집의 위치 정보를 기억하고 있다면, 배열의 마지막 요소부터 물건의 개수를 줄이는 알고리즘의 시간 복잡도를 줄일 수 있다. (배열의 마지막 요소가 아닌, 기억하고 있는 위치부터 수행하면 되므로) 또한 마지막 집의 위치 정보가 배달과 수거 전부 0이라면 모든 배다과 수거를 완료한 것으로 생각할 수 있다. 이 방식은 시간 복잡도를 초과하지 않는다. <code>100,000 * 100</code></p>\n<h1>정답 코드</h1>\n<pre><code class=\"language-js\">function process(arr, index, cap) {\n  while (true) {\n    if (index === 0) break;\n    if (arr[index - 1] > 0 &#x26;&#x26; cap === 0) break;\n\n    if (cap >= arr[index - 1]) {\n      cap -= arr[index - 1];\n      arr[index - 1] = 0;\n      index--;\n    } else {\n      arr[index - 1] -= cap;\n      cap = 0;\n    }\n  }\n  return index;\n}\n\nconst getInitialLast = arr =>\n  arr.reduce((acc, cur, index) => (cur > 0 ? index + 1 : acc), 0);\n\nfunction solution(cap, n, deliveries, pickups) {\n  let deliver_last = getInitialLast(delivers);\n  let pickup_last = getInitialLast(pickups);\n  let distance = 0;\n\n  while (deliver_last > 0 || pickup_last > 0) {\n    distance += Math.max(deliver_last, pickup_last) * 2;\n\n    deliver_last = process(deliveries, deliver_last, cap);\n    pickup_last = process(pickups, pickup_last, cap);\n  }\n\n  return distance;\n}\n</code></pre>","id":"bf3ea1e2-fb92-590b-8aef-3719dc24436d"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}