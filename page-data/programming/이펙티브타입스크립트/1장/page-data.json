{"componentChunkName":"component---src-templates-post-template-tsx","path":"/programming/이펙티브타입스크립트/1장/","result":{"pageContext":{"node":{"fields":{"slug":"/programming/이펙티브타입스크립트/1장/"},"excerpt":"타입스크립트와 자바스크립트의 관계 타입스크립트는 자바스크립트의 상위 집합이다. 즉 모든 자바스크립트 프로그램은 타입스크립트 프로그램이다. 하지만 타입스크립트의 경우 타입 선언 등 별도의 문법을 가지고 있기 때문에 유효한 자바스크립트 프로그램이라고는 할 수 없다. 자바스크립트가 타입스크립트 프로그램이기에 마이그레이션 하는데 큰 이점을 가진다. 타입 시스템 타입스크립트는 자바스크립트에 타입 시스템을 더한 것이다. 타입 시스템의 목표 중 하나는 런…","frontmatter":{"date":"2022-10-17T00:00:00.000Z","description":"타입스크립트 알아보기","title":"이펙티브 타입스크립트 1장"},"html":"<h1>타입스크립트와 자바스크립트의 관계</h1>\n<p>타입스크립트는 자바스크립트의 상위 집합이다. 즉 모든 자바스크립트 프로그램은 타입스크립트 프로그램이다. 하지만 타입스크립트의 경우 타입 선언 등 별도의 문법을 가지고 있기 때문에 유효한 자바스크립트 프로그램이라고는 할 수 없다. 자바스크립트가 타입스크립트 프로그램이기에 마이그레이션 하는데 큰 이점을 가진다.</p>\n<h2>타입 시스템</h2>\n<p>타입스크립트는 자바스크립트에 타입 시스템을 더한 것이다. 타입 시스템의 목표 중 하나는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것이다. '정적'타입 시스템이라는 것은 바로 이런 특징을 말하는 것이다. 하지만 타입 체커가 모든 오류를 찾아내지는 않으니 유의해야한다.</p>\n<p>타입을 선언하지 않아도 타입스크립트는 오류는 발생시키지 않지만 의도와 다르게 동작하는 코드를 찾아내기도 한다. 하지만 정확하지 않기에 명시적으로 타입을 선언해야한다.</p>\n<pre><code class=\"language-typescript\">interface State {\n  name: string\n  capital: string\n}\n\nconst states: State[] = [\n  { name: \"Alaska\", capital: \"Juneau\" },\n  { name: \"Korea\", capitol: \"Seoul\" },\n]\n//만일 State 타입을 명시하지 않았다면, 에러를 발생시키지 않지만 State 타입을 명시함으로써 capitol 속성 부분에 에러를 표시해준다. 이는 잠재적으로 생길 수 있는 문제를 해결해준다.\n</code></pre>\n<p>타입스크립트 타입 시스템은 자바스크립트의 런타임 동작을 모델링한다.</p>\n<pre><code class=\"language-ts\">const x = 2 + \"3\"\nconst a = null + 7\nconst b = [] + 12\nalert(\"hi\", \"ts\")\n</code></pre>\n<p>변수 x의 경우 문자열 \"23\"이 되는 자바스크립트 런타임 동작으로 모델링된다. 하지만 변수 a,b, alert 함수의 경우에 자바스크립에서는 정상적으로 동작하지만 타입스크립에서는 타입 체커가 문제점을 표시한다.</p>\n<p>이러한 불명확함이 타입스크립트를 사용하는데 의문이 들 수 있지만, 타입스크립트를 사용하면 오류가 적은 프로그램을 만들 수 있다. <code>null+7</code>과 같은 코드가 당연하다고 생각된다면 타입스크립트를 안쓰는게 낫다.</p>\n<h1>타입스크립트 설정 이해하기</h1>\n<pre><code class=\"language-ts\">function sum(a, b) {\n  return a + b\n}\n</code></pre>\n<p>다음 함수가 타입스크립트에서 오류를 발생시키는지, 아닌지 알 수 있을까? 해당 프로그램의 타입스크립트 설정을 보지 않는 이상 알 수 없다. 설정은 커맨드라인에서도 사용할 수 있지만, 설정 파일을 만들어서 동료 개발자나 다른 도구들이 알 수 있도록 해야한다.</p>\n<h2>주요 설정</h2>\n<h3>noImplicitAny</h3>\n<p>noImplicitAny는 변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어한다.\n위의 <code>sum</code> 함수는 noImplicitAny가 설정되었다면 유효하지 않다. a,b가 any 타입으로 간주되기 때문이다. 되도록이면 noImplicitAny로 설정하도록 하고 새 프로젝트를 한다면 꼭 noImplicitAny로 설정하도록 한다.</p>\n<h3>strictNullChecks</h3>\n<p>null과 undefined가 모든 타입에서 허용되는지 확인하는 설정이다.</p>\n<pre><code class=\"language-ts\">const x: number = null\n</code></pre>\n<p>위의 예시는 정상이다. 하지만 strictNullChecks 설정하면 오류가 발생한다.</p>\n<pre><code class=\"language-ts\">const x: number | null = null\n</code></pre>\n<p>만일 null을 허용하려면 위와같이 명시적으로 null을 타입에 넣어주어야 한다.</p>\n<p>만일 null을 허용하지 않으려면 null을 체크하는 코드나 단언문을 추가해야한다.</p>\n<pre><code class=\"language-ts\">const el = document.getElementById(\"status\")\n//el.textContent = \"ready'; -> 개체가 null인 것 같습니다.\n\nif (el) {\n  el.textContent = \"ready\"\n}\nel!.textContent = \"ready\"\n</code></pre>\n<p>strictNullChecks 설정은 null, undefined 관련된 오류를 잡는데 큰 도움을 주지만 코드 작성을 어렵게 한다. 새 프로젝트를 시작한다면 가급적 사용을 권장하고 처음이거나 마이그레이션 중이라면 설정하지 않아도 좋다.</p>\n<h3>strict</h3>\n<p>모든 체크를 설정하고 싶다면 strict 설정을 하면 된다. 타입스크립트에 strict 설정을 하면 대부분 오류를 잡아낸다.</p>\n<h1>코드 생성과 타입이 관계없음을 이해하기</h1>\n<p>타입스크립트의 컴파일러는 두 가지 역할을 수행한다.</p>\n<ol>\n<li>최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일 한다.</li>\n<li>코드의 타입 오류를 체크한다.</li>\n</ol>\n<p>여기서 주의해야 할 점은 두 가지가 완벽히 독립적이라는 점이다. <strong>타입스크립트가 자바스크립트로 변환될 때 타입은 영향을 미치지 않는다. 타입과 관련된 코드는 전부 사라진다!</strong></p>\n<h2>독립적이기에 생기는 특징</h2>\n<h3>1. 타입 오류가 있는 코드도 컴파일 가능</h3>\n<p>타입 오류가 있어도 컴파일 된다는 것은 엉성해보이지만, 실제로는 도움이 되는 경우가 있다. 애플리케이션에서 어떤 부분이 오류가 발생했다고 했을 때, 컴파일이 가능하기에 다른 부분에 대한 테스트가 가능하다.</p>\n<p>만일 오류가 있을 때 컴파일 하지 않으려면 noEmitOnError를 설정하면 된다.</p>\n<h3>2. 런타임에는 타입 체크가 불가능하다.</h3>\n<p>만일 어떤 코드에서 <code>instanceof</code>와 타입을 사용하여 분기를 만든다면, 런타임 환경에서 타입은 사라지기에 전혀 유효하지 않다. 런타임에 타입 정보를 유지하는 방법으로는 3가지가 있다.</p>\n<ol>\n<li>\n<p>속성이 존재하는지 체크 - 속성 체크는 런타임에 접근 가능한 값에만 관련되지만, 타입 체커 역시 보정해주기 때문에 오류가 사라진다.</p>\n</li>\n<li>\n<p>타입 정보를 명시적으로 저장하는 태그 기법</p>\n<pre><code class=\"language-ts\">interface Square {\n  kind: \"square\"\n  width: number\n}\n\ninterface Rectangle {\n  kind: \"rectangle\"\n  width: number\n  height: number\n}\n</code></pre>\n<p>kind 속성을 추가해서, 명시해준다. 타입스크립트에서 흔하게 볼 수 있는 패턴이다.</p>\n</li>\n<li>\n<p>타입을 클래스로 만든다.</p>\n<pre><code class=\"language-ts\">class Square {\n  constructor(public width: number) {}\n}\nclass Rectangle extends Square {\n  constructor(public width: number, public height: number) {\n    super(width)\n  }\n}\ntype Shape = Square | Rectangle\n\nfunction calculateArea(shape: Shape) {\n  if (shape instanceof Rectangle) {\n    //...\n  }\n}\n</code></pre>\n<p><code>type Shape = Square | Rectangle</code> 부분에서 Rectangle은 타입으로 참조되지만, <code>shape instanceof Rectangle</code> 부분에서는 값으로 참조되어 분기가 가능한 것이다.</p>\n</li>\n</ol>\n<h3>3. 타입 연산은 런타임에 영향을 주지 않는다.</h3>\n<p>타입이 사라지기 때문에 당연히 타입 연산도 런타임에 어떠한 영향을 주지 않는다.</p>\n<pre><code class=\"language-ts\">function asNumber(val: number | string): number {\n  return val as number\n}\n</code></pre>\n<pre><code class=\"language-js\">function asNumber(val) {\n  return val\n}\n</code></pre>\n<p>위의 코드는 아래와 같이 컴파일 되기 때문에 해당 인수가 해당 함수를 통과하더라도 그대로이다. 즉 어떠한 영향도 받지 않는다.</p>\n<h3>4. 런타임 타입은 선언된 타입과 다를 수 있다.</h3>\n<p>만약 API값을 수신할 때, API값을 잘못 파악하고 타입을 입력해놨다면 런타임 타입과 선언된 타입이 다르다.</p>\n<h3>5. 함수 오버로드 할 수 없다.</h3>\n<p>타입스크립트가 함수 오버로딩 기능을 지원하기는 하지만, 실제 컴파일 되어있을 때 선언문을 여러개 작성하더라도 구현체는 오직 하나뿐이다. 자바스크립트에서 함수 선언문으로 작성할 경우, 함수명이 동일하면 맨 마지막 함수로 덮어써진다. 이는 자바스크립트의 특징이다.</p>\n<h1>구조적 타이핑 익숙해지기</h1>\n<p>자바스크립트는 덕 타이핑 기반이다.</p>\n<p><em>덕 타이핑이란, 객체가 어떤 타입에 부합하는 변수와 메소드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주한다. 독수리가 오리처럼 걷고, 헤엄치고, 꽥꽥거린다면 독수리는 오리라고 할 수 있다.</em></p>\n<pre><code class=\"language-ts\">function calculateLength(v: { a: number; b: number }) {\n  return v.a + v.b\n}\n\nconst v1 = { a: 1, b: 2, c: 3 }\ncalculateLength(v1) //3\n</code></pre>\n<p>calculateLength의 매개변수 v는 a,b의 속성만 가지지만 c의 속성도 가지고 있는 v1을 해당 함수에 넣어도 문제로 인식하지 않는다. 구조적 관점에서 a,b가 있기 때문에 호환되기 때문이다.</p>\n<p>함수를 작성할 때 호출에 사용되는 매개변수의 속성들이 매개변수의 타입에 선언된 속성만을 가질거라 생각하기 쉽다. 이러한 타입은 봉인된 또는 정확한 타입이라고 불리며 타입스크립트 타입 시스템에서는 표현할 수 없다. 좋든 싫든 타입은 열려있다. 이러한 특성때문에 발생하는 오류는 아래와 같다.</p>\n<pre><code class=\"language-ts\">let sum: number = 0\nfor (let p of Object.keys(v1)) {\n  const num = v1[p]\n  //string은 v1의 인덱스로 사용할 수 없다.\n  sum += num\n}\nreturn sum\n</code></pre>\n<p>Object.keys(v1)을 호출하면 도출되는 배열은 무조건 객체의 속성 중 하나이지만, 타입은 확장될 수 있기 때문에 Object.keys(v1)의 타입은 string[]가 될 수도 있다. 즉 v1이 <code>{a:1,b:2,c:3, d: \"this is string\"}</code>이라면 NaN을 반환한다.\n이럴 경우에 루프보다는, 모든 속성을 각각 더하는 구현이 더 간결하다.</p>\n<p>정확한 타입으로 객체를 순회하는 방법은 추후에 다루도록 하겠다.</p>\n<p>클래스 역시 구조적 타이핑을 따른다. 클래스의 인스턴스가 예상과 다를 수 있음을 유의해야한다.</p>\n<h2>구조적 타이핑의 장점</h2>\n<p>구조적 타이핑은 테스트하는데 유리하다. 함수를 테스트하기 위해서는 모킹한 객체를 생성해야 하는데, 테스트에 필요한 객체의 속성만 작성해주면 되기 때문이다.</p>\n<h1>any 타입 지양하기</h1>\n<p>any의 위험성..</p>\n<h2>any 타입에는 타입 안정성이 없다.</h2>\n<pre><code class=\"language-ts\">let age: number = 10\nconst one = \"1\" as any\nage += one\n//age \"101:\n</code></pre>\n<p>age는 number 타입이지만, any를 설정함으로써 string 타입을 할당할 수 있게 된다. 런타임에서 age는 string이다..</p>\n<h2>함수 시그니처를 무시해버린다.</h2>\n<p>함수를 작성할 때는 시그니처를 명시해야 한다. 호출하는 쪽은 약속된 타입의 입력을 제공하고, 함수는 약속된 타입의 출력을 반환한다. any는 이런 약속을 무시해버릴 수 있다.</p>\n<pre><code class=\"language-ts\">function sum(a: number, b: number): number {\n  return a + b\n}\n\nconst a = \"3\" as number\nconst b = 5\nsum(a, b) //정상적으로 작동함.\n</code></pre>\n<h2>언어 서비스가 적용되지 않는다.</h2>\n<p>자동완성 기능 제공하지 않는다. 또한 Rename Symbol 기능을 사용하면 프로그램 내 모든 속성의 이름을 변경해주지만 any 타입이라면 적용되지 않는다.</p>\n<h2>타입 설계를 감춘다.</h2>\n<p>상태 객체의 설계를 감추기 때문에, 설계가 어떻게 되어있는지 전혀 알 수 없다. 내가 아닌 다른 사람이 코드를 본다면 파악하기 위해 코드를 재구성 해봐야 한다.</p>\n<h2>신뢰도를 떨어트린다.</h2>\n<p>런타임 오류가 더 자주 발생한다. 또한 타입 오류를 고쳐야하고 머릿속에 실제 타입을 기억해야 하기 때문에 번거롭다.</p>","id":"c6927e48-b60a-5406-8e46-4523fec67491"},"previous":{"fields":{"slug":"/tech/react/global-state/"},"excerpt":"React에서 전역 상태 관리는 왜 필요할까? 리액트는 단방향 데이터 바인딩이라는 특징을 가진다. 단방향 데이터 바인딩 특징은 어플리케이션이 예측 가능하다는 장점이 있지만, 뷰를 업데이트 해주는 부분을 매번 작성해주어야 한다는 단점이 있다. 리액트의 경우 뷰가 state에 따라서 자동으로 갱신되어 뷰를 업데이트 해주는 코드를 작성할 필요는 없지만, 이 state를 어플리케이션 구조에 맞게 잘 전달해주는 과정이 필요하다. 만일 컴포넌트 구조가 …","frontmatter":{"date":"2022-10-17T00:00:00.000Z","description":"전역 상태 관리는 왜 필요하고, 어떤 도구들이 있나","title":"React의 전역 상태 관리"},"html":"<h1>React에서 전역 상태 관리는 왜 필요할까?</h1>\n<p>리액트는 단방향 데이터 바인딩이라는 특징을 가진다. 단방향 데이터 바인딩 특징은 어플리케이션이 예측 가능하다는 장점이 있지만, 뷰를 업데이트 해주는 부분을 매번 작성해주어야 한다는 단점이 있다. 리액트의 경우 뷰가 state에 따라서 자동으로 갱신되어 뷰를 업데이트 해주는 코드를 작성할 필요는 없지만, 이 state를 어플리케이션 구조에 맞게 잘 전달해주는 과정이 필요하다. 만일 컴포넌트 구조가 매우 깊은 트리 구조라면 해당 state를 넘겨주는데 여러 단계를 거쳐야하고, 이 state가 어디서부터 전달되었는지 추적하기 어려울 것이다.</p>\n<p>이러한 문제를 해결하기위해 전역 상태 관리 도구는 어떠한 컴포넌트에서도 전역으로 관리되는 state에 바로 접근할 수 있도록 해준다. state를 전달하기위해 여러 단계를 거칠 필요가 없는 것이다.</p>\n<p>해당 상태가 어플리케이션 전반에 이용되어 상태를 전달하기 위한 단계가 복잡할 경우, 혹은 전반에 이용되지 않더라도 상태를 전달하기 위한 단계가 복잡할 경우 사용된다.</p>\n<h1>전역 상태 관리를 위한 도구들</h1>\n<h2>Redux</h2>\n<p>리덕스는 리액트 이외에도 자바스크립트로 만들어진 어플리케이션이라면 사용할 수 있다.</p>\n<p>리덕스는 액션이라고 불리는 이벤트를 통해서만 state를 업데이트 시킬 수 있다. 이는 리액트가 사용하는 단방향 데이터 바인딩과 같은 원리로 상태 변경을 예측하기 쉽도록 한다. 언제, 어디서, 왜, 어떻게 state가 변경되었는지 파악할 수 있다.</p>\n<p>리덕스의 이러한 구조는 상태의 변경이 예측 가능하다는 장점도 있지만, 러닝 커브가 있고 구현하기위해 더 많은 코드를 작성해야한다.</p>\n<h3>언제 리덕스를 도입하면 좋을까</h3>\n<ul>\n<li>어플리케이션이 많은 상태를 보유하고, 어플리케이션의 여러 공간에서 사용될 때</li>\n<li>상태가 매우 자주 변경될 때</li>\n<li>상태 변경 로직이 복잡할 때</li>\n<li>어플리케이션의 규모가 클 때, 많은 사람들과 작업해야 할 때</li>\n</ul>\n<p>예측 가능하고, 테스트가 쉽다는 장점에 대규모 어플리케이션에 적합하다. 또한 상태 변경을 손쉽게 추적할 수 있기에 상태 변경 로직이 복잡할 때도 사용하면 좋다.</p>\n<h3>주요 개념</h3>\n<ul>\n<li>스토어는 전역 state를 저장하는 곳으로 자바스크립트 object인데 특별한 함수와 기능을 내장하고 있어 순수 전역 객체와 다르다.</li>\n<li>우리는 스토어 내부의 state를 직접적으로 수정하면 안된다. 이는 정해진 방식으로만 state를 조작하여 예측가능하다는 redux의 원칙을 위배한다.</li>\n<li>state를 변경하는 방법은 순수 액션 객체를 만들고 활용함으로써 가능하다. 액션 객체는 어플리케이션에 무슨 일이 발생할 것인지 알려준다. 그리고 dispatch를 사용해서, action을 전달한다.</li>\n<li>액션이 dispatch되면, reducer를 실행시키고 old state를 기반으로 new state를 계산하여 업데이트한다. old state에서 new state로 변경시킬 때 immutable을 유지해야한다. 만약 immutable하지 않다면 old state와 new state를 비교할 때 문제가 발생하고 리듀서가 올바르게 작동하지 않는다. (객체는 참조값이기 때문에.)</li>\n<li>마지막으로 스토어는 subscribers에게 구독중인 state가 변경되었다고 알려주고 UI가 변경되게 된다.</li>\n</ul>\n<h2>Recoil</h2>\n<p>Recoil은 facebook에서 출시한 상태관리 라이브러리이다.</p>\n<p>state는 공통된 상위 컴포넌트로 끌어올려야만 공유될 수 있으며 이 과정에서 거대한 트리가 다시 렌더링 되는 문제와 Context는 단일값만 저장할 수 있으며, 자체 소비자를 가지는 여러 값들의 집합을 담을 수 없다는 문제를 해결하기위해 탄생했다.</p>\n<h3>Recoil의 특징</h3>\n<p>boiler-plate free api로 redux는 간단한 상태 한개만 처리하려고 해도 수많은 보일러 플레이트 코드가 필요하였으나 recoil은 매우 간단하게 사용할 수 있다. 즉 러닝커브가 낮다고 할 수 있다.\n또한 비동기처리를 하기 위해서 redux의 경우는 redux-thunk와 같은 비동기 처리 라이브러리에 의존했지만 recoil에는 내장되어 있다.</p>\n<h3>주요 개념</h3>\n<ol>\n<li>atoms\n<ul>\n<li>atoms는 상태의 단위이며 업데이트와 구독이 가능하다. atom이 업데이트되면 각각의 구독된 컴포넌트는 새로운 값을 받아 리렌더링 된다. atoms는 런타임 중에서도 생성될 수 있다.</li>\n</ul>\n</li>\n<li>selectors\n<ul>\n<li>atoms나 다른 selectors를 입력으로 받아들이는 순수 함수다. 상위의 atoms 또는 selectors가 업데이트되면 하위의 selector 함수도 다시 실행된다. 컴포넌트들은 selectors를 atoms처럼 구독할 수 있으며 selectors가 변경되면 컴포넌트들도 다시 렌더링된다. selectors는 상태를 기반으로 파생된 데이터를 사용하는데 이용된다. <strong>최소한의 상태 집합만 atoms에 저장하고 파생된 데이터는 selectos를 통해서 처리함으로써 불필요한 상태의 보존을 방지할 수 있다.</strong></li>\n</ul>\n</li>\n</ol>\n<h2>Context api</h2>\n<p>Context api는 react에 자체적으로 내장된 전역 상태 관리 도구이다.</p>\n<h3>언제 Context api를 사용하면 좋을까?</h3>\n<p>상태 변경이 빈번하게 일어나지 않을 때, 간단한 데이터를 전역으로 공유하고 싶을 때 사용하면 좋다. Provider의 모든 하위 컴포넌트가 렌더링이 일어나기 때문이다. 예시로 언어 설정이나, 다크 모드 변경과 같은 스타일 설정을 저장해놓는데 적합하다.</p>\n<h1>서버 데이터 관리</h1>\n<p>위투디 정식 서비스를 제작할 때 서버 데이터 관리를 위해서 redux를 활용했다. 하지만 Redux는 비동기 처리가 불가능하기에 redux-thunk와 같은 비동기 미들웨어를 사용해야 했고, 보일러 플레이트 코드가 너무 많았다.<br>\n또한 서버 데이터의 만료 시간 등, 유효성 처리를 직접 해주어야 해서 번거로웠다.</p>\n<p>이후에는 react-query라는 라이브러리를 사용했다. redux처럼 많은 보일러 플레이트 코드들이 필요없었고, 서버 데이터 관리를 위한 다양한 기능을 제공하여 개발 생산성이 매우 높아졌다. 또한 최근에는 Suspense와 연동이 되기에 데이터를 fetch 할 동안 fallback-ui를 보여줄 수 있다. 매번 컴포넌트마다 loading 관련 분기를 만들어 처리하지 않아도 된다. 마치 try-catch 구문처럼 관심사를 분리하여 더 효율적이고 가독성 높은 코드를 만들 수 있는 것이다.</p>\n<p>서버 데이터를 관리함에 있어서, 데이터를 다루는 매우 복잡한 로직이 있지 않는 이상 react-query를 사용하는 편이 개발 생산성에 도움을 준다고 생각한다.</p>","id":"8ad817f0-aae0-5bb9-acda-d76f90fc3e82"},"next":{"fields":{"slug":"/programming/이펙티브타입스크립트/2장/"},"excerpt":"편집기를 사용하여 타입 시스템 탐색하기 많은 개발자들이 vscode를 이용하는데 typescript를 제작한 ms에서 만든 것이다. 따라서 vscode를 사용하면 typescript의 언어 서비스를 잘 활용할 수 있다. 편집기를 통해서 어떻게 타입 시스템이 동작하는지, 타입스크립트가 어떻게 타입을 추론하는지 개념을 잡을 수 있다. Go to Definition 기능을 통해서 타입 선언 파일로 이동할 수 있고, 타입 선언 파일을 보면서 어떻게 …","frontmatter":{"date":"2022-10-18T00:00:00.000Z","description":"타입스크립트의 타입 시스템","title":"이펙티브 타입스크립트 2장"},"html":"<h1>편집기를 사용하여 타입 시스템 탐색하기</h1>\n<p>많은 개발자들이 vscode를 이용하는데 typescript를 제작한 ms에서 만든 것이다. 따라서 vscode를 사용하면 typescript의 언어 서비스를 잘 활용할 수 있다.</p>\n<p>편집기를 통해서 어떻게 타입 시스템이 동작하는지, 타입스크립트가 어떻게 타입을 추론하는지 개념을 잡을 수 있다.</p>\n<pre><code class=\"language-ts\">const num = 3\n//num은 number로 자동으로 추론한다.\n</code></pre>\n<p>Go to Definition 기능을 통해서 타입 선언 파일로 이동할 수 있고, 타입 선언 파일을 보면서 어떻게 모델링 되었는지 파악할 수 있다.</p>\n<h1>타입이 값들의 집합이라고 생각하기</h1>\n<p>타입이 값들의 집합이라고 생각하라는 의미는 무엇일까. 1,2,3이라는 값들은 number라는 타입에 해당된다. 즉 1,2,3이라는 숫자 값들의 집합은 number 타입에 해당된다는 것이다. 1000도 숫자 값의 집합의 요소이기 때문에 number 타입에 해당된다.</p>\n<h2>타입의 종류</h2>\n<ol>\n<li>never 타입\n<ul>\n<li>공집합으로, never에는 아무런 값도 할당할 수 없다.</li>\n</ul>\n</li>\n<li>유닛 타입 혹은 리터럴 타입\n<ul>\n<li>한 가지 값만 포함하는 타입이다.</li>\n</ul>\n<pre><code class=\"language-ts\">type A = \"a\"\ntype B = \"b\"\n</code></pre>\n</li>\n<li>유니온 타입 - 값 집합들의 합집합을 말한다.\n<pre><code class=\"language-ts\">type AB = \"A\" | \"B\"\ntype AB12 = \"A\" | \"B\" | 12\n</code></pre>\n</li>\n<li>집합의 범위가 한정되어 있지 않은 타입들\n<ul>\n<li>number, string 등의 타입은 범위가 무한대이다. 나올 수 있는 경우의 수가 무수히 많기 때문이다.</li>\n</ul>\n</li>\n<li>서브 타입\n<pre><code class=\"language-ts\">interface Person {\n  name: string\n}\ninterface PersonSpan extends Person {\n  birth: Date\n  death?: Date\n}\n</code></pre>\nPersonSpan은 Person의 서브타입이라고 할 수 있다. PersonSpan은 Person의 모든 조건을 만족해야한다.</li>\n</ol>\n<h2>키워드</h2>\n<h3>&#x26;</h3>\n<p>두 타입의 인터섹션(교집합)을 계산한다. 예시를 통해서 알아보도록 한다.</p>\n<pre><code class=\"language-ts\">interface Person {\n  name: string\n}\n\ninterface LifeSpan {\n  birth: Date\n  death?: Date\n}\n\ntype PersonSpan = Person &#x26; LifeSpan\n\nconst ps: PersonSpan = {\n  name: \"hi\",\n  birth: new Date(),\n}\n</code></pre>\n<p>위의 PersonSpan의 경우 두 인터페이스가 공통적으로 가지는 속성이 없기 때문에 공집합이라고 생각할 수 있지만 이것은 틀린 것이다. 덕 타이핑으로 인해서 Person 인터페이스의 경우 어떤 객체가 name 속성을 보유하고 그것이 문자열이면 모두 만족한다. LifeSpan 인터페이스의 경우 마찬가지로 birth의 속성이 날짜인 객체도 전부 만족한다. 따라서 교집합이므로, name 속성과 birth 속성 2개다 존재해야 하는 것이다.</p>\n<p>하지만 유니온에 대해서는 다른 형태를 보여준다.</p>\n<pre><code class=\"language-ts\">type union = Person | LifeSpan\n\ntype K = keyof union\ntype M = typeof (Person &#x26; LifeSpan)\n</code></pre>\n<p>K는 never이고, M은 <code>name | birth | death</code>이다.\nK가 never인 이유는 union의 키는 (name) | (birth | death) 인데 둘 중 무슨 값이 될지 모르기 때문에 2개 다 만족하는 값이 나와야한다(?)</p>\n<pre><code class=\"language-ts\">keyof (A|B) = (keyof A) &#x26; (keyof B)\n</code></pre>\n<h3>extends</h3>\n<p>extends 키워드를 활용하여 서브 타입을 만들어낼 수 있다.</p>\n<p>extends 키워드는 제너릭 타입에서 한정자로도 쓰인다. 해당 문맥에서는 ~의 부분 집합을 의미하기도 한다.</p>\n<pre><code class=\"language-ts\">function getKey&#x3C;K extends string>(val: any, key: K) {\n  //....\n}\n\ngetKey(val, \"3\")\ngetKey(val, 12)\n//오류가 발생한다. K는 string의 부분 집합이므로.\n</code></pre>\n<h1>타입 공간과 값 공간의 심벌 구분하기</h1>\n<p>타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재한다.</p>\n<p><em>symbol이란 es5에서 추가로 명세된 원시값이다. 고유하기 때문에 충돌이 없어 객체의 키값으로 주로 사용된다.</em></p>\n<pre><code class=\"language-ts\">interface Cylinder {\n  radius: number\n  height: number\n}\n\nconst Cyclinder = (radius: number, height: number) => ({ radius, height })\n</code></pre>\n<p>interface에서는 Cylinder는 타입으로, const에서는 값으로 사용된다. 심벌에 어떤 키워드가 사용되었는지 잘파악하여 문맥으로 유추해야한다.</p>\n<p>클래스의 경우 타입으로 쓰일 때는 형태(속성과 메소드)가 사용되는 반면, 값으로 쓰일 때는 생성자가 사용된다.</p>\n<p>typeof, this 그리고 많은 다른 연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.</p>\n<h1>타입 단언보다는 타입 선언하기</h1>\n<p>타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법은 타입 단언, 타입 선언 두가지이다.\n타입 단언이 꼭 필요한 경우가 아니라면 타입 선언을 사용해야한다. 타입 단언의 경우 강제로 타입을 지정한 것과 마찬가지이다. 타입 체커의 오류도 나타나지 않는다.</p>\n<pre><code class=\"language-ts\">interface Person {\n  name: string\n}\n\nconst person: Person = { name: \"jinwook\" }\nconst e_person = { nickname: \"jinwook\" } as Person\n//e_person의 경우 타입 체커에 의해서 오류가 발생해야 하지만, 타입 단언으로 인해서 오류가 발생하지 않음.\n</code></pre>\n<pre><code class=\"language-ts\">document.querySelector(\"#myButton\").addEventListener(\"click\", e => {\n  const button = e.currentTarget as HTMLButtonElement\n})\n</code></pre>\n<p>타입 단언이 꼭 필요한 경우는 타입 체커가 추론한 타입보다 내가 판단하는 타입이 더 정확할 때 의미가 있다.\n예를 들어 DOM 엘리먼트에 대해서는 타입스크립트보다 개발자가 더 정확히 알고있다. 타입스크립트는 DOM에 접근할 수 없기 때문에 myButton이 버튼 엘리먼트인지 알 수 없다.</p>\n<h2>화살표 함수에서 타입 선언</h2>\n<p>화살표 함수의 타입 선언은 추론된 타입이 모호할 때가 있다.</p>\n<pre><code class=\"language-ts\">const people = [\"jinwook\"].map(name => ({ name }))\n//{name:string}[] 형태이다. 원하는 Person[]이 나오지 않는다.\n</code></pre>\n<p>타입 단언을 써도 문제가 해결되긴 하지만, 런타임에 문제가 발생한다.</p>\n<pre><code class=\"language-ts\">const people = [\"jinwook\"].map(name => ({ name } as Person))\nconst e_people = [\"jinwook\"].map(name => ({} as Person))\n//e_people의 경우 Person 형태를 만족하지 않지만 에러를 반환하지 않음.\n</code></pre>\n<p>화살표 함수의 반환값에 타입을 선언하거나 화살표 함수 내에서 타입과 함께 변수를 선언함으로써 이러한 문제를 해결할 수 있다.</p>\n<pre><code class=\"language-ts\">const people = [\"jinwook\"].map((name): Person => ({ name }))\n\nconst people = [\"jinwook\"].map((name): Person => {\n  const person: Person = { name }\n  return person\n})\n</code></pre>\n<p>타입 단언을 사용하더라도, 서로의 서브타입이 아니면 변환이 불가능하다.</p>\n<pre><code class=\"language-ts\">const body = document.getElementById(\"foo\") //HTMLElement | null\nconst el = body as Person //타입 체커 오류 발생.\n</code></pre>\n<h1>객체 래퍼 타입 피하기</h1>\n<pre><code class=\"language-ts\">\"Thisisstring\".charAt(3)\n</code></pre>\n<p>위와 같은 코드는 어떻게 동작하는 것일까? string은 기본형으로 불변이며 메소드를 가지지 않는데 말이다.\n정확히 알아보면 charAt 메소드는 string의 메소드가 아니라 String 객체의 메소드이다. 자바스크립트는 기본형과 객체 타입을 서로 자유롭게 변환한다.</p>\n<p><strong>string 기본형에 charAt과 같은 메서드를 사용할 때, 기본형을 String 객체로 래핑하고 메소드를 호출하고 마지막에 래핑한 객체를 버린다.</strong></p>\n<p>이 String 객체는 오직 자기 자신하고만 동일하다.</p>\n<p>객체 래퍼 타입의 자동 변환은 종종 당황스러운 동작을 보인다.</p>\n<pre><code class=\"language-ts\">x = \"hello\"\nx.lanuage = \"English\"\nx.lanuage //undefined\n</code></pre>\n<p>String 객체로 변환되었다가 lanuage 속성을 할당하고 객체는 버려진다. 따라서 해당 속성으로 접근해도 undefined가 출력되는 것이다.</p>\n<p>이러한 래퍼 타입들 덕분에 기본형 값에 메소드를 사용할 수 있고, 정적 메소드(String.fromCharCode)도 사용할 수 있다. 타입스크립트는 기본형과 객체 래퍼 타입을 별도로 모델링한다.</p>\n<p>기본형은 객체 래퍼 타입에 할당될 수 있지만, 객체 래퍼 타입은 기본형에 할당될 수 없다. 객체 래퍼 타입의 할당은 지양해야 한다.</p>\n<pre><code class=\"language-ts\">const getStrLen = (foo: String): number => foo.length\ngetStrLen(\"hello\") //정상 작동\n\nconst isGreeting = (phrase: String) => [\"hi\", \"hello\"].includes(phrase)\n//타입 체크 에러 발생. includes에 들어가는 인수는 객체 래퍼 타입이 아니라 기본형이여햐함.\n</code></pre>\n<h1>잉여 속성 체크 한계 인지하기</h1>\n<p>타입이 명시된 변수에 <strong>객체 리터럴을 할당할 때 타입스크립트는 해당 타입의 속성이 있는지 그리고 그외의 속성은 없는지 확인한다.</strong>\n덕 타이핑 관점에서 본다면, 타입스크립트의 해당 타입의 속성만 만족시키면 되는데 왜 이런 현상이 발생할까?</p>\n<pre><code class=\"language-ts\">interface Room {\n  num: number\n  isSuite: boolean\n}\n\nconst r: Room = {\n  num: 10,\n  isSuite: false,\n  elephant: \"present\", //타입 체커 오류 발생. Room 형식에 elephant는 존재하지 않음.\n}\n\nconst r2 = {\n  num: 10,\n  isSuite: false,\n  elephant: \"present\",\n}\n\nconst r3: Room = r2 //오류 발생하지 않음.\n</code></pre>\n<p>위와 같이 객체 리터럴이 아닌, 임시 변수를 도입하면 구조적 타이핑 관점에서 타입이 할당이 가능한 것을 볼 수 있다.</p>\n<p>이러한 시스템이 도입된 이유는 단순히 런타임에 예외를 던지는 코드에 오류를 표시하는 것뿐만 아니라, 의도와 다르게 작성된 코드까지 찾으려고 하기 때문이다. 잉여 속성 체크는 할당 가능 검사와 별도의 과정으로 구조적 타이핑의 개념과 헷갈려서는 안된다.</p>\n<pre><code class=\"language-ts\">interface Options {\n  title: string\n  darkMode: boolean\n}\n\nfunction createWindow(options: Options) {\n  if (options.darkMode) {\n    setDarkMode()\n  }\n}\n\ncreateWindow({ title: \"blahblah\", darkmode: true })\n//타입 체커 오류 발생. darkMode를 쓰려고 했습니까?\n</code></pre>\n<p>위의 코드는 런타임에서 어떠한 오류도 발생시키지 않는다. 하지만 의도한대로 동작하지 않을 수 있다.</p>\n<p>Options 타입에는 실제로 무수히 많은 타입이 할당될 수 있다. document 객체도 할당이 가능하다. <code>title:string</code>속성이 있기 때문이다. <strong>잉여 속성 체크를 이용하면 기본적으로 타입 시스템의 구조적 본질을 해치지 않으면서 객체 리터럴에 알 수 없는 속성을 허용하지 않음으로써, 앞에 예시에서 다룬 문제를 해결할 수 있다.</strong></p>\n<p>만일 잉여 속성 체크를 원하지 않는다면 인덱스 시그니처를 활용하여 추가적으로 속성이 할당될 수 있음을 명시해주시면 된다.</p>\n<h2>약한 타입</h2>\n<p>선택적 속성만 가지는 타입을 약한(weak) 타입이라고 한다.</p>\n<pre><code class=\"language-ts\">interface Animal {\n  hasLeg?: boolean\n  isHerbivores?: boolean\n}\n\nconst elephant = { isBig: true }\n//타입 체크 에러 발생. 공통적인 속성이 없음.\n</code></pre>\n<p>구조적인 관점에서 Animal 타입은 모든 속성이 선택적이므로 모든 객체를 포함할 수 있다. 이런 약한 타입에 대해서 타입스크립트는 값 타입과 선언 타입에 공통된 속성이 있는지 확인하는 별도의 체크를 수행한다. 객체 리터럴에만 수행하는 잉여 속성 체크와 다르게 모든 할당문에서 수행된다. 따라서 임시 변수 패턴을 사용하더라도 공통 속성 체크는 여전히 동작한다.</p>\n<h1>함수 표현식에 타입 적용하기</h1>\n<p>함수를 정의하는 방법은 함수 선언문, 함수 표현식 2가지가 있다. 타입스크립트의 경우 함수 표현식으로 정의하면 좋다. 그 이유는 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용 할 수 있기 때문이다.</p>\n<pre><code class=\"language-ts\">type BinaryFn = (a: number, b: number) => number\nconst sum: BinaryFn = (a, b) => a + b\nconst mul: BinaryFn = (a, b) => a * b\nconst sub: BinaryFn = (a, b) => a - b\n</code></pre>\n<p>위의 예제를 통해서, 재사용성과 함수 타입을 매개변수부터 반환값까지 선언했을 때보다 함수 구현부가 분리되어 있어 로직이 보다 분명해진다는 장점이 있다. 따라서 라이브러리는 공통 ㅏㅎㅁ수 시그니처를 타입으로 제공하기도 한다. 예시로 리액트에서 함수의 매개변수에 명시하는 MouseEvent 타입 대신 함수 전체에 적용할 수 있는 MouseEventHandler 타입을 제공한다.</p>\n<h2>시그니처가 일치하는 다른 함수</h2>\n<p>fetch 함수를 예시로 살펴본다.</p>\n<pre><code class=\"language-ts\">async function getQuote() {\n  const response = await fetch(\"/quote?by=Mark+Twain\")\n  const qutoe = await response.json()\n  return qutoe\n}\n</code></pre>\n<p>위의 예시에서 만일 /quote가 존재하지 않는 API라면 response.json()은 JSON 형식이 아니라는 요상한 오류 메시지를 담아 거절된 프로미스를 반환한다. 이럴 경우 우리는 왜 거절되었는지 이유를 명확히 알 수 없다. 따라서 상태도 체크해주는 새로운 함수를 정의해본다.</p>\n<pre><code class=\"language-ts\">async function checkedFetch(input: RequestInfo, init: ReuqestInit) {\n  const response = await fetch(input, init)\n  if (!response.ok) {\n    throw new Error(response.status)\n  }\n  return response\n}\n</code></pre>\n<p>위의 코드는 아래와 같이 간결하게 고쳐질 수 있다. 함수 표현식에 타입을 적용하면 된다. 다른 함수의 시그니처를 참조하려면 typeof fn을 사용하면 된다.</p>\n<pre><code class=\"language-ts\">const checkedFetchasync: typeof fetch = (input, init) => {\n  const response = await fetch(input, init)\n  if (!response.ok) {\n    throw new Error(response.status)\n  }\n  return response\n}\n</code></pre>\n<p>아래와 같이 적용할 경우 <code>throw new Error(response.status)</code> 부분을 <code>return new Error(response.status)</code>로 변경할 경우 에러도 반환해준다. 반환타입이 fetch와 동일해야하기 떄문이다.</p>\n<h1>타입과 인터페이스의 차이점 알기</h1>\n<p>타입스크립트에서 명명된 타입을 정의하는 방법은 두 가지있다. <code>type</code>(타입 별칭)과 <code>interface</code>이다. <strong>대부분의 경우 타입을 사용해도 되고 인터페이스를 사용해도 된다. 하지만 공통점과 차이점을 명확히 이해하고 같은 상황에서는 동일한 방법으로 명명된 타입을 정의해 일관성을 유지해야한다.</strong></p>\n<p><em>타입에 I혹은 T를 붙여 어떤 형태로 사용되었는지 알려주는 패턴은 초기에는 종종 사용되었으나 현재는 지양해야 할 스타일이다.</em></p>\n<h2>공통점</h2>\n<ol>\n<li>명명된 타입은 어떤 타입으로 정의하던 상태에는 차이가 없다.</li>\n<li>인덱스 시그니처는 인터페이스와 타입에서 모두 사용할 수 있다.</li>\n<li>함수 타입도 인터페이스나 타입으로 정의할 수 있다.\n<pre><code class=\"language-ts\">type TFn = (x: number) => string\ninterface IFn {\n  (x: number): string\n}\n</code></pre>\n</li>\n<li>제너릭 사용이 가능하다.</li>\n<li>클래스를 구현할 때 둘 다 사용할 수 있다.</li>\n</ol>\n<h2>차이점</h2>\n<ol>\n<li>유니온 타입은 있지만, 유니온 인터페이스라는 개념은 없다.</li>\n<li>인터페이스는 타입을 확장(extends)할 수 있지만, 유니온은 할 수 없다.</li>\n<li>튜플과 배열 타입도 타입 별칭을 사용하면 간결하게 표현할 수 있다. 인터페이스로도 튜플과 비슷하게 구현할 수 있지만, concat과 같은 메서드를 사용할 수 없다.</li>\n<li>인터페이스에는 타입에는 없는 보강(augment)이 가능하다.\n<pre><code class=\"language-ts\">interface IState {\n  name: string\n  capital: string\n}\ninterface IState {\n  population: number\n}\nconst wyoming: State = {\n  name: \"Wyoming\",\n  capital: \"Cheyenne\",\n  population: 500000,\n}\n//정상이다.\n</code></pre>\n속성을 확장하는 것을 선언 병합이라고 한다. 선언 병합은 주로 타입 선언 파일에서 사용된다. 따라서 타입 선언 파일을 작성할 때는 선언 병합을 지원하기 위해 반드시 인터페이스를 사용해야 하며 표준을 따라야한다.</li>\n</ol>\n<h2>그렇다면 언제 type, interface를 사용하면 좋을까?</h2>\n<ol>\n<li>복잡한 타입이라면 타입 별칭을 사용하면 된다.</li>\n<li>둘다 표현 가능한 간단한 객체 타입이라면 일관성과 보강의 관점에서 생각해야함.\n<ul>\n<li>기존 프로젝트의 룰에 따른다.</li>\n<li>어떤 API에 대한 타입 선언을 작성해야 한다면 인터페이스가 좋다. 추후에 보강될 여지가 있기 떄문이다.</li>\n</ul>\n</li>\n</ol>\n<h1>타입 연산과 제너릭 사용으로 반복 줄이기</h1>\n<p>코드를 중복하면 안된다. 코드를 중복하면 유지보수 비용이 급격하게 늘어난다. 수정을 할 때 수정이 필요한 요소를 일일이 찾아서 빠짐없이 수정해줘야 하기 때문이다. DRY(Don't Repeat Yourself) 원칙이다.</p>\n<h2>타입 반복을 줄이는 방법들</h2>\n<h3>타입에 이름 붙이기</h3>\n<pre><code class=\"language-ts\">function distance(a: { x: number; y: number }, b: { x: number; y: number }) {\n  return a.x + a.y + b.x + b.y\n}\n\ninterface Point2D {\n  x: number\n  y: number\n}\n\nfunction distance(a: Point2D, b: Point2D) {}\n</code></pre>\n<h3>함수가 같은 타입의 시그니처를 가지고 있을 때</h3>\n<p><a href=\"#%ED%95%A8%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D%EC%97%90-%ED%83%80%EC%9E%85-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0\">예시</a></p>\n<h3>인터페이스 확장을 통한 반복 제거</h3>\n<pre><code class=\"language-ts\">interface Person {\n  firstName: string\n  lastName: string\n}\n\ninterface PersonWithDate {\n  firstName: string\n  lastName: string\n  birth: Date\n}\n\ninterface PersonWithDate extends Person {\n  birth: Date\n}\n\n//이미 존재하는 타입을 확장할 경우(일반적이지는 않음.)\ntype PersonWithDate = Person &#x26; { birth: Date }\n</code></pre>\n<h3>한 타입의 부분 집합인 타입</h3>\n<p>부모 타입을 이용해서 부분 집합 타입을 정의하라.</p>\n<pre><code class=\"language-ts\">interface State {\n  userId: string\n  pageTitle: string\n  recentFiles: string[]\n  pageContents: string\n}\n\ninterface TopNavState {\n  userId: State[\"userId\"]\n  pageTitle: State[\"pageTitle\"]\n  recnetFiles: State[\"recentFiles\"]\n}\n</code></pre>\n<p>매핑된 타입을 이용하는 방식</p>\n<pre><code class=\"language-ts\">type TopNavState = {\n  [k in \"userId\" | \"pageTitle\" | \"recentFiles\"]: State[k]\n}\n</code></pre>\n<p>매핑된 타입은 배열의 필드를 루프 도는 것과 같은 방식이다 이 패턴은 표준 라이브러리의 Pick 제너릭 타입과 동일하다.</p>\n<pre><code class=\"language-ts\">type TopNavState = Pick&#x3C;State, \"userId\" | \"pageTitle\" | \"recentFiles\">\n</code></pre>\n<p><strong>생성하고 난 다음에 업데이트가 되는 클래스의 경우, 타입 대부분이 선택적 필드가 된다.</strong></p>\n<pre><code class=\"language-ts\">interface Options {\n  width: number\n  height: number\n  color: string\n  label: string\n}\n\ninterface OptionsUpdate {\n  width?: number\n  height?: number\n  color?: string\n  label?: string\n}\n</code></pre>\n<p>매핑된 타입과 keyof를 사용하여 중복을 제거</p>\n<pre><code class=\"language-ts\">type OptionsUpdate = { [k in keyof Options]?: Options[k] }\n</code></pre>\n<p>매핑된 타입은 순회하며 Options 내 k 값에 해당하는 속성이 있는지 찾는다. 표준 라이브러리의 Partial 제너릭과 동일하다.</p>\n<pre><code class=\"language-ts\">type OptionsUpdate = Partial&#x3C;Options>\n</code></pre>\n<h3>값 형태에 해당하는 타입을 정의하고 싶을 때</h3>\n<pre><code class=\"language-ts\">const INIT_OPTIONS = {\n  width: 640,\n  height: 480,\n  color: \"#00FFD\",\n  label: \"VGA\",\n}\n\ninterface Options {\n  width: number\n  height: number\n  color: string\n  label: string\n}\n\ntype Options = typeof INIT_OPTIONS\n</code></pre>\n<p>여기서 typeof는 자바스크립의 연산자 typeof로 사용된 것으로 보이지만, 실제로는 타입스크립트 단계에서 연산되고 정교하게 타입을 표현한다. 값으로부터 타입을 만들어 낼 때 선언의 순서에 주의해야한다. 타입 정의를 먼저하고 값이 그 타입에 할당 가능하다고 선언하는 것이 좋다.</p>\n<p>함수나 메소드의 반환 값에 명명된 타입을 만들고 싶을 때</p>\n<pre><code class=\"language-ts\">function getUserInfo(userId: string) {\n  //.....\n  return {\n    userId,\n    name,\n    age,\n    height,\n    width,\n  }\n}\n\ntype UserInfo = ReturnType&#x3C;typeof getUserInfo>\n</code></pre>\n<p>ReturnType을 사용할 때 유의해야 할 점은 getUserInfo의 값이 아니라, typeof로 타입을 적용시켰다는 점이다.</p>\n<h3>제너릭 타입에서 매개변수를 제한하고 싶을 때</h3>\n<p>extends를 사용하면 된다. extends를 사용하면 제너릭 매개변수가 특정 타입을 확장한다고 선언할 수 있다.</p>\n<pre><code class=\"language-ts\">interface Name {\n  first: string\n  last: string\n}\n\ntype DancingDuo&#x3C;T extends Name> = [T, T]\n\nconst couple1: DancingDuo&#x3C;Name> = [\n  { first: \"Fred\", last: \"Artster\" },\n  { first: \"Ginager\", last: \"Rogers\" },\n]\n\nconst couple2: DancingDuo&#x3C;{ first: string }> = [\n  //...,\n  //...\n]\n//{first:string}에는 last 속성이 없어서 오류가 발생한다. extends 구문으로 확장한다고 선언했기 때문에 last가 꼭 필요함.\n</code></pre>\n<h1>동적 데이터에 인덱스 시그니처 사용하기</h1>\n<p>자바스크립트 객체는 문자열 키를 타입의 값에 관계없이 매핑한다. 타입스크립트에서는 타입에 인덱스 시그니처를 명시하여 유연하게 매핑을 표현할 수 있다.</p>\n<pre><code class=\"language-ts\">type Obj = { [property: string]: string }\n</code></pre>\n<p>위와 같은 방식이 인덱스 시그니처이다. 다음 3가지 의미를 담는다.</p>\n<ol>\n<li>키의 이름: 키의 위치만 표시하는 용도. 타입 체커에서는 사용되지 않음.</li>\n<li>키의 타입: string | number | symbol 조합이지만, 보통은 string 사용</li>\n<li>값의 타입: 어떤 값이든 될 수 있음.</li>\n</ol>\n<h2>인덱스 시그니처의 단점</h2>\n<ol>\n<li>잘못된 키를 포함해 모든 키를 허용한다. 만약 name이라는 속성이 필요한 객체임에도 불구하고 Name이라는 속성을 기입해도 타입 체크 오류가 발생하지 않는다.</li>\n<li>특정 키가 필요하지 않다. {}도 인덱스 시그니처 타입이다.</li>\n<li>키마다 다른 타입을 가질 수 없다.</li>\n<li>타입스크립트 언어 서비스의 기능이 일부 동작하지 않는다. name:을 입력할 때 키는 무엇이든 가능하기 때문에 자동완성안됨.</li>\n</ol>\n<h2>언제 인덱스 시그니처를 사용하고 사용하지 말아야 하는가?</h2>\n<p>인덱스 시그니처는 부정확하다. 만일 객체의 모든 속성이 string이라서 인덱스 시그니처를 사용한다면 이는 잘못된 것이다. <strong>인덱스 시그니처는 동적 데이터를 표현할 때 사용해야 한다.</strong></p>\n<p>예시로 CSV 파일처럼 헤더 행에 열 이름이 있고, 데이터 행을 열 이름과 값으로 매핑하는 객체로 나타내고 싶은 경우이다.</p>\n<p><em>declare 키워드는 컴파일러에게 해당 변수나 함수가 이미 존재한다고 알리는 역할을 한다.</em></p>\n<p><strong>어떤 타입에 가능한 필드가 제한되어 있는 경우라면 인덱스 시그니처로 모델링하면 안된다.</strong></p>\n<p>만일 객체에 a,b,c,d와 같은 키가 있지만 얼마나 많이 있는지 모른다면 선택적 필드 또는 유니온 타입으로 모델링 해야한다.</p>\n<pre><code class=\"language-ts\">interface Row1 {\n  [column: string]: number\n}\ninterface Row2 {\n  a: number\n  b?: number\n  c?: number\n  d?: number\n}\ntype Row3 =\n  | { a: number }\n  | { a: number; b: number }\n  | { a: number; b: number; c: number }\n  | { a: number; b: number; c: number; d: number }\n</code></pre>\n<p>마지막 Row3의 방식의 경우 정확하지만, 사용하기에는 조금 번거롭다.\n우리는 2가지 옵션이 존재한다.</p>\n<ol>\n<li>\n<p>Record 제너릭 타입 사용</p>\n<ul>\n<li>키 타입에 유연성을 제공하는 제너릭 타입이다.</li>\n</ul>\n<pre><code class=\"language-ts\">type Vec3D = Record&#x3C;'x' | 'y' | 'z', number>\n&#x3C;!-- Vec3D = {\n  x: number\n  y:number\n  z:number\n} -->\n</code></pre>\n</li>\n<li>\n<p>매핑된 타입 사용</p>\n<pre><code class=\"language-ts\">type Vec3D = { [k in \"x\" | \"y\" | \"z\"]: number }\ntype ABC = { [k in \"a\" | \"b\" | \"c\"]: k extends \"b\" ? string : number }\n// ABC = {\n//   a:number\n//   b:string\n//   c: number\n// }\n</code></pre>\n</li>\n</ol>\n<h1>number 인덱스 시그니처보다는 Array, 튜플, ArrayLike 사용하기</h1>\n<p>자바스크립트의 객체는 문자열을 키값으로 사용한다. 만일 문자열이 아닌 것을 키값으로 할당하면 .toString 메소드를 사용하여 문자열로 변환된다.</p>\n<pre><code class=\"language-ts\">x = {}\nx[[1, 2, 3]] = 2\n//x: '1,2,3' = 2\n//[1,2,3]이 toString으로 문자열로 변환됨.\n</code></pre>\n<p>자바스크립트에서 배열은 객체이다. 배열에서 인덱스에 접근하기 위해서 숫자로 된 키를 사용하지만, 내부에서 문자열로 변환되어 사용된다.</p>\n<pre><code class=\"language-ts\">const arr = [1, 2, 3]\narr[0] // 1\narr[\"0\"] //1\n</code></pre>\n<p>타입스크립트는 이러한 혼란을 막기위해 숫자 키를 허용하고, 문자열 키와는 다른 것으로 인식한다.</p>\n<p>인덱스 시그니처에 number를 사용하기 보다는 Array나 튜플, 또는 ArrayLike 타입을 사용하는 것이 좋다.</p>\n<h1>변경 관련된 오류 방지를 위해 readonly 사용하기</h1>\n<p>함수가 매개변수를 수정하지 않는다면, readonly로 설정하는 것이 좋다. 매개변수의 비의도적인 변경을 방지할 수 있다.</p>\n<p>readonly는 얕게 동작한다. 깊게 동작을 원한다면 ts-essentials에 있는 DeepReadonly 제네릭을 사용하면 된다.</p>\n<h1>매핑된 타입을 사용하여 값 동기화하기.</h1>\n<p>매핑된 타입을 사용해서 관련된 값과 타입을 동기화 할 수 있다.</p>\n<p>만일 이전 객체와 현재 객체를 비교하여 다르다면 업데이트를 수행해야 하는 상황인데, 효율성을 위해서 특정 속성의 차이만 비교한다고 해보자. 그렇다면 속성이 추가될 때마다 해당 속성이 특정 속성에 해당하는지 안하는지 코드를 작성해줘야 할 것이다. 매핑된 타입을 사용하면, 타입 시스템을 활용하여 안전하게 유지보수 할 수 있다.</p>\n<pre><code class=\"language-ts\">interface ScatterProps {\n  xs: number[]\n  ys: number[]\n  xRange: [number, number]\n  yRange: [number, number]\n  color: string\n  onClick: (x: number, y: number, index: number) => void\n}\n\nconst REQUIRES_UPDATE: { [k in keyof ScatterProps]: boolean } = {\n  xs: true,\n  ys: true,\n  xRange: true,\n  yRange: true,\n  color: true,\n  onClick: true,\n}\n\nfunction shouldUpdate(oldProps: ScatterProps, newProps: ScatterProps) {\n  let k: keyof ScatterProps\n  for (k in oldProps) {\n    if (oldProps[k] !== newProps[k] &#x26;&#x26; REQUIRES_UPDATE[k]) {\n      return true\n    }\n  }\n  return false\n}\n</code></pre>\n<p>이후에 만일 ScatterProps에 어떤 속성이 추가된다면, REQUIRES_UPDATE 해당 속성이 없다고 타입 시스템에 오류가 발생할 것이다.</p>","id":"4f71d23a-e4d0-5efb-a1b0-e52d6c4f76bd"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}