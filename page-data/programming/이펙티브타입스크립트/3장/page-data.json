{"componentChunkName":"component---src-templates-post-template-tsx","path":"/programming/이펙티브타입스크립트/3장/","result":{"pageContext":{"node":{"fields":{"slug":"/programming/이펙티브타입스크립트/3장/"},"excerpt":"타입 추론 타입스크립트는 타입 추론을 적극적으로 수행한다. 타입 구문의 수를 엄청나게 줄여주기에 코드의 전체적인 안정성이 향상된다. 숙련된 타입스크립트 개발자는 비교적 적은 수의 구문을 사용한다. 추론 가능한 타입을 사용해 장황한 코드 방지하기 위의 예시에서 a에 굳이 number라는 타입을 명시해줄 필요가 없다. 타입스크립트에서 자동으로 추론해주기 때문이다. 객체의 경우 객체의 경우에도, 타입 추론이 의도한 타입과 동일하다면 굳이 타입을 명…","frontmatter":{"date":"2022-11-01T00:00:00.000Z","description":"타입 추론","title":"이펙티브 타입스크립트 3장"},"html":"<h1>타입 추론</h1>\n<p>타입스크립트는 타입 추론을 적극적으로 수행한다. 타입 구문의 수를 엄청나게 줄여주기에 코드의 전체적인 안정성이 향상된다. 숙련된 타입스크립트 개발자는 비교적 적은 수의 구문을 사용한다.</p>\n<h1>추론 가능한 타입을 사용해 장황한 코드 방지하기</h1>\n<pre><code class=\"language-ts\">const a: number = 3\n</code></pre>\n<p>위의 예시에서 a에 굳이 number라는 타입을 명시해줄 필요가 없다. 타입스크립트에서 자동으로 추론해주기 때문이다.</p>\n<h2>객체의 경우</h2>\n<p>객체의 경우에도, 타입 추론이 의도한 타입과 동일하다면 굳이 타입을 명시해줄 필요가 없다.</p>\n<pre><code class=\"language-ts\">interface Person {\n  name: string\n  born: {\n    where: string\n    when: string\n  }\n}\nconst person: Person = {\n  name: \"sssdf\",\n  born: {\n    where: \"Seoul\",\n    when: \"2000-11-01\",\n  },\n}\n</code></pre>\n<p>person 객체만 정의하면 Person과 같은 타입이 자동으로 추론된다. 하지만 만일 객체 리터럴을 정의할 때 잉여속성 체크를 하고 싶다면 꼭 타입을 명시해야한다. 잉여속성 체크를 함으로써, 객체가 사용되는 쪽의 코드에서 문제가 발생하는 것이 아니고, 객체가 정의된 곳에서 문제가 발생되어 문제를 쉽게 파악할 수 있다.</p>\n<h2>리팩토링을 쉽게</h2>\n<p>타입이 추론되면 리팩토링도 쉽게 할 수 있다. 어떻게 보면 기존에 정의된 타입을 이용한다는 것으로 받아들이면 된다.</p>\n<pre><code class=\"language-ts\">interface Product {\n  id: number\n  name: string\n  price: number\n}\n\nfunction logProduct(product: Prodcut) {\n  const id: number = product.id\n  const name: string = product.name\n  const price: number = product.price\n}\n</code></pre>\n<p>위의 예시에서 만일 id가 number 타입이 아닌 string 타입으로 변경되면 logProduct의 함수 const id 부분이 타입 에러가 발생할 것이다. 위와 같은 경우에는 비구조화 할당문으로 리팩토링 해주는게 좋다. 모든 지역 변수의 타입 추론이 되도록 하기 때문이다.</p>\n<pre><code class=\"language-ts\">function logProduct(product: Product) {\n  const { id, name, price } = product\n}\n</code></pre>\n<h2>함수</h2>\n<p>타입 정보가 있는 라이브러리에서 콜백 함수의 매개변수 타입은 자동으로 추론된다. express HTTP 서버 라이브러리를 사용하는 request와 response 타입 선언은 필요하지 않는다.</p>\n<p>함수의 반환에 타입을 명시하면 객체 리터럴에 타입을 명시하는 것과 유사하게 사용되는 쪽의 코드에서 문제가 발생한 곳이 아니고, 구현부에서 문제를 발견할 수 있다.</p>\n<pre><code class=\"language-ts\">const cache: { [ticker: string]: number } = {}\nfunction getQuote(ticker: string) {\n  if (ticker in cache) {\n    return cache[ticker]\n    //number\n  }\n  return fetch(\"...\")\n    .then(response => response.json())\n    .then(quote => {\n      cache[ticker] = quote\n      return quote\n    })\n  //promise\n}\n</code></pre>\n<p>위의 getQuote 함수는 if 구문에서는 number 타입을, fetch에서는 Promise를 리턴하기 때문에 프로미스가 사용되는 부분에서 타입 에러를 발생한다. 해당 문제를 해결하기 위해서는 cache[ticker]를 반환하는게 아닌, Promise.resolve(cache[ticker])를 반환해야한다.</p>\n<p>또한 함수의 반환값에 타입을 명시하면, 해당 타입을 보고 직관적으로 함수를 이해할 수 있다.</p>\n<pre><code class=\"language-ts\">type Vector2D = { x: number; y: number }\nfunction add(a: Vector2D, b: Vector2D) {\n  return { x: a.x + b.x, y: a.y + b.y }\n}\n</code></pre>\n<p>위의 add 함수는 <code>{x:number, y:number}</code> 타입으로 추론할 것이다. 하지만 Vector2D가 들어갔는데, 해당 타입이 나온다는게 개발자 입장에서는 혼란스러울 수 있다. 이럴 때 타입을 명시해주면 혼란을 줄일 수 있다.</p>\n<h1>다른 타입에는 다른 변수 사용하기</h1>\n<pre><code class=\"language-ts\">let id = \"123\"\nfetchProduct(id) // string\n\nid = 123\nfetchProductByNumber(id) //number\n</code></pre>\n<p>자바스크립트에서는 위의 패턴이 허용된다. 하지만 타입스크립트에서는 id에 string 타입이 할당되었기 때문에 그 다음에 number 타입을 할당할 수 없어 오류가 발생한다.</p>\n<pre><code class=\"language-ts\">let id: string | number = \"123\"\n</code></pre>\n<p>위와 같이 유니온 타입으로 타입을 좁혀서 정의하면 코드는 동작한다. 하지만 id를 사용할 때마다 number인지 string인지 확인해야 하기 때문에, 간단한 타입에 비해 다루기 어렵다.\n<strong>따라서 위의 경우에는 변수를 분리한다!</strong>\n변수를 분리하면 더 정확한 변수명을 지을 수 있고, const로 변수를 선언하여 코드 안정성을 향상 시킬 수 있다.</p>\n<h1>타입 넓히기</h1>\n<p>상수를 사용해서 변수를 초기화 할 때 타입을 명시하지 않으면 타입 체커는 타입을 스스로 결정해야 한다. 지정된 단일 값으로 할당 가능한 값들의 집합을 유추해야 한다는 의미이다. 이러한 과정을 타입 넓히기(widening)라고 부른다.</p>\n<pre><code class=\"language-ts\">function onlyGetABC(abc: \"a\" | \"b\" | \"c\") {\n  //...\n}\n\nlet A = \"a\"\nonlyGetABC(A)\n//타입체크 에러 발생\n</code></pre>\n<p>위의 경우 변수 A의 경우 \"a\"라고 정의하였지만, 타입 체커는 타입을 string으로 배치하였다. 타입을 넓혀야 하기 때문이다. 그리고 <code>onlyGetABC</code>는 string이 아닌 <code>\"a\"</code>를 매개변수로 받기 때문에 타입 에러가 발생한다.</p>\n<pre><code class=\"language-ts\">const mixed = [\"x\", 1]\n</code></pre>\n<p>위의 경우 나올 수 있는 경우의 수가 매우 많다. 타입 시스템은 작성자의 의도를 추측하지만, 아무리 영리하더라도 사람의 마음까지는 읽을 수 없다. 위의 경우 작성자는 튜플로 추론되기를 바랬으나 <code>(string|number)[]</code>으로 추론된다.</p>\n<h2>넓히기를 제어하는 방법</h2>\n<h3>let 대신 const로 선언하기.</h3>\n<p>let 대신 const로 선언하면 더 좁은 타입이 된다.</p>\n<pre><code class=\"language-ts\">const A = \"a\"\nonlyGetABC(A)\n//정상\n</code></pre>\n<p>위의 예시에서 A는 <code>\"a\"</code>로 추론된다.\n그러나 const는 만능이 아니다. 객체와 배열의 경우에는 여전히 문제가 존재한다.</p>\n<p>객체의 경우 타입스크립트의 넓히기 알고리즘은 각 요소를 let으로 할당된 것으로 다룬다. 그리고 다른 속성을 추가하지 못한다.</p>\n<h3>명시적 타입 구문을 제공하기</h3>\n<pre><code class=\"language-ts\">const v: {x:1|2|3} {\n  x:1\n}\n</code></pre>\n<h3>타입 체커에 추가적인 문맥을 제공하는 것</h3>\n<p>이후 아이템에서 다룬다고함.</p>\n<h3>const 단언문 사용</h3>\n<p>const로 변수를 선언하는 것과 다른 의미이다.\n값 뒤에 as const를 작성하면 타입스크립트는 최대한 좁은 타입으로 추론한다. 배열을 튜플 타입으로 추론할 때에도 as const를 사용할수 있다.</p>\n<h1>타입 좁히기</h1>\n<p>타입 넓히기의 반대 개념이다. 대표적인 예시는 null 체크이다.</p>\n<pre><code class=\"language-ts\">const el = document.getElementById(\"foo\")\nif (el) {\n  el.innerHTML = \"hello\"\n} else {\n  alert(\"no element\")\n}\n</code></pre>\n<p>위의 예시에서는 분기 처리를 통해 el의 타입이 HTMLElement임을 확인하였다.</p>\n<h2>타입 좁히기 종류</h2>\n<ol>\n<li>\n<p>instanceof를 사용</p>\n</li>\n<li>\n<p>내장 함수(Array.isArray 등)</p>\n</li>\n<li>\n<p>조건문</p>\n<ul>\n<li>\n<p>조건문을 통해서 타입을 좁힐 때는 유의해주어야 한다.</p>\n<pre><code class=\"language-ts\">function foo(x?: number | string | null) {\n  if (!x) {\n  }\n}\n</code></pre>\n<p>위의 예시의 경우 0, '' 모두 falsy이기 때문에 타입이 전혀 좁혀지지 않았다.</p>\n<pre><code class=\"language-ts\">const el = document.getElementById(\"foo\")\nif (typeof el === \"object\") {\n}\n</code></pre>\n<p>위의 예시도 문제는 object도 null이기 떄문에 타입이 좁혀지지 않았다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>명시적 태그를 붙이는 방법</p>\n<ul>\n<li>객체 내에 type 속성을 넣어주고 값을 넣어주는 패턴 등이 존재한다.</li>\n<li>태그된 유니온, 구별된 유니온이라고 불린다.</li>\n</ul>\n</li>\n<li>\n<p>커스텀 함수 도입</p>\n<pre><code class=\"language-ts\">function isInputElement(el: HTMLElement): el is HTMLInputElement {\n  return \"value\" in el\n}\n\nfunction getElementContent(el: HTMLElement) {\n  if (isInputElement(el)) {\n    return el.value\n  }\n  return el.textContent\n}\n</code></pre>\n<ul>\n<li>위와 같은 패턴을 사용자 정의 타입 가드라고 한다.</li>\n</ul>\n<pre><code class=\"language-ts\">const member = [\"a\", \"b\", \"c\", \"d\"]\nconst people = [\"a\", \"e\"]\n\nconst onlyMember = people.map(who => member.find(v => v === who))\n//(string | undefined)[]\n\nconst filteredOnlyMember = people\n  .map(who => member.find(v => v === who))\n  .filter(who => who !== undefined)\n//(string | undefined)[]\n</code></pre>\n<p>위의 경우 filteredOnlyMember 변수도 (string | undefined)[]이다. 이럴 때 타입 가드를 사용하면 타입을 좁힐 수 있다.</p>\n<pre><code class=\"language-ts\">function isDefined&#x3C;T>(x: T | undefined): x is T {\n  return x !== undefined\n}\n\nconst filteredOnlyMember = people\n  .map(who => member.find(v => v === who))\n  .filter(isDefined)\n//string[]\n</code></pre>\n</li>\n</ol>\n<h1>한꺼번에 객체 생성하기</h1>\n<p>자바스크립트의 값은 변경되지만 일반적으로 타입스크립트의 타입은 변경되지 않는다. 객체를 생성할 때는 속성을 하나씩 추가하는 것보다는 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리하다.</p>\n<pre><code class=\"language-ts\">const pt = {}\npt.x = 3\npt.y = 5\n//타입 체크 오류 발생.. {} 형식에 x가 존재하지 않습니다.\n</code></pre>\n<p>아래와 같은 패턴으로 정의하면 오류가 발생하지 않는다.</p>\n<pre><code class=\"language-ts\">const pt = { x: 3, y: 5 }\n</code></pre>\n<p>객체를 반드시 제각각 나눠서 만들어야 한다면 타입 단언문을 사용해야한다.</p>\n<pre><code class=\"language-ts\">interface Point {\n  x: number\n  y: number\n}\nconst pt = {} as Point\npt.x = 3\npt.y = 5\n</code></pre>\n<h2>전개 연산자</h2>\n<p>객체를 합칠 때는 전개 연산자를 사용한다.</p>\n<pre><code class=\"language-ts\">const pt = { x: 3, y: 4 }\nconst id = { name: \"pythagoras\" }\nconst namedPoint = {}\nObject.assign(namedPoint, pt, id)\nnamedPoint.name\n//타입 에러 발생.. name 속성이 없다.\n\nconst namedPoint = { ...pt, ...id }\nnamedPoint.name\n</code></pre>\n<h3>조건부 속성</h3>\n<pre><code class=\"language-ts\">declare let hasMiddle: boolean\nconst firstLast = { first: \"harry\", last: \"potter\" }\nconst president = { ...firstLast, ...(hasMiddle ? { middle: \"S\" } : {}) }\n</code></pre>\n<p>위의 예시에는 middle이 선택적 속성을 가지는 것으로 추론된다.</p>\n<p>만일 전개 연산자로 여러 속성을 추가하면 어떻게 될까? 이때는 유니온 속성으로 추론된다. 속성이 함께 정의되기 때문에 유니온을 사용하는게 값의 집합을 더 정확히 표현할 수 있기 때문이다.</p>\n<p>유니온 방식이 아닌, 선택적 필드로 만들고 싶다면 헬퍼 함수를 사용해야한다.</p>\n<pre><code class=\"language-ts\">function addOptional&#x3C;T extends object, U extends object>(\n  a: T,\n  b: U | null\n): T &#x26; Partial&#x3C;U> {\n  return { ...a, ...b }\n}\n</code></pre>\n<p><strong>객체나 배열을 변환해서 새롤운 객체나 배열을 생성하고 싶다면 루프 대신 내장된 함수형 기법 또는 로대시 같은 유틸리티 라이브러리를 만드는게 한꺼번에 객체 생성하기 관점에서 옳다.</strong></p>\n<h1>일관성 있는 별칭 사용하기</h1>\n<pre><code class=\"language-ts\">const person = {\n  age: 20,\n  name: \"jinwook\",\n  location: { City: \"Seoul\", State: \"gdd\" },\n}\nconst loc = person.location\n</code></pre>\n<p>위의 loc 변수가 별칭이다. 별칭의 속성값을 변경하면 원본 객체의 속성값도 변경한다. 따라서 별칭을 남발하면 제어 흐름을 파악하기 어렵다.</p>\n<p>만일 location의 분기를 여러번 나눠야되는 로직이 있다면 우리는 location 별칭을 사용해서 코드를 짧게 유지할 것이다.</p>\n<pre><code class=\"language-ts\">function saveLocation1(person) {\n  if (person.location) {\n  }\n  //...\n}\n\nfunction saveLocation2(person) {\n  const personLocation = person.location\n  if (person.location) {\n    fn(personLocation)\n    //error 발생.. personLocation은 null일 수 있음.\n    //...\n  }\n}\n\nfunction saveLocation3(person) {\n  const { location } = person\n  if (location) {\n    //...\n  }\n}\n</code></pre>\n<p>saveLocation2의 경우 객체의 속성을 별칭으로 정의했다. 하지만 아래 분기에서는 <code>person.location</code>을 확인하였고 <code>personLocation</code>은 확인하지 않았다. <code>person.location</code>은 <code>null</code>이 사라져 타입이 좁혀졌으나 <code>personLocation</code>은 그대로이다. 별칭을 사용할 것이면 일관성있게 <code>saveLocation3</code>처럼 사용해야한다. 또한 비구조화 할당을 사용해서 일관된 이름을 사용하면 더더욱 좋다.</p>\n<h2>별칭으로 인한 혼동</h2>\n<pre><code class=\"language-ts\">const { bbox } = polygon\nif (!bbox) {\n  caculatePolygonBbox(polygon)\n}\n</code></pre>\n<p>위의 예시에서 bbox와 polygon.bbox는 이제 다른 값을 참조한다..! bbox의 경우 비구조화 할당으로 인해 새로운 변수에 넣었기 때문이다.</p>\n<pre><code class=\"language-ts\">function fn(p: Polygon) {}\n\npolygon.bbox //BoundingBox | undefined\n\nif (polygon.bbox) {\n  fn(polygon)\n  polygon.bbox //BoundingBox\n}\n</code></pre>\n<p>위의 예시에서 fn은 polygon의 bbox 속성을 제거할 수도 있다. 하지만 타입은 그대로 유지된다. 타입스크립트에서 함수가 타입 정제를 무효화하지 않는다고 가정하기 때문이다. 따라서 위의 경우에는 비구조화 할당을 사용해서 새로운 지역변수를 정의하면 타입은 정확히 유지되지만 원본값은 변함이 없는 장점을 누릴 수 있다.</p>\n<h1>비동기 코드에는 콜백 대신 async 함수 사용하기</h1>\n<p>콜백보다는 프로미스, async 함수를 사용하는 것이 코드도 간결하며 타입을 추론하기 쉽다.\n선택의 여지가 있다면 프로미스 보다는 async를 사용하는게 좋다.</p>\n<ol>\n<li>코드가 더 간결하고 직관적이다.</li>\n<li>항상 프로미스를 반환한다.</li>\n</ol>\n<p>async 함수에서 프로미스를 반환하면 또 다른 프로미스로 래핑되지 않는다. Promise&#x3C;<T>>가 아닌 Promise<T>를 반환한다.</p>\n<h1>타입 추론에 문맥이 어떻게 사용되는지 이해하기</h1>\n<pre><code class=\"language-ts\">type Lanuage = \"JavaScript\" | \"TypeScript\"\nfunction setLanuage(lanuage: Lanuage) {\n  //...\n}\n\nsetLanuage(\"JavaScript\") //1\nlet js = \"JavaScript\"\nsetLanuage(js) //2\n</code></pre>\n<p>위의 예시에서 첫 번째로 호출한 함수의 경우 에러가 발생하지 않지만, 두 번째로 호출한 함수의 경우 에러가 발생한다. 이 문제를 해결할 수 있는 방법은 2가지이다.</p>\n<ol>\n<li>타입 선언\n<pre><code class=\"language-ts\">let js: Lanuage = \"JavaScript\"\n</code></pre>\n</li>\n<li>js를 상수로 만드는 것이다.\n<pre><code class=\"language-ts\">const js = \"JavaScript\"\n</code></pre>\n</li>\n</ol>\n<h2>튜플 사용 시 주의 점</h2>\n<pre><code class=\"language-ts\">function panTo(where: [number, number]) {}\n\npanTo([10, 10])\nconst loc = [10, 10]\npanTo(loc)\n</code></pre>\n<p>위의 예시의 경우 loc를 상수로 선언했음에도 불구하고 타입 에러가 발생한다. 그 이유는 loc를 <code>number[]</code>로 추론했기 때문이다. 이 경우도 위와 유사하다. 타입 선언을 하거나 상수로 정의해준다.</p>\n<pre><code class=\"language-ts\">const loc = [10, 10] as const\n</code></pre>\n<p>기존에 const는 참조값이 바뀌지 않는 것이였는데, as const로 정의하면 내부까지 상수라는 사실을 타입스크립트에게 알려준다.</p>\n<p>하지만 위의 코드는 또 문제가 있다. loc의 경우 readonly 상태를 가지게 되는데, panTo가 매개변수의 내용이 불변을 보장하지 못하는 것이다. panTo의 매개변수에 readonly 키워드를 적용해줌으로써 해당 문제를 해결할 수 있다.</p>\n<p>as const를 사용할 때 유의해야 하는 점은 타입 정의에 실수가 있다면 타입이 정의되는 곳이 아닌, 호출되는 곳에서 발생한다는 것을 유의해야한다.</p>\n<h1>함수형 기법과 라이브러리로 타입 흐름 유지하기</h1>\n<p>자바스크립트에서는 서드파티 라이브러리의 도입을 신중해야한다. 타입을 알 수 없기 때문에 서드파티 라이브러리를 사용해서 코드를 줄이는데 시간이 오래들기 때문이다. 반면에 타입스크립트는 타입이 명시되어있어 서드파티 라이브러리 도입에 큰 문제가 없다. 서드파티 라이브러리를 활용해서 생산성을 높이는 편이 낫다.</p>","id":"28051e14-adc7-5f08-908e-62ff60528369"},"previous":{"fields":{"slug":"/tech/node.js/"},"excerpt":"Node.js란 Node.js는 Chrome의 V8 엔진으로 빌드된 자바스크립트 런타임이다. 기존에 자바스크립트는 브라우저에서만 구동 가능한 언어였다. 구글이 매우 빠른 자바스크립트 엔진인 V8을 출시하자 이를 바탕으로 브라우저 외 환경에서 자바스크립트 런타임을 구축하기 시작했다. 이벤트 기반 이벤트 기반이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미한다. 예시로 클릭이나 네트워크 요청 등이 있을 수 있다. 논 블로킹 논 …","frontmatter":{"date":"2022-10-19T00:00:00.000Z","description":"Node.js, Express, MongoDB란?","title":"Node.js, Express, MongoDB"},"html":"<h1>Node.js란</h1>\n<p>Node.js는 Chrome의 V8 엔진으로 빌드된 자바스크립트 런타임이다. 기존에 자바스크립트는 브라우저에서만 구동 가능한 언어였다. 구글이 매우 빠른 자바스크립트 엔진인 V8을 출시하자 이를 바탕으로 브라우저 외 환경에서 자바스크립트 런타임을 구축하기 시작했다.</p>\n<h2>이벤트 기반</h2>\n<p>이벤트 기반이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미한다. 예시로 클릭이나 네트워크 요청 등이 있을 수 있다.</p>\n<h2>논 블로킹</h2>\n<p>논 블로킹이란 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행함을 뜻한다. 반대로 블로킹이란 이전 작업이 끝나야만 다음 작업을 수행하는 것을 의미한다. 논 블로킹 방식은 모든 작업이 동시에 처리될 수 있다는 전제하에 블로킹 방식보다 훨씬 빠르다. (ex. 시간이 오래 걸리는 블로킹 코드를 setTimeout으로 묶어 백그라운드에서 처리하도록 함.)</p>\n<h2>싱글 스레드</h2>\n<p>엄밀히 말하자면 싱글 스레드로 동작하지 않는다. 노드를 실행하면 프로세스를 하나 생성하고, 해당 프로세스에서 스레드들을 생성하는데 내부적으로 스레드를 여러개 생성한다. 그중에서 우리가 제어할 수 있는 스레드는 하나이기에 싱글 스레드라고 여겨진다. Node.js는 싱글 스레드 논블로킹 방식으로 움직이기 때문에 매우 효율적으로 일처리가 가능하고 멀티 스레드에 비해서 프로그래밍이 비교적 쉽다는 장점이 있다. (워커 스레드라는 기능을 사용하면 멀티 스레드 구현이 가능하다. 스레드풀의 경우는 자동으로 멀티스레드를 사용한다. 암호화, 파일 입출력 등 작업에서 사용된다.)</p>\n<h2>그렇다면 언제 Node.js를 사용하면 좋을까?</h2>\n<p>노드는 싱글 스레드, 논블로킹 모델로 사용하므로 해당 모델의 장단점과 크게 다르지 않다.\n서버는 기본적으로 I/O를 많이 수행하는데 노드는 많은 양의 I/O 작업을 논블로킹 모델로 효율적으로 처리할 수 있다. 하지만 CPU 부하가 큰 작업에는 적합하지 않다. 스레드 하나가 혼자서 감당하기 어렵기 때문이다. 정리를 하자면, 개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는 데 적합하다. 네트워크, 데이터베이스, 디스크 작업 같은 I/O에 특화되어 있기 때문이다. 예시로 실시간 채팅 어플리케이션, 주식 차트, JSON 데이터를 제공하는 API 서버가 노드를 많이 사용한다.</p>\n<p>싱글 스레드 방식의 프로그래밍은 러닝 커브가 멀티 스레드 방식보다 상대적으로 낮다. 하지만 싱글 스레드의 경우 하나뿐인 스레드가 오류가 발생하면 멈추기 때문에 잘 관리하도록 해야한다.</p>\n<h1>Express란</h1>\n<p>Express는 웹 서버 프레임워크이다. 웹 서버를 구성하기 위해서 많은 편의 기능들이 내장되어 있다.\n대표적으로 미들웨어와 라우팅이라는 장점이 있다.</p>\n<p>Express의 핵심은 미들웨어라고 해도 과언이 아니다. 뒤에 나오는 라우터도 미들웨어의 일종이다. 미들웨어를 통해 요청과 응답에 다양한 기능을 추가할 수 있다. 로그인 여부 체크 등..</p>\n<p>라우팅의 경우 http 모듈을 사용해서 처리하려면, 굉장히 많은 분기가 필요하지만 Express 라우팅 기능을 사용하면 손쉽게 가능하다.</p>\n<h1>MongoDB란?</h1>\n<p>MongoDB는 NoSQL 데이터베이스로 자바스크립트 문법을 사용한다는 특징이 있다. MongoDB를 사용하면 자바스크립트만으로 웹 애플리케이션을 구축할 수 있다.</p>\n<h2>NoSQL, SQL 특징</h2>\n<p>NoSQL에는 고정된 테이블이 없다. SQL의 경우 테이블을 만들 때, 칼럼과 자료형, 옵션 등을 정의하지만 몽고디비는 컬렉션을 만들면 끝이다. 어떠한 데이터든 들어갈 수 있다.</p>\n<p>MongoDB는 MySQL과 달리 JOIN 기능이 없다. 흉내를 낼수는 있지만, 하나의 쿼리로 여러 테이블을 합치는 작업이 항상 가능하지는 않다.</p>\n<p>몽고디비의 가장 큰 장점은 확장성과 가용성이다. 데이터의 일관성을 보장해주는 기능이 약한 대신, 데이터를 빠르게 넣을 수 있고 여러 서버에 데이터를 쉽게 분산시킬 수 있다.</p>\n<p>어플리케이션에 꼭 한가지 데이터베이스만 써야되는 것은 아니다. 상황에 맞게 올바른 데이터베이스를 선택하면 된다. 데이터의 일관성이 필요한 항공 예약의 경우는 MySQL로, 채팅 혹은 빅데이터와 같은 일관성이 필요없고 데이터 양이 많은 경우는 MongoDB 도입을 고려해볼 수 있다.</p>\n<h2>Mongoose란?</h2>\n<p>ODM(Object Document Mapping)이라고 불린다. 몽고디비 자체가 이미 자바스크립트인데 굳이 자바스크립트 객체와 매핑시키는 이유는 몽고디비에 없어서 불편한 기능들을 몽구스가 보완해주기 때문이다.\n(참고. MySQL은 ORM은 시퀄라이즈가 있다.)</p>\n<p><em>ODM이란 프로그래밍 언어 Object와 Document를 매핑시켜 호환성을 만들어내고 간편한 CRUD를 가능케한다.</em></p>\n<p>스키마라는 기능을 사용할 수 있다. NoSQL은 테이블이 없어서 자유롭게 데이터를 넣을 수 있지만, 때로는 자유로움이 불편함을 초래한다. 잘못된 자료형을 넣을 수 있고 다른 도큐멘트에는 없는 필드의 데이터를 넣을 수도 있다. 몽구스는 몽고디비에 데이터를 넣기 전에 노드 서버단에서 데이터를 한번 필터링 하는 역할을 한다.</p>\n<p>MySQL에 있는 JOIN 기능을 populate로 어느정도 보완한다. 관계가 있는 데이터를 쉽게 가져올 수 있다. 쿼리 한번에 데이터를 합쳐서 가져오는 것은 아니지만, 이 작업을 우리가 직접 하지 않아도 되므로 편리하다.</p>\n<h1>참고</h1>\n<p><a href=\"http://www.yes24.com/Product/Goods/91860680\">Node.js 교과서 개정 2판</a></p>","id":"c8a81d5e-a70b-5c15-b698-7a380d614956"},"next":{"fields":{"slug":"/알고리즘/부대복귀/"},"excerpt":"문제 링크 해결 전략 위 문제는 한 노드에서 다른 노드의 최단거리 찾기 문제이다. 즉 다익스트라 알고리즘을 사용하면 문제를 해결할 수 있다. 다익스트라 알고리즘은 그리디 알고리즘의 일종인데 방문한 노드에서 최단거리를 가지는 노드를 찾는 알고리즘에서 시간 복잡도 차이가 발생한다.\n노드의 방문 여부를 통해 최단거리를 찾는 알고리즘의 경우 모든 노드를 순회해야하므로 O(n^2)의 시간 복잡도를 가진다.\n하지만 문제의 경우 n이 100,000으로 O…","frontmatter":{"date":"2022-11-22T00:00:00.000Z","description":"다익스트라 알고리즘","title":"부대복귀"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/132266\">문제 링크</a></p>\n<h1>해결 전략</h1>\n<p>위 문제는 한 노드에서 다른 노드의 최단거리 찾기 문제이다. 즉 다익스트라 알고리즘을 사용하면 문제를 해결할 수 있다.</p>\n<p>다익스트라 알고리즘은 그리디 알고리즘의 일종인데 방문한 노드에서 최단거리를 가지는 노드를 찾는 알고리즘에서 시간 복잡도 차이가 발생한다.\n노드의 방문 여부를 통해 최단거리를 찾는 알고리즘의 경우 모든 노드를 순회해야하므로 O(n^2)의 시간 복잡도를 가진다.\n하지만 문제의 경우 n이 100,000으로 O(n^2)으로 해결할 수 없다.</p>\n<p>이 때 힙을 사용하면 O(NlogN)의 시간 복잡도로 최단거리를 가지는 노드를 찾을 수 있다. 따라서 우선순위 큐를 활용해서 다익스트라 알고리즘을 사용하면 문제의 정답을 구할 수 있다.</p>\n<p>이 문제의 경우 특이한 점이 하나 있다. 보통 노드간의 거리가 다른데 이 문제는 모든 노드 사이의 거리가 1이다. 따라서 사실 우선순위큐를 사용하지 않고 일반 큐를 사용해도 좋다. 그 이유는 모든 노드 사이의 거리가 1이므로 큐를 통해서 순차적으로 배출되는 노드가 최단거리를 가지는 노드임이 보장되기 때문이다. (+1씩 거리가 더해져서 큐에 들어가기 때문.)</p>\n<h1>정답 코드</h1>\n<h2>우선순위 큐를 사용한 방식</h2>\n<pre><code class=\"language-js\">class PriorityQueue {\n  constructor() {\n    this.queue = []\n  }\n\n  swap(aIndex, bIndex) {\n    const temp = this.queue[aIndex]\n    this.queue[aIndex] = this.queue[bIndex]\n    this.queue[bIndex] = temp\n  }\n\n  enqueue(priority, value) {\n    const node = { priority, value }\n    this.queue.push(node)\n\n    let currentIndex = this.queue.length - 1\n    let parentIndex = Math.floor((currentIndex - 1) / 2)\n\n    while (\n      parentIndex >= 0 &#x26;&#x26;\n      this.queue[parentIndex].priority &#x3C; this.queue[currentIndex].priority\n    ) {\n      this.swap(parentIndex, currentIndex)\n      currentIndex = parentIndex\n      parentIndex = Math.floor((currentIndex - 1) / 2)\n    }\n  }\n\n  dequeue() {\n    if (this.queue.length === 0) return undefined\n    if (this.queue.length === 1) return this.queue.pop()\n\n    const root = this.queue[0]\n    const end = this.queue.pop()\n    this.queue[0] = end\n\n    let currentIndex = 0\n    let leftIndex = 1\n    let rightIndex = 2\n\n    while (\n      (this.queue[leftIndex] &#x26;&#x26;\n        this.queue[currentIndex].priority &#x3C; this.queue[leftIndex].priority) ||\n      (this.queue[rightIndex] &#x26;&#x26;\n        this.queue[currentIndex].priority &#x3C; this.queue[rightIndex].priority)\n    ) {\n      if (\n        !this.queue[rightIndex] ||\n        this.queue[leftIndex].priority > this.queue[rightIndex].priority\n      ) {\n        this.swap(currentIndex, leftIndex)\n        currentIndex = leftIndex\n      } else {\n        this.swap(currentIndex, rightIndex)\n        currentIndex = rightIndex\n      }\n      leftIndex = currentIndex * 2 + 1\n      rightIndex = currentIndex * 2 + 2\n    }\n    return root\n  }\n\n  size() {\n    return this.queue.length\n  }\n}\n\nfunction solution(n, roads, sources, destination) {\n  const distance = Array(n + 1).fill(1000001)\n  const visited = Array(n + 1).fill(false)\n\n  const graph = Array(n + 1)\n    .fill()\n    .map(_ => [])\n\n  roads.forEach(([start, end]) => {\n    graph[start].push(end)\n    graph[end].push(start)\n  })\n\n  const priorityQueue = new PriorityQueue()\n\n  distance[destination] = 0\n  priorityQueue.enqueue(0, destination)\n\n  while (priorityQueue.size() > 0) {\n    const { priority: dist, value: node } = priorityQueue.dequeue()\n    if (d[node] > -dist) continue\n\n    graph[node].forEach(end => {\n      distance[end] = Math.min(distance[end], distance[node] + 1)\n      if (distance[end] === distance[node] + 1) {\n        priorityQueue.enqueue(-distance[end], end)\n      }\n    })\n  }\n  return sources.map(v => {\n    return distance[v] === 1000001 ? -1 : distance[v]\n  })\n}\n</code></pre>\n<h2>일반 큐를 사용한 방식</h2>\n<pre><code class=\"language-js\">class Queue {\n  constructor() {\n    this.front = 0\n    this.rear = 0\n    this.queue = []\n  }\n\n  enqueue(data) {\n    this.queue[this.rear++] = data\n  }\n\n  dequeue() {\n    const value = this.queue[this.front]\n    delete this.queue[this.front]\n    this.front++\n    return value\n  }\n\n  size() {\n    return this.rear - this.front\n  }\n}\n\nfunction solution(n, roads, sources, destination) {\n  const graph = Array(n + 1)\n    .fill()\n    .map(_ => [])\n\n  roads.forEach(([start, end]) => {\n    graph[start].push(end)\n    graph[end].push(start)\n  })\n\n  const distance = Array(n + 1).fill(Infinity)\n  const queue = new Queue()\n  queue.enqueue(destination)\n\n  distance[destination] = 0\n\n  while (queue.size() > 0) {\n    const node = queue.dequeue()\n    graph[node].forEach(end => {\n      distance[end] = Math.min(distance[end], distance[node] + 1)\n      if (distance[end] === distance[node] + 1) {\n        queue.enqueue(end)\n      }\n    })\n  }\n\n  return sources.map(v => {\n    return distance[v] === Infinity ? -1 : distance[v]\n  })\n}\n</code></pre>","id":"d744896b-c420-5e9c-8733-53f9a9bcc773"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}