{"componentChunkName":"component---src-templates-post-template-tsx","path":"/programming/이펙티브타입스크립트/5장/","result":{"pageContext":{"node":{"fields":{"slug":"/programming/이펙티브타입스크립트/5장/"},"excerpt":"처음에 타입스크립트를 사용했을 때 잘몰라서 any 키워드를 가끔 사용하곤 했다.\nany는 타입 시스템을 뭉개버리기 때문에 최소한으로 사용을 해야한다. any 키워드로 정의된 변수는 프로젝트 내에서 전염병처럼 퍼져나갈 수 있다...\nany를 잘 다루는 방법에 대해서 알아보도록 하자. any 타입은 가능한 좁은 범위에서만 사용하기 any를 사용해서 타입 시스템의 오류를 피하고자 아래와 같은 두가지 방식으로 처리하였다. 어떤 것이 더 좋은 해결책일…","frontmatter":{"date":"2022-12-02T00:00:00.000Z","description":"any 다루기","title":"이펙티브 타입스크립트 5장"},"html":"<p>처음에 타입스크립트를 사용했을 때 잘몰라서 any 키워드를 가끔 사용하곤 했다.\nany는 타입 시스템을 뭉개버리기 때문에 최소한으로 사용을 해야한다. any 키워드로 정의된 변수는 프로젝트 내에서 전염병처럼 퍼져나갈 수 있다...\nany를 잘 다루는 방법에 대해서 알아보도록 하자.</p>\n<h1>any 타입은 가능한 좁은 범위에서만 사용하기</h1>\n<p>any를 사용해서 타입 시스템의 오류를 피하고자 아래와 같은 두가지 방식으로 처리하였다. 어떤 것이 더 좋은 해결책일까?</p>\n<pre><code class=\"language-ts\">function f1() {\n  const x: any = expressionReturingFoo()\n  expectAoo(x) //error\n}\n\nfunction f2() {\n  const x = expressionReturingFoo()\n  expectAoo(x as any) //error\n}\n</code></pre>\n<p>f2 함수가 더 나은 선택이다. 그 이유는 any의 범위를 좁혔기 때문이다. f1의 로직이 길어질 경우 x는 f1 함수의 스코프 내에서 모두 any로 정의된다. 하지만 f2의 경우에는 expectAoo 함수에 매개변수만 any로써 정의되기 때문에 추가적으로 발생할 수 있는 오류를 줄여준다.</p>\n<h2>객체에서 any가 필요할 경우</h2>\n<p>객체의 속성에서 any가 필요할 경우 객체 전체를 any로 설정하는 것은 바람직하지 않다. 객체의 속성값만 any로 설정해주는 것이 좋다.</p>\n<pre><code class=\"language-ts\">const configGood = {\n  a: 1,\n  b: 2,\n  c: {\n    key: value as any,\n  },\n}\n\nconst configBad = {\n  a: 1,\n  b: 2,\n  c: {\n    key: value,\n  },\n} as any\n</code></pre>\n<h1>any를 구체적으로 변형해서 사용하기.</h1>\n<p>any를 사용하되 any를 모델링 할 수 있다면 모델링 하는 편이 좋다.</p>\n<pre><code class=\"language-ts\">function getLengthBad(arr: any) {\n  return array.length\n}\n\nfunction getLengthGood(arr: any[]) {\n  return array.length\n}\n</code></pre>\n<p>getLengthGood의 경우 함수의 매개변수가 배열이라는 형태를 알 수 있기 때문에 getLengthGood의 결과값이 number라는 타입을 가지게 되고, 매개변수도 배열인지 확인하게 된다.</p>\n<h2>객체에서</h2>\n<p>객체이고 값을 알 수 없다면 <code>{[key:string] :any}</code> 처럼 선언하면 된다.\nobject 타입도 가능하지만, 객체의 키를 열거 가능하지만 속성에 접근은 할 수 없다는 점에서 차이가 있다.</p>\n<h2>함수에서</h2>\n<pre><code class=\"language-ts\">type Fn0 = () => any\ntype Fn1 = (args: any[]) => any\n</code></pre>\n<p>Fn1의 경우 매개변수가 배열이라는 것을 알 수 있다는 장점이 있다.</p>\n<h1>함수 안으로 타입 단언문 감추기</h1>\n<p><strong>불가피하게 타입 선먼문을 사용해야 한다면, 정확한 정의를 가지는 함수 안으로 숨겨야한다.</strong></p>\n<p>함수의 모든 부분을 안전한 타입으로 구현하는 것이 이상적이다만, 불필요한 시간이 들 수 있다. 함수 내부에는 타입 단언을 사용하고 배출값의 타입 정의를 정확히 명시하는 정도로 하면 효율적이다.</p>\n<p>함수 캐싱 예시를 통해서 알아보도록 하겠다.</p>\n<pre><code class=\"language-ts\">function shallowEqual(a: any, b: any) {\n  return a === b\n}\n\nfunction cacheLast&#x3C;T extends Function>(fn: T): T {\n  let lastArg: any[] | null = null\n  let lastResult: any\n\n  return function (arg: any) {\n    if (!lastArg || !shallowEqual(lastArg, arg)) {\n      lastResult = fn(arg)\n      lastArg = arg\n    }\n    return lastResult\n  } as unknown as T\n}\n</code></pre>\n<h1>any의 진화</h1>\n<p>타입스크립트에서 변수의 타입은 변수를 선언할 때 결정된다. 정제(null, undefined)될 수는 있으나 새로운 값이 추가되도록 확장할 수는 없다. 하지만 any는 예외적인 케이스가 존재한다.</p>\n<pre><code class=\"language-ts\">function makeArr(num: number) {\n  const arr = []\n  for (let i = 0; i &#x3C; num; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n</code></pre>\n<p>위의 예시에서 arr이 선언된 부분에서는 any[] 이지만, 리턴할 때 arr는 number[]로 정의된다.\narr에 number 속성의 인자를 넣는 순간 number[]로 진화한다.</p>\n<p>만약에 number가 아닌 다른 속성을 넣어보면 어떨까?</p>\n<pre><code class=\"language-ts\">function makeArr(num: number) {\n  const arr = []\n  for (let i = 0; i &#x3C; num; i++) {\n    arr.push(i % 2 === 0 ? i : `${i}`)\n  }\n  return arr\n}\n</code></pre>\n<p>arr은 (num | string)[]가 된다.</p>\n<p>any 타입의 진화는 noImplictAny가 false로 설정되었고, 변수의 타입이 암시적 any일 경우에만 일어난다. 명시적으로 타입을 선언해주면 타입은 유지가 된다. 암시적 any는 함수 호출을 거쳐도 진화하지 않는다.</p>\n<p>암시적 any를 진화시키는 것보다 명시적으로 타입을 선언해주는 것이 좋다. 위의 예제의 경우 map 메소드를 사용한다면 문제를 해결할 수 있다.</p>\n<h1>모르는 타입에는 any 대신 unknown 사용하기</h1>\n<p>함수의 반환타입으로 any를 사용하는 것은 좋지 않다. 대신에 호출한 부분에서 반환값을 원하는 타입으로 설정하도록 하는 것이 더 이상적이다. unknown 타입을 반환함으로써 사용부에서 타입을 강제로 설정하도록 할 수 있다.</p>\n<p>any의 위험한 이유는 아래 두가지 특징을 가지기 때문이다.</p>\n<ol>\n<li>어떠한 타입이던 any에 할당 가능하다.</li>\n<li>any 타입은 어떠한 타입으로도 할당 가능하다.</li>\n</ol>\n<p>타입스크립트에서는 집합이라는 개념이 사용되는데, A라는 집합이 B의 부분 집합이면서 동시에 B의 상위 집합이 될 수 없기 때문에 any는 타입 시스템과 상충된다.\nB라는 큰 원에 A가 들어가고, A의 원에 B가 들어가는 모양이다. 말이 안된다.</p>\n<p>unknown은 타입 시스템에 부합한다. any의 첫 번째 특징은 만족하지만, 두 번째 특징은 만족하지 않는다.</p>\n<p>B라는 큰 원이 unknown이고, A라는 작은 원이 어떠한 타입이다.</p>\n<pre><code class=\"language-ts\">let unknownType: unknown\nlet unknownType2: unknown\nlet numberType = 3\n\nunknownType = numberType\nnumberType = unknownType\n//에러가 발생한다.\nunknownType2 = unknownType\n</code></pre>\n<p>numberType에 unkownType을 할당하려고 하면 에러가 발생한다. 그 이유는 더 작은 집합에 큰 집합을 넣으려고 했기 때문이다. 하지만 unknownType에 numberType을 할당할 수는 있다. unknownType이 더 큰 집합이기 때문이다.</p>\n<p>unkown 타입인 채로 값을 사용할 경우 오류가 발생하기 때문에 적절한 타입으로 변환해야 한다.\n적절한 타입으로 변환하는 방법은 아래와 같다.</p>\n<ol>\n<li>타입 단언</li>\n<li>체크를 통해서 원하는 타입으로 변환(예시.instanceof를 사용하여 체크하는)</li>\n<li>사용자 정의 타입가드</li>\n</ol>\n<h1>제너릭 vs unknown</h1>\n<p>제너릭을 사용한 스타일은 unknown 타입을 사용했을 때와 기능적으로는 동일하다.\n책에는 unknown 타입을 사용하는 것이 더 좋다고 하는데 이유는 안나와있다.\nunknown을 뱉는게 더 명시적으로 <strong>알 수 없음</strong>을 알려주어서 그런것인가? 라고 생각해본다.</p>\n<h1>타입 단언의 단언</h1>\n<p>어떠한 타입을 보유한 변수의 타입을 변경해줄 때 타입의 단언의 단언 형태가 많이 사용된다.</p>\n<p>express에서 req.query의 기본적인 타입이 존재되어 있고, 제너릭을 통해서 좁혀야 하지만 타입의 단언의 단언을 활용한 예시를 살펴보자.</p>\n<pre><code class=\"language-ts\">interface QueryParams {\n  code:string\n}\nconst queryAny = req.query as any QueryParams\nconst queryUnknown = req.query as unknown as QueryParams\n</code></pre>\n<p>위의 queryAny와 queryUnkown의 기능은 동일하지만, 리팩토링을 하면서 두 개의 단언문을 분리하는 순간 문제가 발생한다. unknown의 경우 분리하는 순간 에러를 발생시키지만, any는 아니다. 전염병처럼 퍼져나간다..!</p>\n<h1>몽키 패치보다는 안전한 타입을 사용하기</h1>\n<blockquote>\n<p>몽키 패치란 런타임에서 코드의 동작을 업데이트하는 기술을 의미한다.</p>\n</blockquote>\n<p>javascript는 언어가 매우 유연하다. window나 DOM에 접근하여 속성을 추가하거나 변경할 수 있다. 하지만 해당 데이터는 전역 변수가 되기 때문에 어떤 side effect를 발생시킬지 모른다.</p>\n<p>타입스크립트를 사용하면 문제가 더 심각해진다. 런타임에서 추가된 속성에 대해서 알 수 없기 때문이다.</p>\n<p>최선의 해결책은 당연하게 window 또는 DOM으로부터 데이터를 분리하는 것이다. 만일 불가능 할 경우 2가지 차선책이 있다.</p>\n<ol>\n<li>\n<p>interface 보강 기능 사용</p>\n<pre><code class=\"language-ts\">interface Window {\n  monkey?: string\n}\n</code></pre>\n<p>타입이 안전하며 몽키패치가 어떤 부분에 적용되었는지 정확하게 알 수 있다.\n하지만 모듈의 관점에서 제대로 동작하려면 global 선언을 추가해줘야 한다.</p>\n</li>\n<li>\n<p>더 구체적인 타입 단언문을 사용하는 것이다. (any가 아니라!)</p>\n<pre><code class=\"language-ts\">interface MonkeyWindow extends Window {\n  monkey: string\n}\n\nconst monkeyWindow = window as MonkeyWindow\nmonkeyWindow.monkey = \"moonkey\"\n</code></pre>\n<p>모듈 문제 없이 타입을 확장할 수 있다.</p>\n</li>\n</ol>\n<h1>타입 커버리지 추적하여 타입 안정성 유지하기</h1>\n<p>noImplictAny를 사용하더라도 아래 2가지의 경우 막을 수 없다.</p>\n<ol>\n<li>명시적 any</li>\n<li>서드파티 타입 선언</li>\n</ol>\n<p>npm의 type-cover-any 패키지를 이용하여 any의 개수를 추적할 수 있다.\n--detail flag를 붙이면 any 타입이 있는 곳을 모두 출력해준다.</p>\n<p>any 타입 커버리지를 꾸준하게 추적하여 불필요한 any 사용을 줄여야한다.\n(서드파티의 타입 오류가 잡혔을 경우, any로 선언한 변수가 더이상 사용되지 않을 경우)</p>","id":"414b468b-24be-5589-bdcd-6836f05d98b8"},"previous":{"fields":{"slug":"/programming/이펙티브타입스크립트/4장/"},"excerpt":"유효한 상태만 표현하는 타입을 지향하기 유효한 상태만 표현한다는 것의 의미가 무엇일까. 유효하지 않은 상태가 있음으로써 버그가 생기는 것이라고 할 수 있을 것 같다.\n예시를 통해서 이해해보도록 하자. api를 호출하고 비동기적으로 데이터를 받아옴으로써 페이지의 상태를 다음과 같이 표현할 수 있다. 위와 같은 상태 설계는 유효하지 않은 상태가 존재함으로 버그가 생길 수 있다.\n유효하지 않은 상태는 isLoading이 true이고, error 값…","frontmatter":{"date":"2022-12-01T00:00:00.000Z","description":"타입 설계","title":"이펙티브 타입스크립트 4장"},"html":"<h1>유효한 상태만 표현하는 타입을 지향하기</h1>\n<p>유효한 상태만 표현한다는 것의 의미가 무엇일까. 유효하지 않은 상태가 있음으로써 버그가 생기는 것이라고 할 수 있을 것 같다.\n예시를 통해서 이해해보도록 하자.</p>\n<p>api를 호출하고 비동기적으로 데이터를 받아옴으로써 페이지의 상태를 다음과 같이 표현할 수 있다.</p>\n<pre><code class=\"language-ts\">interface State {\n  data?: string\n  isLoading: boolean\n  error?: string\n}\n</code></pre>\n<p>위와 같은 상태 설계는 유효하지 않은 상태가 존재함으로 버그가 생길 수 있다.\n유효하지 않은 상태는 isLoading이 true이고, error 값이 존재한다면 로딩중인지, 에러인지 파악할 수 없다.</p>\n<p>위의 설계 오류를 아래와 같이 수정할 수 있다.</p>\n<pre><code class=\"language-ts\">interface RequestPending {\n  state: \"pending\"\n}\n\ninterface RequestError {\n  state: \"error\"\n  error: string\n}\n\ninterface RequestSuccess {\n  state: \"success\"\n  data: string\n}\n\ntype RequestState = Requestpending | RequestError | RequestSuccess\n</code></pre>\n<p>RequestState를 위와 같이 정의할 경우, state에 따라서 error 속성과 data 속성의 여부가 변경되기 때문에 유효하지 않은 상태를 가지지 않는다.</p>\n<pre><code class=\"language-ts\">interface RequestState {\n  state: \"pending\" | \"error\" | \"success\"\n  error?: string\n  data?: string\n}\n</code></pre>\n<p>위와 같이 정의할 경우, 유효하지 않은 error와 data가 생길 수 있기 때문에 옳지 않다.</p>\n<p>유효하지 않은 상태가 존재하지 않도록 타입을 정의하고, 어떠한 속성의 값에 따라 상태가 변하는 경우 유니온 속성을 이용하여 깔끔하게 분기처리를 해야한다.</p>\n<h1>사용할 때는 너그럽게, 생성할 때는 엄격하게</h1>\n<blockquote>\n<p>포스텔의 법칙: 당신의 작업은 엄격하게 하고, 다른 사람의 작업은 너그럽게 받아들여야 한다.</p>\n</blockquote>\n<p>함수도 마찬가지이다. 매개변수의 타입의 범위는 넓어도 되지만, 결과를 반환할 때는 타입의 범위가 더 구체적이여야 한다.</p>\n<p>결과를 반환하는 값의 타입의 범위가 좁아야 되는 이유는 타입의 범위가 좁아야 함수를 호출부에서 사용이 편리하기 때문이다.</p>\n<pre><code class=\"language-ts\">interface Argument {\n  a: { x: number; y: number } | { x: number; y: number; z: number }\n}\n\ninterface Return {\n  ans:\n    | { a: number; b: number }\n    | { a: number; c: number }\n    | { a: number; d: number }\n}\n\ndeclare function returnVariousType(arg: Argument): Return\n\nfunction someFunc() {\n  const { c } = returnVariousType({ x: 3, y: 3 })\n}\n</code></pre>\n<p>위의 예제에서 someFunc의 c의 경우 undefined가 될 수 있다. 따라서 분기 처리를 통해 c가 존재한다는 있는 것을 확인해주거나, 리턴값에 속성 타입을 명시하여 분기 처리를 해주어야한다.\n정리하자면, 함수를 호출하는 부분에서 사용이 매우 불편하다..!\n다만 매개변수의 타입은 보다 넓게 설정해주어 함수를 호출할 때 편리함을 증가시켜줄 수 있다.</p>\n<h1>문서에 타입 정보 쓰지 않기.</h1>\n<p>주석으로 타입 정보를 선언해주면, 코드를 수정할 때마다 주석도 수정해주어야 한다. 실무에서 동기화가 안될 떄가 많다. 하지만 타입 시스템은 자동으로 동기화된다.</p>\n<p>또한 타입스크립트는 간결하고, 구체적이며, 읽기 편하게 설계되어 있어 굳이 주석이 필요하지 않다.</p>\n<p>변수명을 지을 때도 타입의 단위를 가지고 있다면 굳이 변수명에 넣지 않아도 좋다. 하지만 단위가 무엇인지 확실하지 않다면 변수명에 표현해줘도 좋다. 전자의 예시로는 ageNum, 후자의 예시로는 temperatureC 등이 있다.</p>\n<h1>타입 주변에 null을 배치하기.</h1>\n<p>한 값의 null이 다른 값의 null에 영향을 미치도록 설계하면 안된다.\n그 이유는 한 값이 null일 때, 아닐 때. 다른 값이 null일 때, 아닐 때 4가지 경우가 생성되기 때문이다. 여러가지 경우의 수가 생긴다. 사용부에서 많은 경우의 수에 대한 분기 처리가 필요하게 되고 가독성 있게 표현하기 힘들어 코드가 복잡하고 읽기 힘들게 된다.</p>\n<p>두 값을 하나의 객체로 정의하고 null 혹은 값을 가지는 상태로 정의한다면 위와 같은 오류를 피할 수 있다.</p>\n<h2>함수의 관점</h2>\n<pre><code class=\"language-ts\">function extent(nums: number[]) {\n  let min, max\n  for (let num of nums) {\n    if (!min) {\n      min = num\n      max = num\n    } else {\n      min = Math.min(min, num)\n      max = Math.max(max, num)\n    }\n  }\n}\n</code></pre>\n<p>strickCheckNull을 키고 다음 함수를 호출한다면, max값에 대해서 오류가 발생할 것이다. 초기 null인 max값에 대해서 값의 대입은 이루어졌지만, 타입 시스템의 검증은 수행되지 않았다. if문에서 min에 대한 체크만 이루어졌기 때문에 max 값은 undefined 혹은 number의 타입을 가지게 된다. number의 타입을 기대하고 함수를 사용했다면 곤란한 상황에 처하게 된다.\n또한 js의 특성상 min이 0일 경우, if(!min)의 분기 처리의 로직을 실행하기 때문에 원하는 최솟값과 최댓값이 나오지 않을 수 있다.</p>\n<p>이 때 max에 대한 분기도 넣어줄 수 있지만, 이는 함수의 구현을 복잡하게 할 뿐만 아니라 추가적인 요청사항이 들어올 경우 에러가 발생할 확률을 높인다.</p>\n<p>min과 max를 하나의 객체로 관리하고, 값의 대입이 이루어졌다면 null이 아니도록 처리해주면 위와 같은 문제를 피할 수 있다.</p>\n<pre><code class=\"language-ts\">function extent(nums: number[]) {\n  const results: { min: number; max: number } | null = null\n\n  for (let num of nums) {\n    if (!results) {\n      results = [num, num]\n    } else {\n      results.max = Math.max(results.max, num)\n      results.min = Math.min(results.min, num)\n    }\n  }\n}\n</code></pre>\n<p>위의 경우 min과 max값이 둘다 null로 묶여 있어서 null 체크를 한번만 해주면 min,max값을 사용할 수 있다.</p>\n<pre><code class=\"language-ts\">function extent(nums: number[]) {\n  return { min: Math.min(...nums), max: Math.max(...nums) }\n}\n</code></pre>\n<pre><code class=\"language-ts\">function extent(nums: number[]) {\n  let min = nums[0]\n  let max = nums[0]\n  //... 이하는 아래와 같다.\n}\n</code></pre>\n<p>위의 2개 함수는 사실 null check가 필요없는 content 함수이다. 2번째 함수의 경우 함수의 초기값을 인자의 첫 번째 요소로 초기화 시켜주어 다른 타입을 가질 가능성을 막아버렸다.</p>\n<h2>클래스의 관점</h2>\n<p>클래스의 경우 초기값(null)을 가지고 메소드에 따라서 값이 변화한다고 한다면, 다른 메소드에서 null 체크가 매번 일어나야 하고, 경우의 수가 생기기 때문에 코드가 복잡해진다.\n클래스의 경우 값을 정확히 가질 때 인스턴스를 정의할 수 있도록 함으로써 null 분기에 필요한 로직을 걷어낼 수 있다. 데이터가 부분적으로 준비한 경우를 다루어야 한다면 null과 관련된 부분을 다룰 수 밖에 없긴하다.</p>\n<h1>유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기</h1>\n<p>유니온 타입의 속성을 가지는 인터페이스를 작성 중이라면, 인터페이스의 유니온 타입을 사용하는 게 더 알맞지는 않을지 검토해봐야 한다.</p>\n<p>그 이유는 유니온 타입에 따른 조합이 생겨 다양한 경우의 수가 생기기 때문이다.</p>\n<p>벡터를 그리는 프로그램을 작성중이고, 특정한 기하학적 타입을 가지는 계층의 인터페이스를 정의한다고 가정해보도록 하자.</p>\n<pre><code class=\"language-ts\">interface Layer {\n  layout: FillLayout | LineLayout | PointLayout\n  paint: FillPaint | LinePaint | PointPaint\n}\n</code></pre>\n<p>위의 경우 layout은 LineLayout을 가지고, paint의 경우 PointPaint를 가지는 상태는 말이 안될 것이다. 위의 같은 경우 인터페이스의 유니온을 사용하여 처리해야한다. 태그된 유니온 방식은 타입스크립트의 타입 체커 시스템과 매우 잘맞기 때문에 해당 방식으로 표현할 수 있다면 사용하는 편이 좋다.</p>\n<pre><code class=\"language-ts\">interface FillLayer {\n  type: \"fill\"\n  layout: FillLayout\n  paint: FillPaint\n}\n\ninterface LineLayer {\n  type: \"line\"\n  layout: LineLayout\n  paint: LinePaint\n}\n\ninterface PointLayer {\n  type: \"point\"\n  layout: PointLayout\n  paint: PointPaint\n}\n\ntype Layer = FillLayer | LineLayer | PointLayer\n</code></pre>\n<p>어떠한 2개의 속성이 있고 둘다 같이 존재하거나, 같이 존재하지 않는 상태라고 가정한다면 이전 아이템에서 배운 타입 주변에 null 배치하기 방식을 이용하면 좋다. 2개의 속성을 하나(객체)로 묶는 것이다.</p>\n<pre><code class=\"language-ts\">interface Person {\n  name: string\n  placeOfBirth?: string\n  dateOfBirth?: Date\n}\n\ninterface Person {\n  name: string\n  birth?: {\n    place: string\n    date: Date\n  }\n}\n</code></pre>\n<h1>string 타입보다 더 구체적인 타입 사용하기</h1>\n<p>string 타입보다 구체적인 타입을 사용해야 하는 이유는 string 타입이 너무 크기 때문이다. 한 글자를 가지던 1만 글자를 가진 문장이던 같은 string 타입이다.</p>\n<p>구체적으로 살펴봤을 때 string 타입보다 구체적인 타입을 사용해야 하는 이유는 3가지이다.</p>\n<ol>\n<li>\n<p>타입을 명시적으로 정의함으로써, 다른 곳으로 값이 전달되어도 타입 정보가 유지된다.</p>\n<ul>\n<li>예시로 다른 함수의 인수의 타입으로 사용될 수 있다. 어떤 배열 내 객체의 속성의 특정한 값을 만족하는 요소를 추출하는 함수를 작성한다고 하였을 떄, 해당 함수의 인자로 타입을 이용하면 좋다. (타입이 변경되었을 떄도 유지보수가 편리하다.)</li>\n</ul>\n</li>\n<li>\n<p>타입을 명시적으로 정의하고 해당 타입의 의미를 설명하는 주석을 붙여넣을 수 있다.</p>\n</li>\n<li>\n<p>keyof 연산자로 더욱 세밀하게 객체의 속성 체크가 가능하다. (이 부분이 여기에 왜 있는지는 잘 모르겠다.)</p>\n<pre><code class=\"language-ts\">interface Albums {\n  recordType: \"studio\" | \"live\"\n  name: string\n  releaseDate: Date\n  follower: number\n}\n\nconst albums: Albums[] = [\n  {\n    recordType: \"studio\",\n    name: \"a\",\n    releaseDate: new Date(\"2022-10-11\"),\n    follower: 200,\n  },\n  {\n    recordType: \"live\",\n    name: \"b\",\n    releaseDate: new Date(\"2022-10-12\"),\n    follower: 300,\n  },\n  {\n    recordType: \"studio\",\n    name: \"c\",\n    releaseDate: new Date(\"2022-10-13\"),\n    follower: 400,\n  },\n]\n\nfunction pluck(arr, key) {\n  return arr.map(v => v[key])\n}\nconst dates1 = pluck(albums, \"releaseDate\")\n//dates1은 any[] 타입을 가진다. 또한 pluck 함수의 두 번째 인수도 첫 번쨰 인수가 보유한 속성값이 언어 서비스에 드러나지 않는다.\n\nfunction pluck2&#x3C;T>(arr: T[], key: keyof T) {\n  return arr.map(v => v[key])\n}\n\nconst dates2 = pluck2(albums, \"releaseDate\")\n//dates2 타입은 (string | Date | number)[]이다. 두 번쨰 인수의 경우 첫 번쨰 인수가 보유한 속성값이 언어 서비스에 드러난다.\n//albums의 속성이 가질 수 있는 모든 타입을 가진다. 원활한 사용을 위해서는 타입을 더 좁혀야한다.\n\nfunction pluck3&#x3C;T, K extends keyof T>(arr: T[], key: K) {\n  return arr.map(v => v[key])\n}\n//keyof T의 범위를 더욱 좁혀야 한다. keyof T의 부분 집합으로 두 번째 매개변수를 도입한다.\n\nconst dates3 = pluck3(albums, \"releaseDate\")\n//dates3의 타입은 Date[]이다. 언어 서비스를 이용하며 명확하게 좁혀진 타입의 결과를 얻어낼 수 있다.\n</code></pre>\n</li>\n</ol>\n<h1>부정확한 타입보다는 미완성 타입을 사용하기</h1>\n<p>타입의 선언의 정밀도를 높이는 일에는 주의를 기울여야 한다. 실수가 발생할 수 있고 잘못된 타입은 있는 것 보다 못하기 때문이다.</p>\n<pre><code class=\"language-ts\">interface Geometry {\n  coordinate: number[] | number[][] | number[][][]\n}\n</code></pre>\n<p>위와 같은 코드에서 coordinate가 위도, 경도로 이루어져있다고 생각하고 타입이 너무 크다고 판단하여 [number, number] 타입으로 변형하였다. 기존에 고도라는 개념이 있어 number[]라고 표현이 되어있던 것이고, 모든 코드에 오류가 발생하게 된다.</p>\n<p>타입을 정교하게 만들어서 부정확함을 바로잡는 방법 대신 테스트를 추가하여 놓친 부분이 없는지 확인하는 방식을 사용해도 좋다. 타입을 정제할 때, 볼쾌한 골짜기 은유를 생각해보면 도움이 될 수 있다.</p>\n<h1>데이터가 아닌 API와 명세를 보고 타입 만들기</h1>\n<p>API 명세서를 읽어보지 않고 데이터만을 받아서 타입을 작성했을 때 예상치않은 오류가 발생할 수 있다.\nAPI 명세서를 참고해서 타입을 만들거나, 공식 타입 선언을 다운로드 받아서 사용하면 좋다.</p>\n<h1>해당 분야의 용어로 타입 이름 짓기</h1>\n<p>해당 분야의 용어는 몇십년에 지나면서 다듬어져 왔다. 가독성을 더 높여준다.</p>\n<p>또한 이미 체계적으로 분류가 잡혀져 있는 경우가 있다. 기후라는 타입을 정의하기 위해서는 미리 정의된 쾨펜 기후 분류 등을 사용하면 편리하고 유지보수에 용이하다.\n유지보수에 용이한 이유는 코드를 작성한 사람에게 조언을 구할 필요가 없기 때문이다.</p>\n<p>동일한 의미를 나타날 때는 꼭 같은 단어를 사용해야한다.</p>\n<h1>공식 명칭에는 상표 붙이기</h1>\n<p>구조적 타이핑의 특성 때문에 가끔 코드가 이상한 결과를 낼 수 있다.</p>\n<pre><code class=\"language-ts\">interface Vector2D {\n  x: number\n  y: number\n}\n\nfunction calculateNorm(p: Vector2D) {\n  return Math.sqrt(p.x * p.x + p.y * p.y)\n}\n\nconst vector3D = { x: 1, y: 2, z: 5 }\ncalculateNorm(vector3D)\n</code></pre>\n<p>위의 코드는 구조적 타이핑 관점에서 오류가 발생하지 않는다. 하지만 수학적으로 따지면 2차원 벡터를 사용하는 것이 이치에 맞다.\n3차원 벡터를 허용하지 않게 하려면 공식 명칭을 사용하면 된다.\n값의 관점에서 vector2D라고 정의해주는 것이다. 타입스크립트에서 흉내내기 위해서는 상표를 붙이면 된다.</p>\n<pre><code class=\"language-ts\">interface Vector2D {\n  _brand: \"2d\"\n  x: number\n  y: number\n}\n\ncalculateNorm({ x: 1, y: 2, _brand: \"2d\" }) //1\ncalculateNorm({ x: 1, y: 2, z: 5, _brand: \"2d\" }) //2\n</code></pre>\n<p>2번째 함수 호출부에서 처럼 악의적으로 공식 명칭을 흉내내는 것을 방지하지는 못한다. 다만 프로그래머에게 실수를 알려주기에는 충분하다.</p>\n<p>상표 기법은 타입 시스템에서 동작하지만 런타임에 상표를 검사하는 것과 동일한 효과를 얻을 수 있다. 타입 시스템으로 런타임 오버헤드가 없고 속성이 없는 string 또는 number와 같은 내장 타입도 상표화 할 수 있다.</p>\n<p>절대 경로를 이용하여 파일 시스템에 접근하는 함수를 통해서 가정해보자.\n런타임에는 절대 경로로 시작하는지 체크하기가 쉽지만, 타입 시스템에서는 판단하기 어렵기 때문에 상표 기법을 사용한다.</p>\n<pre><code class=\"language-ts\">type AbsolutePath = string &#x26; { _brand: \"abs\" }\nfunction listAbsolutePath(path: AbsolutePath) {}\nfunction isAbsolutePath(path: string): path is AbsolutePath {\n  return path.startsWith(\"/\")\n}\n</code></pre>\n<p>AbsolutePath 타입의 경우 string이면서 _brand 속성을 가지는 객체라는게 애초에 말이 안된다. 온전히 타입 시스템의 영역이다.</p>\n<p>만일 절대경로인지, 상대경로인지 확실하지 않다면 타입 가드를 사용해서 오류를 방지할 수 있다.</p>\n<pre><code class=\"language-ts\">function someFunc(path: string) {\n  if (isAbsolutePath(path)) {\n    listAbsolutePath(path)\n  }\n}\n</code></pre>\n<p>로직 분기 대신 타입 단언문을 사용해도 되지만, 타입 단언문은 사용을 지양해야한다.</p>\n<p>추가적인 예시로는 오름차순으로 정렬된 배열인지 체크하는 타입이다.</p>\n<pre><code class=\"language-ts\">type SortedList&#x3C;T> = T[] &#x26; { _brand: \"sorted\" }\nfunction isSorted&#x3C;T>(arr: T[]): arr is SortedList&#x3C;T> {\n  for (let i = 1; i &#x3C; arr.length; i++) {\n    if (arr[i - 1] > arr[i]) return false\n  }\n  return false\n}\n\nfunction binarySearch&#x3C;T>(arr: SortedList&#x3C;T>, target: number): number {\n  //....\n}\n</code></pre>","id":"93f20b56-f5b3-56b5-baf6-201ed50da5de"},"next":{"fields":{"slug":"/programming/쓰로들링,디바운싱/"},"excerpt":"쓰로들링과 디바운싱 개념이 가끔 서로 헷갈릴 떄가 있어서 글을 통해서 정리하도록 한다.\n두 기법 모두 불필요한 함수 호출 횟수를 줄여주기 위해 고안되었다. 쓰로들링 함수가 호출된 후, 정해진 시간 내에 동일한 함수를 호출할 경우 실행하지 않도록 하는 것이다. 위투디 프로젝트에 적용해본 부분은 디자인 에디터의 창 크기가 resize 될 때마다 동적으로 캔버스 크기와 이미지 크기들을 변경시키는데 사용이 되었다. 디바운싱이 아닌 쓰로들링으로 적용한…","frontmatter":{"date":"2022-12-05T00:00:00.000Z","description":"쓰로들링, 디바운싱 개념과 활용","title":"쓰로들링과 디바운싱"},"html":"<p>쓰로들링과 디바운싱 개념이 가끔 서로 헷갈릴 떄가 있어서 글을 통해서 정리하도록 한다.\n두 기법 모두 불필요한 함수 호출 횟수를 줄여주기 위해 고안되었다.</p>\n<h1>쓰로들링</h1>\n<p>함수가 호출된 후, 정해진 시간 내에 동일한 함수를 호출할 경우 실행하지 않도록 하는 것이다.</p>\n<p>위투디 프로젝트에 적용해본 부분은 디자인 에디터의 창 크기가 resize 될 때마다 동적으로 캔버스 크기와 이미지 크기들을 변경시키는데 사용이 되었다.</p>\n<p>디바운싱이 아닌 쓰로들링으로 적용한 이유는, 브라우저의 창 크기가 작아지면서 캔버스 크기도 작아지는 모습을 보여주어야 하기 때문이다. 만일 디바운싱을 적용했다면 창 크기가 작아짐에도 불구하고 캔버스 크기는 계속 동일하다가 마지막에야 사이즈가 맞춰졌을 것이다.</p>\n<p>정리하자면 연속적인 이벤트가 발생하는데 이벤트가 발생하는 모습을 드문드문 보여줘야 할 때 사용한다고 할 수 있다. 예를 들어 스크롤 이벤트가 있다.</p>\n<h3>자바스크립트 예시</h3>\n<pre><code class=\"language-js\">function throttle(cb, time = 3000) {\n  let timer\n  return function (...args) {\n    if (!timer) {\n      timer = setTimeout(() => {\n        cb.apply(this, args)\n        timer = null\n      }, time)\n    }\n  }\n}\n</code></pre>\n<h3>React 예시</h3>\n<pre><code class=\"language-tsx\">const [timer, setTimer] = useState&#x3C;NodeJS.Timeout>()\nconst handleSomethingUsingThrottling = time => {\n  if (!timer) {\n    const newTimer = setTimeout(() => {\n      //doSomething\n      setTimer(null)\n    }, time)\n    setTimer(newTimer)\n  }\n}\n</code></pre>\n<h1>디바운싱</h1>\n<p>디바운싱의 경우 연속적인 함수 호출 중에서 가장 마지막 혹은 처음의 함수를 호출하는 것이다.</p>\n<p>디바운싱이 주로 적용되는 부분은 검색 부분이다. 타이핑을 하는 동안은 검색에 대한 결과를 굳이 보여줄 큰 필요는 없으며 검색의 통신 비용이 꽤 크다고 생각하기 때문이다. 물론 쓰로들링으로 적용해도 관계없다.</p>\n<h3>자바스크립트 에시</h3>\n<pre><code class=\"language-js\">function debounce(cb, time = 3000) {\n  let timer\n\n  return function (...args) {\n    clearTimeout(timer)\n\n    timer = setTimeout(() => {\n      cb.apply(this, args)\n    }, time)\n  }\n}\n\n//사용 에시\nconst debounceFunc = debounce(value => {\n  console.log(value)\n})\n\nfor (let i = 0; i &#x3C; 10; i++) {\n  debounceFunc(i)\n}\n//9가 출력된다.\n</code></pre>\n<h3>리액트 예시</h3>\n<pre><code class=\"language-tsx\">const [timer, setTimer] = useState&#x3C;NodeJS.Timeout>()\nconst handleSomethingUsingDebouncing = time => {\n  clearTimeout(timer)\n  const newTimer = setTimeout(() => {\n    //doSomething...\n  }, time)\n  setTimer(newTimer)\n}\n</code></pre>","id":"53860c9a-c00f-5ec9-8dd6-4d2099991fef"}}},"staticQueryHashes":["4031756233","4237942306"],"slicesMap":{}}