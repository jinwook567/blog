{"componentChunkName":"component---src-templates-post-template-tsx","path":"/programming/쓰로들링,디바운싱/","result":{"pageContext":{"node":{"fields":{"slug":"/programming/쓰로들링,디바운싱/"},"excerpt":"쓰로들링과 디바운싱 개념이 가끔 서로 헷갈릴 떄가 있어서 글을 통해서 정리하도록 한다.\n두 기법 모두 불필요한 함수 호출 횟수를 줄여주기 위해 고안되었다. 쓰로들링 함수가 호출된 후, 정해진 시간 내에 동일한 함수를 호출할 경우 실행하지 않도록 하는 것이다. 위투디 프로젝트에 적용해본 부분은 디자인 에디터의 창 크기가 resize 될 때마다 동적으로 캔버스 크기와 이미지 크기들을 변경시키는데 사용이 되었다. 디바운싱이 아닌 쓰로들링으로 적용한…","frontmatter":{"date":"2022-12-05T00:00:00.000Z","description":"쓰로들링, 디바운싱 개념과 활용","title":"쓰로들링과 디바운싱"},"html":"<p>쓰로들링과 디바운싱 개념이 가끔 서로 헷갈릴 떄가 있어서 글을 통해서 정리하도록 한다.\n두 기법 모두 불필요한 함수 호출 횟수를 줄여주기 위해 고안되었다.</p>\n<h1>쓰로들링</h1>\n<p>함수가 호출된 후, 정해진 시간 내에 동일한 함수를 호출할 경우 실행하지 않도록 하는 것이다.</p>\n<p>위투디 프로젝트에 적용해본 부분은 디자인 에디터의 창 크기가 resize 될 때마다 동적으로 캔버스 크기와 이미지 크기들을 변경시키는데 사용이 되었다.</p>\n<p>디바운싱이 아닌 쓰로들링으로 적용한 이유는, 브라우저의 창 크기가 작아지면서 캔버스 크기도 작아지는 모습을 보여주어야 하기 때문이다. 만일 디바운싱을 적용했다면 창 크기가 작아짐에도 불구하고 캔버스 크기는 계속 동일하다가 마지막에야 사이즈가 맞춰졌을 것이다.</p>\n<p>정리하자면 연속적인 이벤트가 발생하는데 이벤트가 발생하는 모습을 드문드문 보여줘야 할 때 사용한다고 할 수 있다. 예를 들어 스크롤 이벤트가 있다.</p>\n<h3>자바스크립트 예시</h3>\n<pre><code class=\"language-js\">function throttle(cb, time = 3000) {\n  let timer\n  return function (...args) {\n    if (!timer) {\n      timer = setTimeout(() => {\n        cb.apply(this, args)\n        timer = null\n      }, time)\n    }\n  }\n}\n</code></pre>\n<h3>React 예시</h3>\n<pre><code class=\"language-tsx\">const [timer, setTimer] = useState&#x3C;NodeJS.Timeout>()\nconst handleSomethingUsingThrottling = time => {\n  if (!timer) {\n    const newTimer = setTimeout(() => {\n      //doSomething\n      setTimer(null)\n    }, time)\n    setTimer(newTimer)\n  }\n}\n</code></pre>\n<h1>디바운싱</h1>\n<p>디바운싱의 경우 연속적인 함수 호출 중에서 가장 마지막 혹은 처음의 함수를 호출하는 것이다.</p>\n<p>디바운싱이 주로 적용되는 부분은 검색 부분이다. 타이핑을 하는 동안은 검색에 대한 결과를 굳이 보여줄 큰 필요는 없으며 검색의 통신 비용이 꽤 크다고 생각하기 때문이다. 물론 쓰로들링으로 적용해도 관계없다.</p>\n<h3>자바스크립트 에시</h3>\n<pre><code class=\"language-js\">function debounce(cb, time = 3000) {\n  let timer\n\n  return function (...args) {\n    clearTimeout(timer)\n\n    timer = setTimeout(() => {\n      cb.apply(this, args)\n    }, time)\n  }\n}\n\n//사용 에시\nconst debounceFunc = debounce(value => {\n  console.log(value)\n})\n\nfor (let i = 0; i &#x3C; 10; i++) {\n  debounceFunc(i)\n}\n//9가 출력된다.\n</code></pre>\n<h3>리액트 예시</h3>\n<pre><code class=\"language-tsx\">const [timer, setTimer] = useState&#x3C;NodeJS.Timeout>()\nconst handleSomethingUsingDebouncing = time => {\n  clearTimeout(timer)\n  const newTimer = setTimeout(() => {\n    //doSomething...\n  }, time)\n  setTimer(newTimer)\n}\n</code></pre>","id":"53860c9a-c00f-5ec9-8dd6-4d2099991fef"},"previous":{"fields":{"slug":"/programming/이펙티브타입스크립트/5장/"},"excerpt":"처음에 타입스크립트를 사용했을 때 잘몰라서 any 키워드를 가끔 사용하곤 했다.\nany는 타입 시스템을 뭉개버리기 때문에 최소한으로 사용을 해야한다. any 키워드로 정의된 변수는 프로젝트 내에서 전염병처럼 퍼져나갈 수 있다...\nany를 잘 다루는 방법에 대해서 알아보도록 하자. any 타입은 가능한 좁은 범위에서만 사용하기 any를 사용해서 타입 시스템의 오류를 피하고자 아래와 같은 두가지 방식으로 처리하였다. 어떤 것이 더 좋은 해결책일…","frontmatter":{"date":"2022-12-02T00:00:00.000Z","description":"any 다루기","title":"이펙티브 타입스크립트 5장"},"html":"<p>처음에 타입스크립트를 사용했을 때 잘몰라서 any 키워드를 가끔 사용하곤 했다.\nany는 타입 시스템을 뭉개버리기 때문에 최소한으로 사용을 해야한다. any 키워드로 정의된 변수는 프로젝트 내에서 전염병처럼 퍼져나갈 수 있다...\nany를 잘 다루는 방법에 대해서 알아보도록 하자.</p>\n<h1>any 타입은 가능한 좁은 범위에서만 사용하기</h1>\n<p>any를 사용해서 타입 시스템의 오류를 피하고자 아래와 같은 두가지 방식으로 처리하였다. 어떤 것이 더 좋은 해결책일까?</p>\n<pre><code class=\"language-ts\">function f1() {\n  const x: any = expressionReturingFoo()\n  expectAoo(x) //error\n}\n\nfunction f2() {\n  const x = expressionReturingFoo()\n  expectAoo(x as any) //error\n}\n</code></pre>\n<p>f2 함수가 더 나은 선택이다. 그 이유는 any의 범위를 좁혔기 때문이다. f1의 로직이 길어질 경우 x는 f1 함수의 스코프 내에서 모두 any로 정의된다. 하지만 f2의 경우에는 expectAoo 함수에 매개변수만 any로써 정의되기 때문에 추가적으로 발생할 수 있는 오류를 줄여준다.</p>\n<h2>객체에서 any가 필요할 경우</h2>\n<p>객체의 속성에서 any가 필요할 경우 객체 전체를 any로 설정하는 것은 바람직하지 않다. 객체의 속성값만 any로 설정해주는 것이 좋다.</p>\n<pre><code class=\"language-ts\">const configGood = {\n  a: 1,\n  b: 2,\n  c: {\n    key: value as any,\n  },\n}\n\nconst configBad = {\n  a: 1,\n  b: 2,\n  c: {\n    key: value,\n  },\n} as any\n</code></pre>\n<h1>any를 구체적으로 변형해서 사용하기.</h1>\n<p>any를 사용하되 any를 모델링 할 수 있다면 모델링 하는 편이 좋다.</p>\n<pre><code class=\"language-ts\">function getLengthBad(arr: any) {\n  return array.length\n}\n\nfunction getLengthGood(arr: any[]) {\n  return array.length\n}\n</code></pre>\n<p>getLengthGood의 경우 함수의 매개변수가 배열이라는 형태를 알 수 있기 때문에 getLengthGood의 결과값이 number라는 타입을 가지게 되고, 매개변수도 배열인지 확인하게 된다.</p>\n<h2>객체에서</h2>\n<p>객체이고 값을 알 수 없다면 <code>{[key:string] :any}</code> 처럼 선언하면 된다.\nobject 타입도 가능하지만, 객체의 키를 열거 가능하지만 속성에 접근은 할 수 없다는 점에서 차이가 있다.</p>\n<h2>함수에서</h2>\n<pre><code class=\"language-ts\">type Fn0 = () => any\ntype Fn1 = (args: any[]) => any\n</code></pre>\n<p>Fn1의 경우 매개변수가 배열이라는 것을 알 수 있다는 장점이 있다.</p>\n<h1>함수 안으로 타입 단언문 감추기</h1>\n<p><strong>불가피하게 타입 선먼문을 사용해야 한다면, 정확한 정의를 가지는 함수 안으로 숨겨야한다.</strong></p>\n<p>함수의 모든 부분을 안전한 타입으로 구현하는 것이 이상적이다만, 불필요한 시간이 들 수 있다. 함수 내부에는 타입 단언을 사용하고 배출값의 타입 정의를 정확히 명시하는 정도로 하면 효율적이다.</p>\n<p>함수 캐싱 예시를 통해서 알아보도록 하겠다.</p>\n<pre><code class=\"language-ts\">function shallowEqual(a: any, b: any) {\n  return a === b\n}\n\nfunction cacheLast&#x3C;T extends Function>(fn: T): T {\n  let lastArg: any[] | null = null\n  let lastResult: any\n\n  return function (arg: any) {\n    if (!lastArg || !shallowEqual(lastArg, arg)) {\n      lastResult = fn(arg)\n      lastArg = arg\n    }\n    return lastResult\n  } as unknown as T\n}\n</code></pre>\n<h1>any의 진화</h1>\n<p>타입스크립트에서 변수의 타입은 변수를 선언할 때 결정된다. 정제(null, undefined)될 수는 있으나 새로운 값이 추가되도록 확장할 수는 없다. 하지만 any는 예외적인 케이스가 존재한다.</p>\n<pre><code class=\"language-ts\">function makeArr(num: number) {\n  const arr = []\n  for (let i = 0; i &#x3C; num; i++) {\n    arr.push(i)\n  }\n  return arr\n}\n</code></pre>\n<p>위의 예시에서 arr이 선언된 부분에서는 any[] 이지만, 리턴할 때 arr는 number[]로 정의된다.\narr에 number 속성의 인자를 넣는 순간 number[]로 진화한다.</p>\n<p>만약에 number가 아닌 다른 속성을 넣어보면 어떨까?</p>\n<pre><code class=\"language-ts\">function makeArr(num: number) {\n  const arr = []\n  for (let i = 0; i &#x3C; num; i++) {\n    arr.push(i % 2 === 0 ? i : `${i}`)\n  }\n  return arr\n}\n</code></pre>\n<p>arr은 (num | string)[]가 된다.</p>\n<p>any 타입의 진화는 noImplictAny가 false로 설정되었고, 변수의 타입이 암시적 any일 경우에만 일어난다. 명시적으로 타입을 선언해주면 타입은 유지가 된다. 암시적 any는 함수 호출을 거쳐도 진화하지 않는다.</p>\n<p>암시적 any를 진화시키는 것보다 명시적으로 타입을 선언해주는 것이 좋다. 위의 예제의 경우 map 메소드를 사용한다면 문제를 해결할 수 있다.</p>\n<h1>모르는 타입에는 any 대신 unknown 사용하기</h1>\n<p>함수의 반환타입으로 any를 사용하는 것은 좋지 않다. 대신에 호출한 부분에서 반환값을 원하는 타입으로 설정하도록 하는 것이 더 이상적이다. unknown 타입을 반환함으로써 사용부에서 타입을 강제로 설정하도록 할 수 있다.</p>\n<p>any의 위험한 이유는 아래 두가지 특징을 가지기 때문이다.</p>\n<ol>\n<li>어떠한 타입이던 any에 할당 가능하다.</li>\n<li>any 타입은 어떠한 타입으로도 할당 가능하다.</li>\n</ol>\n<p>타입스크립트에서는 집합이라는 개념이 사용되는데, A라는 집합이 B의 부분 집합이면서 동시에 B의 상위 집합이 될 수 없기 때문에 any는 타입 시스템과 상충된다.\nB라는 큰 원에 A가 들어가고, A의 원에 B가 들어가는 모양이다. 말이 안된다.</p>\n<p>unknown은 타입 시스템에 부합한다. any의 첫 번째 특징은 만족하지만, 두 번째 특징은 만족하지 않는다.</p>\n<p>B라는 큰 원이 unknown이고, A라는 작은 원이 어떠한 타입이다.</p>\n<pre><code class=\"language-ts\">let unknownType: unknown\nlet unknownType2: unknown\nlet numberType = 3\n\nunknownType = numberType\nnumberType = unknownType\n//에러가 발생한다.\nunknownType2 = unknownType\n</code></pre>\n<p>numberType에 unkownType을 할당하려고 하면 에러가 발생한다. 그 이유는 더 작은 집합에 큰 집합을 넣으려고 했기 때문이다. 하지만 unknownType에 numberType을 할당할 수는 있다. unknownType이 더 큰 집합이기 때문이다.</p>\n<p>unkown 타입인 채로 값을 사용할 경우 오류가 발생하기 때문에 적절한 타입으로 변환해야 한다.\n적절한 타입으로 변환하는 방법은 아래와 같다.</p>\n<ol>\n<li>타입 단언</li>\n<li>체크를 통해서 원하는 타입으로 변환(예시.instanceof를 사용하여 체크하는)</li>\n<li>사용자 정의 타입가드</li>\n</ol>\n<h1>제너릭 vs unknown</h1>\n<p>제너릭을 사용한 스타일은 unknown 타입을 사용했을 때와 기능적으로는 동일하다.\n책에는 unknown 타입을 사용하는 것이 더 좋다고 하는데 이유는 안나와있다.\nunknown을 뱉는게 더 명시적으로 <strong>알 수 없음</strong>을 알려주어서 그런것인가? 라고 생각해본다.</p>\n<h1>타입 단언의 단언</h1>\n<p>어떠한 타입을 보유한 변수의 타입을 변경해줄 때 타입의 단언의 단언 형태가 많이 사용된다.</p>\n<p>express에서 req.query의 기본적인 타입이 존재되어 있고, 제너릭을 통해서 좁혀야 하지만 타입의 단언의 단언을 활용한 예시를 살펴보자.</p>\n<pre><code class=\"language-ts\">interface QueryParams {\n  code:string\n}\nconst queryAny = req.query as any QueryParams\nconst queryUnknown = req.query as unknown as QueryParams\n</code></pre>\n<p>위의 queryAny와 queryUnkown의 기능은 동일하지만, 리팩토링을 하면서 두 개의 단언문을 분리하는 순간 문제가 발생한다. unknown의 경우 분리하는 순간 에러를 발생시키지만, any는 아니다. 전염병처럼 퍼져나간다..!</p>\n<h1>몽키 패치보다는 안전한 타입을 사용하기</h1>\n<blockquote>\n<p>몽키 패치란 런타임에서 코드의 동작을 업데이트하는 기술을 의미한다.</p>\n</blockquote>\n<p>javascript는 언어가 매우 유연하다. window나 DOM에 접근하여 속성을 추가하거나 변경할 수 있다. 하지만 해당 데이터는 전역 변수가 되기 때문에 어떤 side effect를 발생시킬지 모른다.</p>\n<p>타입스크립트를 사용하면 문제가 더 심각해진다. 런타임에서 추가된 속성에 대해서 알 수 없기 때문이다.</p>\n<p>최선의 해결책은 당연하게 window 또는 DOM으로부터 데이터를 분리하는 것이다. 만일 불가능 할 경우 2가지 차선책이 있다.</p>\n<ol>\n<li>\n<p>interface 보강 기능 사용</p>\n<pre><code class=\"language-ts\">interface Window {\n  monkey?: string\n}\n</code></pre>\n<p>타입이 안전하며 몽키패치가 어떤 부분에 적용되었는지 정확하게 알 수 있다.\n하지만 모듈의 관점에서 제대로 동작하려면 global 선언을 추가해줘야 한다.</p>\n</li>\n<li>\n<p>더 구체적인 타입 단언문을 사용하는 것이다. (any가 아니라!)</p>\n<pre><code class=\"language-ts\">interface MonkeyWindow extends Window {\n  monkey: string\n}\n\nconst monkeyWindow = window as MonkeyWindow\nmonkeyWindow.monkey = \"moonkey\"\n</code></pre>\n<p>모듈 문제 없이 타입을 확장할 수 있다.</p>\n</li>\n</ol>\n<h1>타입 커버리지 추적하여 타입 안정성 유지하기</h1>\n<p>noImplictAny를 사용하더라도 아래 2가지의 경우 막을 수 없다.</p>\n<ol>\n<li>명시적 any</li>\n<li>서드파티 타입 선언</li>\n</ol>\n<p>npm의 type-cover-any 패키지를 이용하여 any의 개수를 추적할 수 있다.\n--detail flag를 붙이면 any 타입이 있는 곳을 모두 출력해준다.</p>\n<p>any 타입 커버리지를 꾸준하게 추적하여 불필요한 any 사용을 줄여야한다.\n(서드파티의 타입 오류가 잡혔을 경우, any로 선언한 변수가 더이상 사용되지 않을 경우)</p>","id":"414b468b-24be-5589-bdcd-6836f05d98b8"},"next":{"fields":{"slug":"/tech/yarnberry/"},"excerpt":"패키지 매니저 공부 배경 위투디 프로젝트에서 사용했던 기술을 바탕으로 2개의 프로젝트를 진행해보려고 한다.\n2개의 프로젝트 모두 웹에서 디자인 할 수 있는 canvas api를 사용하기 때문에 두 프로젝트가 컴포넌트를 공유하여 사용할 수 있도록 제작하려 한다.\n물론 버튼이나, 레이아웃 등의 기타 컴포넌트도 공통적으로 관리하여 개발 생산성을 높일 것이다. 이런 공통적인 기능을 어떻게 유지할까 고민해봤다. 패키지로 만들어서 관리하는 방식. 모노레…","frontmatter":{"date":"2022-12-07T00:00:00.000Z","description":"Yarn Berry는 왜 사용하는걸까?","title":"package manager"},"html":"<h1>패키지 매니저 공부 배경</h1>\n<p>위투디 프로젝트에서 사용했던 기술을 바탕으로 2개의 프로젝트를 진행해보려고 한다.\n2개의 프로젝트 모두 웹에서 디자인 할 수 있는 canvas api를 사용하기 때문에 두 프로젝트가 컴포넌트를 공유하여 사용할 수 있도록 제작하려 한다.\n물론 버튼이나, 레이아웃 등의 기타 컴포넌트도 공통적으로 관리하여 개발 생산성을 높일 것이다.</p>\n<p>이런 공통적인 기능을 어떻게 유지할까 고민해봤다.</p>\n<ol>\n<li>패키지로 만들어서 관리하는 방식.</li>\n<li>모노레포 방식.</li>\n</ol>\n<p>1번인 패키지로 만들어서 관리하는 방식은 공통적인 기능(컴포넌트)이 변경이 되면 패키지를 다시 빌드해줘야 한다. 이렇게 되면 패키지 버전이 달라지게 되고 2개의 프로젝트 모두 패키지를 업데이트 해줘야한다.\n개발을 하면서 공통적인 기능의 수정이 빈번하게 일어날 것 같은데 이 과정이 매우 번거롭다고 생각했다.</p>\n<p>2번인 모노레포 방식을 사용하기로 결심했다!</p>\n<p>빅테크 기업들의 모노레포 도입기를 보니까 yarn berry의 workspaces 기능을 많이 사용하였다.\n나는 npm을 사용했기에 이번 기회에 패키지 매니저에 대해서 공부해야겠다고 생각했다.</p>\n<h1>yarn classic</h1>\n<p>yarn은 기존에 npm이 있었음에도 불구하고 왜 개발되었을까?</p>\n<ul>\n<li>병렬화를 통해서 다운로드 속도를 개선한다.</li>\n<li>lock 파일을 자동으로 생성(npm의 경우 과거에는 자동으로 생성을 지원하지 않았으나 현재는 지원함.)\n<ul>\n<li>package.json에는 버전의 정확한 버전이 아니라, 버전의 범위가 명시되어 있다. 패키지의 버그가 수정되어 버전이 올라갔을 때, 범위로 명시 되었기에 매번 패키지의 릴리즈에 대해서 추적하지 않아도 된다.</li>\n<li>package-lock.json에는 의존성 트리에 대한 정보가 담겨있으며 node_modules의 트리나 package.json이 수정되었을 때 자동으로 생성된다. 의존성 트리에 대한 정보가 있음으로써 npm install 했을 때 동일한 환경을 구성하도록 도와준다.</li>\n</ul>\n</li>\n<li>의존성 트리 알고리즘 변경\n<ul>\n<li>의존성 트리가 덜 변경되도록 함. npm의 경우 다운로드 순서에 따라서 의존성 트리가 변경되는 경우가 있음.</li>\n</ul>\n</li>\n<li>캐시 사용.</li>\n</ul>\n<p>yarn은 현재 2020년 부터 유지보수 단계이다. 1.x 버전은 모두 레거시로 간주한다.\n장기적으로 프로젝트를 진행한다면 yarn berry를 사용하는 편이 좋아보인다.</p>\n<h1>pnpm</h1>\n<p>2017년에 제작되었으며 npm이 보유한 문제점을 해결한 대체품으로 npm만 있으면 사용 가능하다.</p>\n<p>pnpm은 2가지 문제를 해결한다.</p>\n<ol>\n<li>패키지 중복 다운로드 문제</li>\n<li>유령 의존성 문제 해결</li>\n</ol>\n<h2>1. 패키지 중복 다운로드 문제</h2>\n<p>만일 100개의 프로젝트가 동일한 dependency를 사용하고 있다고 가정하면, 모든 프로젝트에 해당 dependency를 다운로드 해주어야 한다.\npnpm 개발자들은 이러한 행위가 불필요하다고 생각했다.</p>\n<p>pnpm을 사용하면 의존성이 content-addressable에 저장이 된다. 모든 파일은 디스크 상에서 단일 위치에 저장되고, 패키지가 설치될 때 그 파일들은 단일 위치에서 하드 링크되고 추가적인 디스크 공간을 소비하지 않는다.\n중복된 패키지 설치를 줄이기 때문에 많은 디스크 공간을 세이브 할 수 있고 새롭게 패키지를 구성할 때 필요한 다운로드 수를 줄여 빠른 다운로드가 가능하다.</p>\n<p>pnpm은 프로젝트 수가 많아질수록 그 위력이 강력해지는 것 같다.</p>\n<h2>2. 유령 의존성 문제 해결</h2>\n<p>npm과 yarn classic의 경우 의존성을 위해 다운로드 되는 패키지의 중복 저장을 막기위해 평탄화 작업을 한다.\n평탄화 작업이란 중복되는 패키지를 위로 끌어올리는 작업을 의미한다.</p>\n<p>만일 A가 B라는 패키지에 의존을 하고있고 C라는 패키지가 A라는 패키지에 의존하고 있을 때, 평탄화 작업이 일어나지 않는다면 B 패키지의 경우 중복 저장된다.\n평탄화 작업을 통해서 중복 저장은 피했지만, 유령 의존성이라는 문제가 생기게 된다. package.json에 명시되어 있지 않은 B라는 패키지에 바로 접근할 수 있게 되는 것이다.</p>\n<p>pnpm은 symlink를 사용하여 프로젝트의 직접적인 의존성 만을 모듈 디렉토리의 루트로 추가하여 이러한 문제를 해결한다.</p>\n<p>프로젝트의 의존성 정보를 symlink로 정확하게 dependencies의 중첩된 구조를 생성한다.\nsymlink를 이용한 방식이 가능한 이유는 단일 출처에 저장되어, 끌어올리는 평탄화 작업이 필요없기 때문이다.</p>\n<p>A 패키지의 의존성을 가지는 B 패키지를 설치한다고 가정해보자.</p>\n<p>node_modules 폴더 아래 .pnpm이라는 폴더가 있다. 해당 폴더에는 A 패키지와 B 패키지가 담기게 되고, B 패키지에는 필요한 A 패키지에 대한 심볼릭 링크가 된다.\n그 다음으로는 직접 의존성이 처리된다. B 패키지는 node_modules에 심볼릭 링크된다. node_modules는 B라는 패키지 정보만 보유하고 있기 때문에 유령 의존성 문제가 발생하지 않는다.</p>\n<h1>yarn berry</h1>\n<p>yarn berry는 yarn classic의 업그레이드 버전이다.</p>\n<p>yarn berry는 node_modules를 아에 없애버리고자 하고 있다.\nnode_modules를 왜 없애버릴려고 했을까?</p>\n<h2>비효율적인 의존성 검색</h2>\n<p>node_modules는 복잡한 폴더 구조이다. 그리고 npm은 파일을 찾기위해 node의 파일 시스템을 사용한다.\n필요한 파일을 찾기위해 상위 폴더 순회를 반복한다. 하지만 yarn berry의 경우 의존성을 관리하기위해 <code>.pnp.cjs</code>라는 파일을 사용하는데 이는 중첩된 폴더 구조가 아닌 단일 파일로 디스크 I/O없이 빠르게 의존성 검색이 가능하다.</p>\n<h2>무거운 node_modules</h2>\n<p>기존에는 간단한 프로젝트를 하려고 해도 수백 메가바이트에 달하는 node_modules를 설치해야했다.\n하지만 yarn은 의존성을 <code>.yarn/cache</code> 폴더 아래 zip 파일로 관리하여 디스크 공간을 많이 세이브 할 수 있고, 의존성 패키지 다운로드 속도를 대폭 줄일 수 있다.\n또한 zip 파일로 관리가 되기에 의존성을 구성하는 파일의 수가 많지 않으므로 변경 사항을 감지하거나 의존성을 삭제하는 작업이 매우 빠르다.</p>\n<p>의존성 패키지의 용량이 작아지면서 Zero-Install이라는 개념이 생겼다.\nZero-Install이란 프로젝트를 클론했을 때, npm install과 같은 명령어를 사용하여 필요한 패키지를 다운로드 할 필요가 없다는 의미이다.</p>\n<p>어떻게 가능한 것일까?</p>\n<p>프로젝트를 처음 구성했을 때 가장 먼저 하는 일은 git 저장소를 생성하고 <code>.gitignore</code>에 <code>/node_modules</code>를 추가하는 것이였다.\n그 이유는 node_modules가 무겁고 환경에 따라서 동작이 달라질 수 있기 때문이다.</p>\n<p>하지만 yarn berry의 경우 zip 파일로 용량이 상대적으로 적고, .pnp.cjs 파일을 이용하여 의존성이 관리되기 때문에 외부 환경에 영향을 받지 않는다.\n따라서 의존성 파일을 git을 사용하여 버전관리를 해도 좋다. 의존성 파일을 코드 저장소에 포함시킴으로써 우리는 프로젝트를 클론하기만 하면 패키지 install없이 시작할 수 있다.</p>\n<h1>어떤 패키지 매니저를 사용할 것인가?</h1>\n<p>나는 yarn berry를 사용하여 프로젝트를 진행하기로 결정하였다.</p>\n<p>그 이유는 3가지이다.</p>\n<ol>\n<li>엄격한 의존성 관리가 가능하다.</li>\n<li>내가 진행하는 프로젝트의 수는 그렇게 많지 않다. pnpm을 사용하여 패키지 중복 다운로드 문제를 해결함으로써 크게 디스크 공간이 세이브 되지 않는다. (현재 디스크 공간도 여유롭다.)</li>\n<li>Zero-Install이 가능하며 의존성 파일의 크기가 작아짐으로써 CI 시간을 절약할 수 있다.</li>\n</ol>","id":"09245a9f-0302-56b2-b221-d0eb5db7bf7a"}}},"staticQueryHashes":["4031756233","4237942306"],"slicesMap":{}}