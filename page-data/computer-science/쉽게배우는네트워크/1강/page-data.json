{"componentChunkName":"component---src-templates-post-template-tsx","path":"/computer-science/쉽게배우는네트워크/1강/","result":{"pageContext":{"node":{"fields":{"slug":"/computer-science/쉽게배우는네트워크/1강/"},"excerpt":"네트워크란? 네트워크란 노드라고 불리는 장치들이 통신 링크로 연결된 집합체를 의미한다. 장치와 링크는 각각 2개의 분류로 나뉘게 되는데 장치는 네트워크 내,외부를 기준으로, 링크는 무선, 유선을 기준으로 나뉘게 된다. 좋은 네트워크란? 좋은 네트워크란 우수한 성능, 신뢰성, 보안성을 보유한 네트워크이다. 성능 성능은 처리량과 지연 시간으로 측정된다. 처리량: 단위 시간 당 얼마나 많은 트래픽을 통과시킬 수 있는가. 트래픽을 많이 처리할 수 있…","frontmatter":{"date":"2022-01-02T00:00:00.000Z","description":"네트워크 구조와 종류","title":"쉽게 배우는 네트워크 1강"},"html":"<h1>네트워크란?</h1>\n<p>네트워크란 노드라고 불리는 <strong>장치</strong>들이 통신 <strong>링크</strong>로 연결된 집합체를 의미한다.</p>\n<p>장치와 링크는 각각 2개의 분류로 나뉘게 되는데 장치는 네트워크 내,외부를 기준으로, 링크는 무선, 유선을 기준으로 나뉘게 된다.</p>\n<h1>좋은 네트워크란?</h1>\n<p>좋은 네트워크란 우수한 <strong>성능, 신뢰성, 보안성</strong>을 보유한 네트워크이다.</p>\n<ol>\n<li>\n<p>성능</p>\n<p>성능은 처리량과 지연 시간으로 측정된다.</p>\n<ul>\n<li>처리량: 단위 시간 당 얼마나 많은 트래픽을 통과시킬 수 있는가. 트래픽을 많이 처리할 수 있을수록 우수하다.</li>\n<li>경유 시간: 한 장치에서 다른 장치로 데이터가 전달되는데 걸리는 시간이다. 경유 시간이 짧을수록 우수하다.</li>\n<li>왕복 시간(RTT:Round Trip Time): 출발지에서 목적지까지 갔다가 돌아오는데 걸리는 시간. RTT가 짧을수록 우수하다.</li>\n<li>응답 시간: 요청을 받았을 떄 이에 응답에 소요되는 시간. 응답 시간이 짧을수록 우수하다.</li>\n</ul>\n</li>\n<li>\n<p>신뢰성</p>\n<p>장애 빈도와 장애 발생 후 회복 시간, 재난에 대한 견고성 등으로 평가된다.</p>\n</li>\n<li>\n<p>보안성</p>\n<p>네트워크에서 정보유출이나 불법적인 침입으로부터 보안이 좋을수록 우수하다.</p>\n</li>\n</ol>\n<h1>통신 링크에 대해서</h1>\n<p>통신 링크는 노드 사이의 패킷을 전달하기 위해서 사용된다.\n통신 링크의 방식은 2가지로 분류된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 425px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f76232b58d8034b850eee920b12ecab2/2fbbf/link.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54.85714285714286%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABdElEQVR42oVTXU+CUBjm//+D1rpxrXXpunFdqK0tqaGgaSs4HBLtwqnDkg8Bgae9x1AUtWd79sJ73k/Og+T7AWazObIsQ5IkJa7XaziOA9d1kaZp6ZzyPNfDfDYHQbKsT1Qq1xgMBjAMA7qub0nvRFVV0e/3YZrm3jmRc45WS8bNzS2CIIBEXWgCsvkEZInktywLo9EItm2L4pRU3Ibi4jiG4yyEX8IZUEDehJLyFc9BypPIHvJUk2NM/6xUTDwVfKzBKb9YOQwjJEmK/yDLz1A7asnfepKhdbRdwVrtHtXqHeI4EvLwfR/T6RSTyUQ8ky+KQnS0Hh5lBeFqhR/Px7cfIA5DvLQ1KNrrrmCj8YCLyyvY9lDcJGNMyKTb7QpZMGbCMhl65hDNdxu2aUDRLTTfOL44g/xhgS1Wm4LL5VLoy2AMURSV1skv7BDc5Ggr7cJHpThsdEh/Q1H5VITgeR7G47GYkpqS1rYFOUe93txTCJDhFwDJR+eDBf2uAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"link\"\n        title=\"link\"\n        src=\"/static/f76232b58d8034b850eee920b12ecab2/2fbbf/link.png\"\n        srcset=\"/static/f76232b58d8034b850eee920b12ecab2/4edbd/link.png 175w,\n/static/f76232b58d8034b850eee920b12ecab2/13ae7/link.png 350w,\n/static/f76232b58d8034b850eee920b12ecab2/2fbbf/link.png 425w\"\n        sizes=\"(max-width: 425px) 100vw, 425px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>\n<p>일대일 연결(point-to-point)</p>\n<ul>\n<li>노드와 노드가 1개의 통신 링크에 의해서 연결되어 있는 상태</li>\n<li>보내는 사람을 받는 사람쪽에서 확실히 알 수 있다는 특징이 있다.</li>\n</ul>\n</li>\n<li>\n<p>멀티 포인트(multi-point, multi-drop)</p>\n<ul>\n<li>선 하나에 여러 개의 시스템이 상호 공유하는 상태</li>\n</ul>\n</li>\n</ol>\n<h1>네트워크 토폴로지</h1>\n<p><img src=\"https://cdn.ttgtmedia.com/rms/onlineimages/whatis-network_topology_02-f_mobile.png\" alt=\"network topology\">\n구성 요소인 노드와 링크가 어떻게 배치되었는지를 의미한다. 총 4개로 분류된다.</p>\n<ol>\n<li>\n<p>Mesh</p>\n<p>여러 장치들이 상관성 없이 연결되어있는 구조.</p>\n<p>완전 메시형과 부분 메시형이 있다. 완전 메시형은 모든 노드들끼리 일대일로 연결된 구조이고, 부분 메시형은 2-3개의 장치들과만 연결된다.</p>\n<p>장점: 안정성과 보안성이 뛰어나고, 매우 많은 연결을 지니고 있기에 한 노드가 고장난다고 해도 네트워크가 먹통이 되는 일은 발생하지 않는다.</p>\n<p>단점: 비싸다. 모든 노드를 연결하려면 케이블이 그만큼 많이들고 설치하는데 시간이 오래걸린다. 노드를 추가할수록 케이블에 드는 비용이 기하급수적으로 증가한다.</p>\n</li>\n<li>\n<p>Star</p>\n<p>허브라고 하는 통신 장비가 필수적으로 존재한다. 컴퓨터를 케이블을 통해 허브와 일대일로 연결한다.\n허브를 중심으로 컴퓨터 배치 모양이 별과 같다하여 스타 토폴로지라고 한다. 가장 흔하게 이용되는 토폴로지이다.</p>\n<p>장점: 각각의 노드는 중앙 허브로부터 독립적으로 연결되어 있어서, 노드에 이상이 발생해도 다른 노드에 미치는 영향이 없다. 메시 토폴로지와 다르게 네트워크를 구성하는데 상대적으로 적은 케이블을 사용하기에 확장하거나 줄여나갈 때 유리하다.</p>\n<p>단점: 중앙 허브가 다운되면 전체 네트워크가 먹통이 된다.</p>\n</li>\n<li>\n<p>Bus</p>\n<p>케이블 하나를 여러개의 시스템이 공유하는 구조.\n하나의 긴 케이블에 여러 장치들이 멀티 포인트 링크 형태로 연결되어있다.</p>\n<p>장점: 네트워크 배치가 단순하여 모든 장치가 하나의 케이블로 연결되기 때문에 비용이 효율적이다. 소규모 네트워크에 적합하다.</p>\n<p>단점: 케이블이 고장나면 먹통이 된다. 버스 토폴로지는 기본적으로 높은 대역폭을 가지지만, 노드가 추가될수록 대역폭이 낭비되어 데이터 전송 속도가 느려진다. 따라서 소규모 네트워크에 적합하다.</p>\n</li>\n<li>\n<p>Ring</p>\n<p>링의 형태(원형)로 구성되어있는 구조. 데이터가 링을 따라서 한 방향, 또는 양방향으로 흐르며 좌,우 이웃 노드가 반드시 존재한다.</p>\n<p>장점: 한번에 하나의 노드에서만 데이터 전송이 가능하기에 패킷 충돌 위험이 없기에 데이터를 오류없이 잘 전달할 수 있다. 설치 비용이 저렴하고 문제가 있는 노드를 쉽게 알 수 있다.</p>\n<p>단점: 데이터를 전달할 때 목적지 노드에 도착하기 위해서 중간 노드를 경유하는데 이런 특징 때문에 노드 하나에 문제가 발생하면 전체 네트워크가 먹통이 될 수 있다. 노드를 추가 또는 제거하기 위해서는 전체 네트워크를 중단해야한다. 원이 끊어지기 때문이다.</p>\n</li>\n<li>\n<p>Tree</p>\n<p>스타 토폴로지는 각각의 노드가 허브에 직접적으로 연결되었지만, 트리 토폴로지에서 노드는 부모-자식 계층 구조로 연결되어 있다. 스타 토폴로지와 버스 토폴로지가 결합된 구조이다.</p>\n<p>장점: 스타, 버스 토폴로지와 마찬가지로 노드의 추가와 네트워크 확장에 용이하다.</p>\n<p>단점: 중앙 허브가 고장나면 먹통이 된다. 계층 구조로 이루어졌기 때문에 추가되는 노드가 많아질수록 관리가 어려워지고 케이블 양이 많이들어 비용이 높아진다.</p>\n</li>\n</ol>\n<p>실제로 사용되는 네트워크 토폴리지는 여러 구조를 결합한 복잡한 구조를 갖고 있다.</p>\n<h1>네트워크 분류</h1>\n<p>네트워크는 크기, 소유권, 구조 등에 의해서 분류한다.</p>\n<ol>\n<li>\n<p>LAN(Local-area network)</p>\n<p>Local의 기준을 어떻게 잡을지는 사실 애매하다. LAN에 속하는 네트워크는 소유주가 개인이라는 특징을 통해서 기준을 생각해볼 수 있다. 집, 사무실, 한 층, 한 캠퍼스, 한 건물을 등 개인이 소유한 네트워크의 범위를 로컬 area라고 간주할 수 있다.</p>\n</li>\n<li>\n<p>MAN(Metropolitan-area network)</p>\n<p>metropolitan라는 단어의 뜻에 맞게 한 도시 정도를 커버하는 영역의 네트워크를 말한다. 링 토폴로지 형태를 띈다.</p>\n</li>\n<li>\n<p>WAN(Wide-area network)</p>\n<p>전국, 전세계 규모의 굉장히 광범위한 네트워크로 인터넷이 여기에 속한다.</p>\n</li>\n</ol>\n<h1>참고</h1>\n<p><a href=\"https://www.youtube.com/watch?v=D9KKEKETLmI&#x26;list=PLFpZ7zSiHhPxrib8i4XPRKxB6FR9_NlCo\">쉽게 배우는 네트워크 1강</a></p>\n<p><a href=\"https://www.edrawsoft.com/kr/for-beginners/what-is-network-topology.html\">https://www.edrawsoft.com/kr/for-beginners/what-is-network-topology.html</a></p>","id":"ab9f11b2-d634-53e3-8e2e-e813489890ad"},"previous":null,"next":{"fields":{"slug":"/algorithm/스티커모으기/"},"excerpt":"문제 링크 다이나믹 프로그래밍인 이유 문제의 해결 전략이 다이나믹 프로그래밍으로 도출되어야 하는 이유는 2가지이다. 시간 복잡도를 줄여야 한다. 작은 문제의 해답이 그것을 포함하는 큰 문제에서도 동일하다. 1. 시간 복잡도 스티커의 최대 길이는 100,000개이다. 만일 완전 탐색으로 어떤 스티커를 뜯었는지, 안뜯었는지 고려하여 구한다면 시간 복잡도는 최대 O(2^50000)으로 불가능하다. 2. 작은 문제의 해답이.. 스티커 전체 배열이 […","frontmatter":{"date":"2022-09-30T00:00:00.000Z","description":"다이나믹 프로그래밍","title":"스티커 모으기"},"html":"<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/12971\">문제 링크</a></p>\n<h1>다이나믹 프로그래밍인 이유</h1>\n<p>문제의 해결 전략이 다이나믹 프로그래밍으로 도출되어야 하는 이유는 2가지이다.</p>\n<ol>\n<li>시간 복잡도를 줄여야 한다.</li>\n<li>작은 문제의 해답이 그것을 포함하는 큰 문제에서도 동일하다.</li>\n</ol>\n<h3>1. 시간 복잡도</h3>\n<p>스티커의 최대 길이는 100,000개이다. 만일 완전 탐색으로 어떤 스티커를 뜯었는지, 안뜯었는지 고려하여 구한다면 시간 복잡도는 최대 O(2^50000)으로 불가능하다.</p>\n<h3>2. 작은 문제의 해답이..</h3>\n<p>스티커 전체 배열이 <code>[1,3,5,6,4]</code>라고 가정해보자. 부분 배열 <code>[1,3,5]</code>가 있다고 하였을 때, 뽑을 수 있는 가장 최댓값인 5이다. 부분 배열 <code>[1,3,5,6]</code>에서 <code>[1,3,5]</code>의 최댓값은 5로 만족한다. 하지만 5를 뽑는 경우 6을 뽑을 수 없다. 따라서 이 부분 배열의 경우 3과 6을 뽑아야 최댓값이다. 3의 경우는 부분 배열 <code>[1,3]</code>의 최댓값이라고 할 수 있다. 현재에 해당되는 스티커를 뗀다면, 2번 째 전 부분 배열의 최댓값과 현재의 스티커 점수를 더한 것이고 떼지 않는다면 1번 째 전 부분 배열의 최댓값과 동일하다.</p>\n<h1>해결 전략</h1>\n<p>다이나믹 프로그래밍이라는 사실도 알아냈고 규칙도 찾았으니 점화식을 세워보도록 한다.</p>\n<pre><code>d[i] = max(d[i-2]+i번째 스티커점수, d[i-1])\n(단, d[i]는 부분 배열 i까지의 최댓값을 의미한다.)\n</code></pre>\n<p>하지만 위 점화식은 맨 처음 스티커를 떼는 경우를 만족시키지 못한다. 맨 처음 스티커를 떼는 경우 맨 마지막 스티커도 제거 되어야 하기 때문이다. 따라서 맨 처음 스티커를 떼는 경우, 맨 처음 스티커를 떼지 않는 경우 2가지로 나눠서 문제를 풀어보도록 한다.</p>\n<pre><code class=\"language-javascript\">if (sticker.length &#x3C;= 2) return Math.max(...sticker)\n</code></pre>\n<p>만일 스티커의 개수가 2개 이하라면, 배열 내의 최댓값을 리턴하면 된다. 맨 처음 스티커를 떼지 않는 경우를 고려할 때 스티커 배열의 3번째 요소에 접근하기 때문에 위와 같이 처리해준다.</p>\n<pre><code class=\"language-javascript\">const len = sticker.length\nconst d = Array(len - 1).fill(0)\n\nd[0] = sticker[0]\nd[1] = d[0]\nfor (let i = 2; i &#x3C; d.length; i++) {\n  d[i] = Math.max(d[i - 2] + sticker[i], d[i - 1])\n}\n\nconst max_first = Math.max(...d)\n</code></pre>\n<p>첫 번째 스티커를 뜯어냈을 경우 코드는 위와 같다. <code>d[1] = d[0]</code>인 이유는 <code>d[1]</code>의 경우 스티커를 뜯어낼 수 없기 떄문에 <code>d[0]</code>의 값과 동일하게 넣어주어야 한다.</p>\n<pre><code class=\"language-javascript\">const d2 = Array(len - 1).fill(0)\nd2[0] = sticker[1]\nd2[1] = Math.max(d2[0], sticker[2])\n\nfor (let i = 2; i &#x3C; d.length; i++) {\n  d2[i] = Math.max(d2[i - 2] + sticker[i + 1], d2[i - 1])\n}\nconst max_second = Math.max(...d2)\n\nreturn Math.max(max_first, max_second)\n</code></pre>\n<p>첫 번째 스티커를 뜯어내지 않았을 경우 코드는 위와 같다. 첫 번째 스티커를 뜯지 않았기 때문에(제외시켰기 떄문에) 테이블은 스티커의 첫 번째 요소에서부터 시작하도록 한다. 그리고 <code>d2[1]</code>의 경우 만일 <code>sticker[2]</code>의 크기가 <code>d2[0]</code>의 크기보다 크다면, <code>sticker[2]</code>를 뜯는게 더 값이 크기 때문에 둘 중 큰 값을 가지도록 한다.</p>\n<h1>전체 코드</h1>\n<pre><code class=\"language-javascript\">function solution(sticker) {\n  if (sticker.length &#x3C;= 2) return Math.max(...sticker)\n\n  const len = sticker.length\n  const d = Array(len - 1).fill(0)\n\n  d[0] = sticker[0]\n  d[1] = d[0]\n  for (let i = 2; i &#x3C; d.length; i++) {\n    d[i] = Math.max(d[i - 2] + sticker[i], d[i - 1])\n  }\n  const max_first = Math.max(...d)\n\n  const d2 = Array(len - 1).fill(0)\n  d2[0] = sticker[1]\n  d2[1] = Math.max(d2[0], sticker[2])\n\n  for (let i = 2; i &#x3C; d.length; i++) {\n    d2[i] = Math.max(d2[i - 2] + sticker[i + 1], d2[i - 1])\n  }\n  const max_second = Math.max(...d2)\n\n  return Math.max(max_first, max_second)\n}\n</code></pre>","id":"22a5aab2-66b9-5717-bdb8-1e8b06438abb"}}},"staticQueryHashes":["1749904500","4031756233"],"slicesMap":{}}